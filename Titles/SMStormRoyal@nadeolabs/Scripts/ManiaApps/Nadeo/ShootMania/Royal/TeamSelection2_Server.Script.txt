/**
 *  team selection UI
 */
#Const Version    "2018-06-21"
#Const ScriptName "ManiaApps/Nadeo/TeamSelection_Server.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "Libs/Nadeo/ShootMania/Royal/Constants2.Script.txt" as Const
#Include "MathLib" as ML
#Include "Libs/Nadeo/Color.Script.txt" as Color


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Const C_CanInvitePlayerFromAnotherTeam False //< Can a player select as teammate a player that is already in a team
#Const ColorList [
/*RED*/					<1., 0., 0.>,
/*Green*/				<0., 1., 0.>,
/*Blue*/				<0., 0., 1.>,
/*Yellow*/			<1., 1., 0.>,
/*Cyan*/				<0., 1., 1.>,
/*Purple*/			<0.7, 0., 0.7>,
/*RED*/					<0., 0.4, 0.1>,
/*Salmon*/			<1., 0.2, 0.2>,
/*Brown*/				<0.4, 0.2, 0.09>
]
#Const ClansIds [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]

#Struct KTeamColorSet {
	Vec3 NewColor;
	Boolean IsUsed;
}

#Struct KTeamClanId {
	Integer ClanId;
	Boolean IsUsed;
}

#Struct KTeam {
	Text Leader;
	Text[] AllTeamMembers;
	Vec3 TeamColor;
	Boolean TeamInAutoFill;
	Boolean TeamReady;
	Integer MaxMatesNumber;
	Integer ClanId;
	Boolean VipInTeam;
	Integer TeamScore;
	Text	TeamEventName;
	Integer PointsScored;
	Integer BonusStreakValue;
	Integer TeamHitCombo;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Globales
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //

declare Boolean G_InvitationSent;
declare Text[] G_PlayerInTeams;
declare Text[] G_AllPlayersInAnyTeam;
declare KTeam[Text] G_AllTeams;
declare Integer G_TeamCreated;
declare Text[] G_PlayersWithNoTeam;
declare KTeamColorSet[Vec3] G_TeamColor;
declare KTeamClanId[Integer] G_ClansIds;
declare Boolean G_IsColorListInstantiate;
declare Text[] G_LeadersToDisplay;
declare Text[] G_PlayersWaiting;
declare Text[] G_LeadersInFullTeam;
declare Text[] G_InviterLeaveTeamCreation;
declare Text[] G_PlayersWaitingForAnAutoFillTeam;
declare Text[] G_PlayersJoiningAnAutoFillTeamAndCanGoesLeader;
declare Text[] G_LeadersReady;

declare Integer G_PlayersInAutoJoinTimer;
declare Integer G_PrevPlayersInAutoJoinTimer;
declare Integer G_PrevTeamRefresh;

declare Ident[] G_PlayerList;
declare Text[] G_PlayerLoginToRemove;
declare Ident[Text] G_IdsOfPlayerInTeam;

declare Text[] G_PlayerLoginList;
declare Text[] G_PlayerSpectating;
declare Text[] G_InvitersToDelete;

declare Integer G_Count;
declare Integer G_PrevCall;

declare Text[] G_PlayersNeedHelp;
declare Integer PlayersNeedingHelpTimer;
declare Integer PrevPlayersNeedingHelpTimer;
declare Integer PrevTeamRefresh;
declare Integer PrevAllPlayersCount;
declare Integer PrevPlayersCount;

declare Integer[Integer] G_PlacesAvailable;
declare Integer G_ClansCount;


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Public
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Allow the display of team selection UI
 *	for the given player
 *
 *	@param	_Enabled									True to display the team selection UI,
 *																		False otherwise
 *	@param	_Player										The player to update
 */
Void Enable(Boolean _Enabled, CPlayer _Player) {
	if (_Player == Null) return;
	declare netwrite Net_TeamSelection_IsEnabled for _Player = False;
	Net_TeamSelection_IsEnabled = _Enabled;
}

/** Called once the server is started
 *
 *	@Action														Initialize every value in the server
 */
Void OnStartServer(){
	
	declare netwrite Integer	ServerRestartTime							for Teams[0];
	ServerRestartTime = Now;
	declare netwrite Text			Net_LoginOfLeader					for Teams[0];
	Net_LoginOfLeader = "";
	declare netwrite Text[]		Net_Array_LoginOfLeader		for Teams[0];
	Net_Array_LoginOfLeader.clear();
	declare netwrite Integer	TeamRefresh								for Teams[0];
	TeamRefresh = 0;
	declare netwrite Integer	Net_TS2_PlayersPerTeam		for Teams[0];
	Net_TS2_PlayersPerTeam = 0;
	declare netwrite Text[]		Client_PlayersInTeamList	for Teams[0];
	Client_PlayersInTeamList.clear();
	declare netwrite Text[]		Net_LeadersToDisplay			for Teams[0];
	Net_LeadersToDisplay = [];
	declare netwrite Text[]		PlayersInTeamList					for Teams[0];
	PlayersInTeamList = [];
	declare netwrite Text[]   Net_InvitersToDelete			for Teams[0];
	Net_InvitersToDelete = [];
	declare netwrite Text[]		Net_AllPlayersInTeam			for Teams[0];
	Net_AllPlayersInTeam = [];
	declare netwrite Text[]		LeadersListForClient			for Teams[0];
	LeadersListForClient = [];
	declare netwrite Text[] Net_LeaderSpawnedList 			for Teams[0];
	Net_LeaderSpawnedList = [];
	declare netwrite Text[] Net_LeaderReadyToSpawn			for Teams[0];
	G_AllPlayersInAnyTeam = [];
 	declare netwrite Text[][Text] Net_AllTeamsMembersInServer for Teams[0];
	Net_AllTeamsMembersInServer.clear();
	G_PlayersWithNoTeam = [];
	declare netwrite Text[] Net_PlayersWithNoTeam for Teams[0];
	Net_PlayersWithNoTeam = [];
	declare netwrite Text[] Net_PlayersInAutoJoin for Teams[0];
	Net_PlayersInAutoJoin = [];
	declare netwrite Text[] Net_PlayersInATeam for Teams[0];
	Net_PlayersInATeam = [];
	G_AllTeams = [];
	G_PlayersWithNoTeam = [];
	G_PlayersWaitingForAnAutoFillTeam = [];
	G_PlayersJoiningAnAutoFillTeamAndCanGoesLeader = [];
	
	foreach(Player in Players){
		declare UI <=> UIManager.GetUI(Player);
		declare netwrite Boolean	IsPlayerSpawned							for UI;
		declare netwrite Text[]		SquadForClient							for UI;
		declare netwrite Integer UpdateClientSquad 						for UI;
		declare netwrite Text[]		Client_PlayersInTeamList		for UI;
		declare netwrite Boolean	InATeamForMode							for UI;
		declare netwrite Text[] PlayerMembers 								for Player;
		declare netwrite Boolean IsPlayersUpdated 						for UI;
		declare netwrite Net_SelectedPlayer 									for UI = "";
		declare netwrite Text	LoginOfInviter 									for UI;
		declare netwrite Integer HasBeenInvitedTime 					for UI;
		declare netwrite Text	LoginOfRequester 								for UI;
		declare netwrite Boolean IsInTeam 										for UI;
		declare netwrite Integer IsInTeamTimer 								for UI;
		declare netwrite Text[] Net_PlayerDisplayedForMakers  for UI;
		declare netwrite Text[] Net_PlayersNeedHelp 					for UI;
		declare netwrite Text[] MatesHealed 									for UI;
		declare netwrite Boolean PutInAutoJoin 								for UI;
		declare netwrite Integer AutoAutoFillTimer 						for UI;
		declare netwrite Boolean Net_RS_PlayerIsSpawning 			for UI;
		declare netwrite Integer[Integer] Net_PlacesAvailable 	for UI;
		declare netwrite Integer Net_TeamSelection2_RoundCount for UI;
		declare Boolean PlayerCanGoInTeam 										for Player;
		Net_PlacesAvailable = [];
		PlayerCanGoInTeam = False;									
		PutInAutoJoin = False;
		AutoAutoFillTimer = Now;
		Net_PlayersNeedHelp = [];
		PlayersNeedingHelpTimer = Now;
		IsPlayerSpawned = False;
		Net_PlayerDisplayedForMakers = [];
		SquadForClient = [];
		UpdateClientSquad = Now;
		MatesHealed = [];
		Client_PlayersInTeamList = [];
		InATeamForMode = False;
		PlayerMembers = [];
		IsPlayersUpdated = False;
		Net_SelectedPlayer = "";
		IsInTeam = False;
		IsInTeamTimer = Now;
		LoginOfInviter = "";
		Net_RS_PlayerIsSpawning = False;
		Net_TeamSelection2_RoundCount = 0;
	}

	G_PlayerInTeams.clear();
	
}

Void ShowTeamSelectionUI(){
	declare netwrite Boolean HideMenu for Teams[0];
	HideMenu = False;
}

Void HideTeamSelectionUI(){
	declare netwrite Boolean HideMenu for Teams[0];
	HideMenu = True;	
}



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the validated teammate of a player
 *	A teammate is validated if both side
 *	agreed to play together
 *
 *	@param	_Player										The player to check
 *
 *	@return														The validated teammate if found,
 *																		Null otherwise
 */
CPlayer GetValidatedTeammate(CPlayer _Player) {
	if (_Player == Null) return Null;
	
	declare TeamSelection_Teammate for _Player = NullId;
	if (TeamSelection_Teammate != NullId && Players.existskey(TeamSelection_Teammate)) {
		declare Teammate <=> Players[TeamSelection_Teammate];
		declare TeamSelection_Teammate as ReverseTeammate for Teammate = NullId;
		if (ReverseTeammate != NullId && Players.existskey(ReverseTeammate) && Players[ReverseTeammate] == _Player) {
			return Teammate;
		}
	}
	
	return Null;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the requested teammate of a player
 *	A teammate is requested if at least one side
 *	agreed to play together
 *
 *	@param	_Player										The player to check
 *
 *	@return														The requested teammate if found,
 *																		Null otherwise
 */
CPlayer GetRequestedTeammate(CPlayer _Player) {
	if (_Player == Null) return Null;
	
	declare TeamSelection_Teammate for _Player = NullId;
	if (TeamSelection_Teammate != NullId && Players.existskey(TeamSelection_Teammate)) {
		return Players[TeamSelection_Teammate];
	}
	
	return Null;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Send the current player selection to the UI
Void UpdatePlayerSelection() {
	declare PlayerSelection = Text[Text];
	
	foreach (Player in Players) {
		declare TeamSelection_Teammate for Player = NullId;
		if (TeamSelection_Teammate != NullId && Players.existskey(TeamSelection_Teammate)) {
			PlayerSelection[Player.User.Login] = Players[TeamSelection_Teammate].User.Login;
		}
	}
	
	declare netwrite Net_TeamSelection_PlayerSelection for Teams[0] = Text[Text];
	declare netwrite Net_TeamSelection_PlayerSelectionUpdate for Teams[0] = -1;
	Net_TeamSelection_PlayerSelection = PlayerSelection;
	Net_TeamSelection_PlayerSelectionUpdate = Now;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Select if the given player use a
 *	random teammate or not
 *
 *	@param	_IsRandom									True to use a random teammate,
 *																		False otherwise
 *	@param	_Player										The player to update
 */
Void UseRandomTeammate(Boolean _IsRandom, CPlayer _Player) {
	if (_Player == Null) return;
	
	declare TeamSelection_UseRandomTeammate for _Player = False;
	TeamSelection_UseRandomTeammate = _IsRandom;
	
	declare netwrite Net_TeamSelection_UseRandomTeammate for _Player = False;
	Net_TeamSelection_UseRandomTeammate = TeamSelection_UseRandomTeammate;
	
	if (_IsRandom) {
		declare TeamSelection_Teammate for _Player = NullId;
		TeamSelection_Teammate = NullId;
	}
	
	UpdatePlayerSelection();
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Check if the given player has a
 *	a random teammate
 *
 *	@param	_Player										The player to check
 *
 *	@return														True if the player has a random teammate,
 *																		False otherwise
 */
Boolean HasRandomTeammate(CPlayer _Player) {
	if (_Player == Null) return False;
	
	declare TeamSelection_UseRandomTeammate for _Player = False;
	return TeamSelection_UseRandomTeammate;
}


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Set the teammate of a player
 *
 *	@param	_Teammate									The teammate to associate
 *	@param	_Player										The player to update
 */
Void SetTeammate(CPlayer _Teammate, CPlayer _Player) {
	if (_Player == Null) return;
	
	declare TeamSelection_Teammate for _Player = NullId;
	if (_Teammate != Null && _Player != _Teammate) {
		if (
			C_CanInvitePlayerFromAnotherTeam ||
			GetValidatedTeammate(_Teammate) == Null
		) {
			TeamSelection_Teammate = _Teammate.Id;
			UseRandomTeammate(False, _Player);
			
			// If both players now form a team
			// Cancel any teammate requests they previously received
			if (
				!C_CanInvitePlayerFromAnotherTeam &&
				GetValidatedTeammate(_Teammate) != Null
			) {
				foreach (Player in AllPlayers) {
					if (Player != _Teammate && Player != _Player) {
						declare TeamSelection_Teammate as RequestedTeammate for Player = NullId;
						if (RequestedTeammate == _Teammate.Id || RequestedTeammate == _Player.Id) {
							RequestedTeammate = NullId;
						}
					}
				}
			}
		}
	} else {
		TeamSelection_Teammate = NullId;
	}
	
	UpdatePlayerSelection();
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Send the list of players currently
 *	in the lobby to the UI
 *
 *	@param	_PlayerIds								The id of the players currently in the lobby
 */
Void SetLobbyPlayers(Ident[] _PlayerIds) {
	declare Logins = Text[];
	foreach (PlayerId in _PlayerIds) {
		if (AllPlayers.existskey(PlayerId)) {
			Logins.add(AllPlayers[PlayerId].User.Login);
		}
	}
	
	declare netwrite Net_TeamSelection_PlayersInLobby for Teams[0] = Text[];
	declare netwrite Net_TeamSelection_PlayersInLobbyUpdate for Teams[0] = -1;
	Net_TeamSelection_PlayersInLobby = Logins;
	Net_TeamSelection_PlayersInLobbyUpdate = Now;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Find the player owning the given UI
 *
 *	@param	_UI												The UI to check
 *
 *	@return														The owning player if found,
 *																		Null otherwise
 */
CPlayer FindPlayerFromUI(CUIConfig _UI) {
	if (_UI == Null) return Null;
	
	foreach (Player in Players) {
		if (_UI == UIManager.GetUI(Player)) {
			return Player;
		}
	}
	
	return Null;
}

/** Get the Requested CPlayer
 *
 *	@param	_LoginOfInvited										The login of the player invited
 *
 * @return PotentialInvited										The CPlayer corresponding to the login
 */
CPlayer GetRequestedFromLogin(Text _LoginOfInvited) {
	foreach (PotentialInvited in Players) {
		if (PotentialInvited.User.Login == _LoginOfInvited) {
			return PotentialInvited;
		}
	}
	return Null;
}

/** Get the Chief from Login
 *
 *	@param	_LoginOfChief										The login of the Chief
 *
 *	@return	PotentialChief									The CPlayer corresponding to the login
 */
CPlayer GetChiefFromLogin(Text _LoginOfChief){
	foreach (PotentialChief in Players) {
		if (PotentialChief.User.Login == _LoginOfChief) {
		return PotentialChief;
		}
	}
	return Null;
}

/** Get the Requester corresponding to the Event.UI
 *
 *	@param	_Event										The Event send, containing the UI of the player who activate it
 *	@return	PotentialRequester				The Player correponding to the UI of the Event
 */
CPlayer GetRequesterFromEvent(CUIConfigEvent _Event) {
	foreach (PotentialRequester in Players) {
		declare UIOfPotentialRequester <=> UIManager.GetUI(PotentialRequester);
		if (UIOfPotentialRequester == _Event.UI) {	
			return PotentialRequester;
		}
	}
	return Null;
}

/** Play a sound and notice if someone is close to win
 *
 *	@param	_Event										The Event send, containing the UI of the player who activate it
 *	@return	PotentialInvited					The potential invited CPlayer 
 */
CPlayer GetInvitedFromEvent(CUIConfigEvent _Event){
	foreach (PotentialInvited in Players){
		declare UI <=> UIManager.GetUI(PotentialInvited);
		if (UI == _Event.UI) {
			return PotentialInvited;
		}
	}
	return Null;
}

/** Ensure that both Requester and Requested are not Null
 *
 *	@param	_Requested										The player who scored a point
 *	@param	_Requester										The points limit to reach to win
 */
Boolean AreRequestedAndRequesterNotNull(CPlayer _Requested, CPlayer _Requester) {
	if (_Requested != Null && _Requester != Null) {
		return True;
	} else {
		return False;
	}
	return False;
}


/** Send the invited to the Requested Player
 *
 *	@param	_Requester										The Requester
 *	@param	_Requested										The Requested who receive the invite
 */
Void GiveInviteFromRequesterToRequested(CPlayer _Requester, CPlayer _Requested) {
	declare UIOfRequested <=> UIManager.GetUI(_Requested);
	declare netwrite Text	LoginOfInviter for UIOfRequested;
	LoginOfInviter = _Requester.User.Login;
	if(_Requester != Null && LoginOfInviter != ""){
		declare netwrite Integer HasBeenInvitedTime for UIOfRequested;
		HasBeenInvitedTime = Now;
	}
}

/** Play a sound and notice if someone is close to win
 *
 *	@param	_Player										The player who scored a point
 *	@param	_PointsLimit							The points limit to reach to win
 */
Void SendInviteFromRequesterMemberToLeader(CPlayer _Requester, CPlayer _Requested) {
	declare UIOfRequested <=> UIManager.GetUI(_Requested);
	declare netwrite Text	LoginOfRequester for UIOfRequested;
	LoginOfRequester = _Requester.User.Login;
	declare netwrite Integer HasBeenRequestedTime for UIOfRequested;
	HasBeenRequestedTime = Now;
}

/** Get the User.Login of a Given CPlayer
 *
 *	@param	_Player										The player who scored a point
 */
Text GetNameFromPlayer (CPlayer _Player) {
	foreach(Player in Players){
		if (Player == _Player) {
			return Player.User.Login;
		}
	}
	return "";
}

/** Get the User.Name of a Given CPlayer
 *
 *	@param	_Player										The player who scored a point
 */
Text GetRealNameFromPlayer (CPlayer _Player){
	foreach(Player in Players){
		if (Player == _Player) {
			return Player.User.Name;
		}
	}
	return "";
}

/** Get Player from a Given Login
 *
 *	@param	_Player										The player who scored a point
 *	@param	_PointsLimit							The points limit to reach to win
 */
CPlayer GetPlayerFromLogin (Text _PlayerName) {
	foreach(Player in Players){
		if (Player.User.Login == _PlayerName) {
			
			return Player;
		}
	}
	return Null;
}

/** Get Player from a Given Login
 *
 *	@param	_Player										The player who scored a point
 *	@param	_PointsLimit							The points limit to reach to win
 */
CSmPlayer GetCSmPlayerFromLogin (Text _PlayerName) {
	foreach(Player in Players){
		if (Player.User.Login == _PlayerName) {
			
			return Player;
		}
	}
	return Null;
}

CPlayer GetPlayerinAllPlayersFromLogin(Text _Login){
	foreach(Player in AllPlayers){
		if(Player.User.Login == _Login){
			return Player;
		}
	}
	return Null;
}

Void HidePlayerTeamCreationUI(Text _PlayerLogin){
	declare PlayerToHideUI <=> GetPlayerFromLogin(_PlayerLogin);
	if(PlayerToHideUI != Null){
		declare UI <=> UIManager.GetUI(PlayerToHideUI);
		declare netwrite Boolean HidePlayerUI for UI;
		HidePlayerUI = True;
	}
}

Void ShowPlayerTeamCreationUI(Text _PlayerLogin){
	declare PlayerToHideUI <=> GetPlayerFromLogin(_PlayerLogin);
	if(PlayerToHideUI != Null){
		declare UI <=> UIManager.GetUI(PlayerToHideUI);
		declare netwrite Boolean HidePlayerUI for UI;
		HidePlayerUI = False;
	}
}

Void SetPlayerReadyToSpawn(CPlayer _Player, Boolean _IsReadyToSpawn){
	if(_Player != Null){
		declare UI <=> UIManager.GetUI(_Player);
		declare netwrite Boolean IsPlayerSpawned for UI;
		declare netwrite Integer IsPlayerSpawnedTimer for UI;
		IsPlayerSpawned = _IsReadyToSpawn;
		IsPlayerSpawnedTimer = Now;
	}
}

Boolean GetIfPlayerIsReadyToSpawn(CPlayer _Player){
	if(_Player != Null){
		declare UI <=> UIManager.GetUI(_Player);
		declare netwrite Boolean IsPlayerSpawned for UI;
		return IsPlayerSpawned;
	}
	return False;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Manage Clan //

//When a team is created/modified, add the Team in the TeamsList if the team exists update the values
/** Play a sound and notice if someone is close to win
 *
 *	@param	_Player										The player who scored a point
 *	@param	_PointsLimit							The points limit to reach to win
 */
KTeam[Text] AddTeamInTeamsList(KTeam _Team) {
	
	if (!G_AllTeams.existskey(_Team.Leader)) {
		G_AllTeams[_Team.Leader] = _Team;
	}
	return G_AllTeams;
}

/** Get all The teams existing in the server
 *
 *	@param	_GetAllTeam										The player who scored a point
 */
KTeam[Text] GetAllTeams(Boolean _GetAllTeam){
	declare Text[][Text] AllTeamsMembers_Array;
	declare netwrite Text[][Text] Net_AllTeamsMembersInServer for Teams[0];
	foreach(TeamKey => Team in G_AllTeams){
		AllTeamsMembers_Array[G_AllTeams[TeamKey].AllTeamMembers[0]] = G_AllTeams[TeamKey].AllTeamMembers;
		//Remove the key if the leader isn't a Leader in G_AllTeams
	}
	foreach(TeamsMembersIndex => TeamMember in AllTeamsMembers_Array){
		if(!G_AllTeams.existskey(TeamsMembersIndex)){
			AllTeamsMembers_Array.removekey(TeamsMembersIndex);
		}
	}
	Net_AllTeamsMembersInServer = AllTeamsMembers_Array;
	return G_AllTeams;
}

Vec3 SetTeamColor(){
	foreach(ColorIndex => ColorForTeam in G_TeamColor){
		if(!ColorForTeam.IsUsed){
			G_TeamColor[ColorIndex].IsUsed = True;
			return ColorIndex;
		}
	}
	return Color::GetNewColor();
}

Void SetColorNotUsed(Vec3 _ColorToReset){
	if(ColorList.exists(_ColorToReset) && G_TeamColor.existskey(_ColorToReset)){
		G_TeamColor[_ColorToReset].IsUsed = False;
	}
}

Integer SetClanId(){
	foreach(ClanIndex => ClanId in G_ClansIds){
		if(!ClanId.IsUsed){
			G_ClansIds[ClanIndex].IsUsed = True;
			return ClanIndex;
		}
	}
	return 0;
}

Void SetClanIdNotUsed(Integer _ClanId){
	if(ClansIds.exists(_ClanId) && G_ClansIds.existskey(_ClanId)){
		G_ClansIds[_ClanId].IsUsed = False;
	}
}

//Function called if it's a leader that doesn't exist in G_AllTeams, then add the leader in this team
/** Play a sound and notice if someone is close to win
 *
 *	@param	_Leader										The Leader who own the future team
 */
KTeam CreateNewTeam(CPlayer _Leader, Integer _MaxMatesNumber) {
	declare KTeam NewTeam;
	if(_Leader != Null){
		NewTeam.Leader = _Leader.User.Login;
		declare Text LoginOfLeader = _Leader.User.Login;
		declare Real ColorValue;
		NewTeam.TeamScore = 0;
		NewTeam.MaxMatesNumber = _MaxMatesNumber;
		declare UI <=> UIManager.GetUI(_Leader);
		declare netwrite Text[] SquadForClient for UI;
		declare netwrite Boolean IsInTeam  for UI;
		declare netwrite Integer IsInTeamTimer for UI;
		IsInTeamTimer = Now;
		IsInTeam = True;
		if(!G_AllPlayersInAnyTeam.exists(_Leader.User.Login)){
			G_AllPlayersInAnyTeam.add(_Leader.User.Login);
		}
		declare netwrite Text[] Net_AllPlayersInTeam for Teams[0];
		Net_AllPlayersInTeam = G_AllPlayersInAnyTeam;
		declare netwrite Integer Net_AllPlayersInTeamTimer for Teams[0];
		Net_AllPlayersInTeamTimer = Now;
		declare netwrite Integer	TeamRefresh				 for Teams[0];
		TeamRefresh = Now;
		NewTeam.TeamColor = SetTeamColor();
		NewTeam.ClanId = SetClanId();
		NewTeam.AllTeamMembers.add(LoginOfLeader);
		SquadForClient = NewTeam.AllTeamMembers;
		AddTeamInTeamsList(NewTeam);
	}
	return NewTeam;
}

// Function called if the team already exist (Leader exist), then add the member in the Leader Team
/** Play a sound and notice if someone is close to win
 *
 *	@param	_Team										The Team to modify
 *	@param	_Member									The Member to add to the team
 */
KTeam AddMembersInExistingTeam(KTeam _Team, CPlayer _Member) {
	declare Text _LoginOfMember;
	declare KTeam _ExistingTeam = _Team;
	declare netwrite Integer TeamRefresh for Teams[0];
	if(_Member != Null){
		declare UIOfMember <=> UIManager.GetUI(_Member);
		declare PlayerInTeamLogin = GetNameFromPlayer(_Member);
		
		declare netwrite Integer Net_TS2_PlayersPerTeam for Teams[0];
		if (_ExistingTeam.AllTeamMembers.count < Net_TS2_PlayersPerTeam && _ExistingTeam.AllTeamMembers.count < _ExistingTeam.MaxMatesNumber) {
		
			_LoginOfMember = _Member.User.Login;
			if(!_ExistingTeam.AllTeamMembers.exists(_LoginOfMember)){
				_ExistingTeam.AllTeamMembers.add(_LoginOfMember);
				declare netwrite Boolean IsInTeam for UIOfMember;
				declare netwrite Integer IsInTeamTimer for UIOfMember;
				IsInTeam = True;
				IsInTeamTimer = Now;
				declare netwrite Integer Net_MatesNumbersChanged for UIOfMember;
				Net_MatesNumbersChanged = Now;
				declare netwrite Integer Net_MatesNumberSet for UIOfMember;
				Net_MatesNumberSet = _ExistingTeam.MaxMatesNumber;
				if(!G_AllPlayersInAnyTeam.exists(_LoginOfMember)){
					G_AllPlayersInAnyTeam.add(_LoginOfMember);
				}
				declare netwrite Text[] Net_AllPlayersInTeam for Teams[0];
				Net_AllPlayersInTeam = G_AllPlayersInAnyTeam;
				declare netwrite Integer Net_AllPlayersInTeamTimer for Teams[0];
				Net_AllPlayersInTeamTimer = Now;
				TeamRefresh = Now;
			}
		}
		
		foreach (Index => Members in _ExistingTeam.AllTeamMembers) {
			declare CPlayer PlayerMember;
			PlayerMember <=> GetPlayerFromLogin(Members);
			if(PlayerMember != Null){
				declare UIOfMates <=> UIManager.GetUI(PlayerMember);
				declare netwrite Text[] SquadForClient for UIOfMates;
				declare netwrite Integer UpdateClientSquad for UIOfMates;
				if (Members == _ExistingTeam.AllTeamMembers[Index]) {
					SquadForClient = _ExistingTeam.AllTeamMembers;
					UpdateClientSquad = Now;
				}
			}
		}
	}
	
	
	return _ExistingTeam;
}

/** Removing a intentional leavers of his team
 *
 *	@param	_Team										The Team to Modify
 *	@param	_LoginOfLeaver					The Login of the player who leaves the team
 */
KTeam DeleteMembersFromHisTeam(KTeam _Team, Text _LoginOfLeaver){
	declare KTeam _ModifiedTeam = _Team;
	if(_LoginOfLeaver != ""){
		declare netwrite Integer TeamRefresh for Teams[0];
		foreach (Player in Players){
			//Les mates doivent recevoir leur equipe modifié
			//Le leaver doit voir sa squad vidée
			declare LastMatePlayer = Player;
			declare UI <=> UIManager.GetUI(Player);
			declare UIOfLeaver <=> UIManager.GetUI(GetPlayerFromLogin(_LoginOfLeaver));
			declare PlayerLeaver = FindPlayerFromUI(UI);
			declare PlayerLeaverLogin = GetNameFromPlayer(PlayerLeaver);
			declare netwrite Text[] SquadForClient for UI;
			declare netwrite Integer UpdateClientSquad for UI;
			declare netwrite Boolean PutInAutoJoin for UI;
			declare netwrite Text[] Net_PlayersNeedHelp for UI;
			if(Net_PlayersNeedHelp.exists(PlayerLeaverLogin)){
				Net_PlayersNeedHelp.remove(PlayerLeaverLogin);
			}
			PutInAutoJoin = False;
			if(_ModifiedTeam.AllTeamMembers.exists(_LoginOfLeaver)){
				_ModifiedTeam.AllTeamMembers.remove(_LoginOfLeaver);
				TeamRefresh = Now;
			}
			//UI with the Squad empty for the leaver
			if (_LoginOfLeaver == Player.User.Login || G_PlayerLoginToRemove.exists(_LoginOfLeaver)){
				SquadForClient = [];
				UpdateClientSquad = Now;
			}
			//UI with the new squad for older mates
			foreach (Members in _ModifiedTeam.AllTeamMembers) {
				if (LastMatePlayer.User.Login == Members) {
					SquadForClient = _ModifiedTeam.AllTeamMembers;
					UpdateClientSquad = Now;
				}
			}	
		}
	}
	
	return _ModifiedTeam;
}

/** Delete from team a Player who disconnect from the server
 *
 *	@param	_Team											The team to modify
 *	@param	_LoginOfDisconnected			The Login of the player who disconnect from the server
 */
KTeam DeleteDisconnectedFromTeam(KTeam _Team, Text _LoginOfDisconnected){
	declare KTeam _ModifiedTeam = _Team;
	declare netwrite Integer TeamRefresh for Teams[0];

	if(_ModifiedTeam.AllTeamMembers.exists(_LoginOfDisconnected)){
		_ModifiedTeam.AllTeamMembers.remove(_LoginOfDisconnected);
		TeamRefresh = Now;
	}

	declare netwrite Text[] Net_LeaderSpawnedList for Teams[0];
	if(Net_LeaderSpawnedList.exists(_LoginOfDisconnected)){
		Net_LeaderSpawnedList.remove(_LoginOfDisconnected);
	}

	foreach (Member in _Team.AllTeamMembers){
		declare PlayerOfMember <=> GetPlayerFromLogin(Member);
		if(PlayerOfMember != Null){
			declare UIOfPlayerStaying <=> UIManager.GetUI(PlayerOfMember);
			declare netwrite Text[] SquadForClient for UIOfPlayerStaying;
			declare netwrite Integer UpdateClientSquad for UIOfPlayerStaying;
			declare netwrite Text[] Net_PlayersNeedHelp for UIOfPlayerStaying;
			if(Net_PlayersNeedHelp.exists(_LoginOfDisconnected)){
				Net_PlayersNeedHelp.remove(_LoginOfDisconnected);
			}
			SquadForClient = _ModifiedTeam.AllTeamMembers;
			UpdateClientSquad = Now;

		}
		
	}

	return _ModifiedTeam;
}

Text GetLeaderWaitingWithGoodOptions(Integer[] _Net_SquadOptionsCheck, CPlayer _PlayerWaiting){
	declare Text LeaderLoginInMatchmakingAndLeader;
	foreach(LoginOfLeaderWaiting in G_LeadersToDisplay){
		if(_PlayerWaiting.User.Login != LoginOfLeaderWaiting){
			foreach(LeaderLogin => Team in G_AllTeams){
				foreach(OptionCheck in _Net_SquadOptionsCheck){
					if(LoginOfLeaderWaiting == LeaderLogin && Team.MaxMatesNumber == OptionCheck && Team.AllTeamMembers.count < Team.MaxMatesNumber){
						return LeaderLogin;
					}
				}
			}
		}
	}
	if(LeaderLoginInMatchmakingAndLeader != ""){
		return LeaderLoginInMatchmakingAndLeader;
	}
	return "";
}

Integer GetCommonSettings(Integer[] _FirstOptionSetup, Integer[] _SecondOptionSetup){
	foreach(Option in _SecondOptionSetup){
		if(_FirstOptionSetup.exists(Option)){
			return Option;
		}
	}
	return 0;
}

Void CreateTeamWithBestSetting(CPlayer _PlayerWaiting, Integer _NewCommonSettings, Integer[] _Net_SquadOptionsCheck){
	declare NewMemberLogin = _PlayerWaiting.User.Login;
	declare KTeam NewTeam;
	NewTeam.Leader = NewMemberLogin;
	declare KTeam	TeamCreated;
	declare PlayerFromLogin <=> GetPlayerFromLogin(NewMemberLogin);
	if(PlayerFromLogin != Null){
		declare UI <=> UIManager.GetUI(PlayerFromLogin);
		if(UI != Null){
			declare netwrite Integer Net_MatesNumberSet for UI;
			declare netwrite Integer Net_MatesNumbersChanged for UI;
			declare Integer PrevOptionCheck;
			foreach(OptionsCheck in _Net_SquadOptionsCheck){
				if(OptionsCheck - PrevOptionCheck >= 0){
					Net_MatesNumberSet = OptionsCheck;
				}
				PrevOptionCheck = OptionsCheck;
			}
			if(_NewCommonSettings != 0){
				Net_MatesNumberSet = _NewCommonSettings;
			}
			Net_MatesNumbersChanged = Now;
			TeamCreated = CreateNewTeam(_PlayerWaiting, Net_MatesNumberSet);
			if(!G_LeadersReady.exists(_PlayerWaiting.User.Login)){
				G_LeadersReady.add(_PlayerWaiting.User.Login);
			}
		}
	}
	declare netwrite Integer TeamRefresh for Teams[0];
	TeamRefresh = Now;
	foreach(LeaderLogin => Team in G_AllTeams){
		if(LeaderLogin == NewMemberLogin){
			G_AllTeams[LeaderLogin].TeamReady = True;
		}
	}
	if(!G_LeadersToDisplay.exists(NewMemberLogin)){
		G_LeadersToDisplay.add(NewMemberLogin);
		G_PlayersInAutoJoinTimer = Now;
		foreach (LeaderLogin => Team in G_AllTeams) {
			G_AllTeams[LeaderLogin].TeamInAutoFill = True;
			if (!G_AllTeams.existskey(LeaderLogin)){
				AddTeamInTeamsList(TeamCreated);
			}
		}	
	}
}

Void CreateTeamForPlayersWaiting(){
	foreach(LoginOfPlayerWaiting in G_PlayersWaitingForAnAutoFillTeam){
		declare PlayerWaiting <=> GetPlayerFromLogin(LoginOfPlayerWaiting);
		declare Boolean SkipTimerInMatchMaking for PlayerWaiting;
		SkipTimerInMatchMaking = True;
	}
}

Void PutPlayerInMatchMaking(CPlayer _PlayerWaiting, Integer _CommonSettings, Integer[] _Net_SquadOptionsCheck){
	declare Boolean PlayerCanGoInTeam for _PlayerWaiting;
	declare Integer TimeInWaitingList for _PlayerWaiting;
	declare Boolean SkipTimerInMatchMaking for _PlayerWaiting;
	declare Integer MaxTimeInWaitingList = 10000;
	declare NewCommonSettings = _CommonSettings;
	if(!G_AllTeams.existskey(_PlayerWaiting.User.Login) && !PlayerCanGoInTeam && !_Net_SquadOptionsCheck.exists(1)){
		foreach(LoginPlayerWaiting in G_PlayersWaitingForAnAutoFillTeam){
			declare PlayerInMatchMaking <=> GetPlayerFromLogin(LoginPlayerWaiting);
			if(PlayerInMatchMaking != Null && PlayerInMatchMaking != _PlayerWaiting && !PlayerCanGoInTeam) {
				declare UIOfPlayerInMatckMaking <=> UIManager.GetUI(PlayerInMatchMaking);
				declare netread Integer[] Net_SquadOptionsCheck for UIOfPlayerInMatckMaking;
				NewCommonSettings = GetCommonSettings(Net_SquadOptionsCheck, _Net_SquadOptionsCheck);
				if(NewCommonSettings != 0){
					PlayerCanGoInTeam = True;
				}
			}
			if(Now > TimeInWaitingList + MaxTimeInWaitingList && !PlayerCanGoInTeam){
				PlayerCanGoInTeam = True;
			}
		}
	} else if (!G_AllTeams.existskey(_PlayerWaiting.User.Login) && !PlayerCanGoInTeam && _Net_SquadOptionsCheck.exists(1)){
		PlayerCanGoInTeam = True;
		NewCommonSettings = 0;
	}
	if(!G_AllTeams.existskey(_PlayerWaiting.User.Login) && PlayerCanGoInTeam || SkipTimerInMatchMaking){
		CreateTeamWithBestSetting(_PlayerWaiting, NewCommonSettings, _Net_SquadOptionsCheck);
		if(SkipTimerInMatchMaking){
			G_PlayersWaitingForAnAutoFillTeam.remove(_PlayerWaiting.User.Login);
		}
		SkipTimerInMatchMaking = False;
	}
}

Void PutPlayerInCorrespondingTeam(Text _LoginOfLeaderToJoin, CPlayer _PlayerWaiting){
	declare netwrite Integer Net_TS2_PlayersPerTeam for Teams[0];
	G_AllTeams[_LoginOfLeaderToJoin] = AddMembersInExistingTeam(G_AllTeams[_LoginOfLeaderToJoin], _PlayerWaiting);
	declare LeaderToJoin <=> GetPlayerFromLogin(_LoginOfLeaderToJoin);
	if(LeaderToJoin != Null){
		G_PlayersWaitingForAnAutoFillTeam.remove(_LoginOfLeaderToJoin);
		declare netwrite Integer TeamRefresh for Teams[0];
		TeamRefresh = Now;
		G_PlayersWaitingForAnAutoFillTeam.remove(_PlayerWaiting.User.Login);
		G_PlayersInAutoJoinTimer = Now;
		if(G_AllTeams[_LoginOfLeaderToJoin].AllTeamMembers.count >= Net_TS2_PlayersPerTeam){
			if(G_LeadersToDisplay.exists(_LoginOfLeaderToJoin)){
				G_LeadersToDisplay.remove(_LoginOfLeaderToJoin);
				G_PlayersInAutoJoinTimer = Now;
			}
		}
		declare UIOfLeaderToJoin <=> UIManager.GetUI(LeaderToJoin);
		declare netwrite Boolean IsInTeam for UIOfLeaderToJoin; 
		IsInTeam = True;
		declare netwrite Integer IsInTeamTimer for UIOfLeaderToJoin;
		IsInTeamTimer = Now;
		G_PlayersJoiningAnAutoFillTeamAndCanGoesLeader.add(_PlayerWaiting.User.Login);
		if(G_AllTeams.existskey(_PlayerWaiting.User.Login)){
			if(G_AllTeams[_PlayerWaiting.User.Login].Leader == _PlayerWaiting.User.Login){//On trouve la team du player en liste d'attente, on delete sa team
				SetColorNotUsed(G_AllTeams[_PlayerWaiting.User.Login].TeamColor);
				SetClanIdNotUsed(G_AllTeams[_PlayerWaiting.User.Login].ClanId);
				G_AllTeams.removekey(_PlayerWaiting.User.Login);
			}
		}
	}

}

Void SortFirstLeaderWaitingLast(Text _LeaderToSortLast){
	if(G_LeadersToDisplay.exists(_LeaderToSortLast)){
		G_LeadersToDisplay.remove(_LeaderToSortLast);
	}
	if(!G_LeadersToDisplay.exists(_LeaderToSortLast)){
		G_LeadersToDisplay.add(_LeaderToSortLast);
	}
}

Void UseSquadMatchMaking(Integer _Net_S_MatchMakingAlgorythm){
	if(_Net_S_MatchMakingAlgorythm == 0 && G_PlayersWaitingForAnAutoFillTeam.count > 0){
		foreach(LoginOfPlayerWaiting in G_PlayersWaitingForAnAutoFillTeam){
			declare PlayerWaiting = GetPlayerFromLogin(LoginOfPlayerWaiting);
			declare Boolean SkipTimerInMatchMaking for PlayerWaiting;
			if(PlayerWaiting != Null){
				declare Boolean PlayerCanGoInTeam for PlayerWaiting = False;
				declare UIOfPlayerWaiting <=> UIManager.GetUI(PlayerWaiting);
				declare netread Integer[] Net_SquadOptionsCheck for UIOfPlayerWaiting;
				declare LoginOfLeaderToJoin = GetLeaderWaitingWithGoodOptions(Net_SquadOptionsCheck, PlayerWaiting);
				if(LoginOfLeaderToJoin != ""){
					PutPlayerInCorrespondingTeam(LoginOfLeaderToJoin, PlayerWaiting);
					SortFirstLeaderWaitingLast(LoginOfLeaderToJoin);
					SkipTimerInMatchMaking = False;
				} else if (LoginOfLeaderToJoin == LoginOfPlayerWaiting){
					continue;
				} else if (LoginOfLeaderToJoin == ""){
					//Aucune team n'est trouvée dans les presets, avant de créer une team, créer un timer for Player.
					declare Integer CommonSettings = 0;
					if(PlayerWaiting != Null){
						PutPlayerInMatchMaking(PlayerWaiting, CommonSettings, Net_SquadOptionsCheck);
						SkipTimerInMatchMaking = False;
					}
				}
			}
		}
	}
}

Ident GetIdFromLogin(Text _Login){
	foreach(Player in Players){
		if (Player.User.Login == _Login){
			return Player.Id;
		}
	}
	return NullId;
}

/** List All Players in the server
 *
 */
Void ListAllCurrentPlayers(){
	declare netwrite Text[] Net_PlayersSpectating for Teams[0];
	foreach (Player in AllPlayers){
		declare PlayerFromAllPlayer <=> GetPlayerinAllPlayersFromLogin(Player.User.Login);
		declare UI <=> UIManager.GetUI(PlayerFromAllPlayer);
		if ( !Player.RequestsSpectate && !G_PlayerLoginList.exists(Player.User.Login)) {
			G_PlayerLoginList.add(Player.User.Login);
		}
		if(!Players.exists(Player)){
			if(!G_PlayerSpectating.exists(Player.User.Login)){
				G_PlayerSpectating.add(Player.User.Login);
			}
		} else G_PlayerSpectating.remove(Player.User.Login);
		
	}
	Net_PlayersSpectating = G_PlayerSpectating;
}

/** Get the login of a player who leave the server
 *
 *	@param	_PlayerLogin							The player who scored a point
 */
Boolean PlayerHasLeft(Text _PlayerLogin) {
	declare PlayerOfLogin <=> GetPlayerFromLogin(_PlayerLogin);
	return (PlayerOfLogin == Null || PlayerOfLogin.RequestsSpectate);
}

/** List of all the playes who leave the server
 *
 */
Void ListAllLeavingPlayers(){
	foreach (PlayerLogin in G_PlayerLoginList) {
		if (PlayerHasLeft(PlayerLogin)) {
			G_PlayerLoginToRemove.add(PlayerLogin);
		}
	}
}

Void SendInvitersToDeleteToClient(Text[] _InvitersToDelete){
	declare netwrite Text[] Net_InvitersToDelete for Teams[0];
	Net_InvitersToDelete = _InvitersToDelete;
}

/** Manage all players in the server
 *
 *	@param	_Player										The player who scored a point
 *	@param	_PointsLimit							The points limit to reach to win
 */
Void ManagePlayers(Boolean _Net_NewMap){
	declare netwrite Text[] Net_PlayersSpectating for Teams[0];
	if(Players.count != PrevPlayersCount && !_Net_NewMap){
		ListAllCurrentPlayers();
		ListAllLeavingPlayers();
		PrevPlayersCount = Players.count;
	}
	foreach(Spectator in Spectators){
		if(!G_PlayerSpectating.exists(Spectator.User.Login)){
			G_PlayerSpectating.add(Spectator.User.Login);
		}
	}
	
	Net_PlayersSpectating = G_PlayerSpectating;
	foreach (PlayerLogin in G_PlayerLoginToRemove) {
		declare RemovedFromPlayerList = G_PlayerLoginList.remove(PlayerLogin);
	}

		foreach(PlayerLogin in G_PlayerLoginToRemove){
			declare PlayerFromLogin <=> GetPlayerFromLogin(PlayerLogin);
			G_PlayersWaitingForAnAutoFillTeam.remove(PlayerLogin);
			G_PlayersInAutoJoinTimer = Now;
			G_LeadersToDisplay.remove(PlayerLogin);
			G_PlayersInAutoJoinTimer = Now;
			G_PlayerSpectating.remove(PlayerLogin);
			G_PlayersWithNoTeam.remove(PlayerLogin);
			if(G_LeadersReady.exists(PlayerLogin)){
				G_LeadersReady.remove(PlayerLogin);
			}
			declare netwrite Text[] Net_PlayersSpectating for Teams[0];
			Net_PlayersSpectating.remove(PlayerLogin);
			if(!G_InvitersToDelete.exists(PlayerLogin)){
				G_InvitersToDelete.add(PlayerLogin);
				SendInvitersToDeleteToClient(G_InvitersToDelete);
				declare netwrite Integer InvitersUpdatedTime for Teams[0];
				InvitersUpdatedTime = Now;
			}
			foreach(TeamKey => Team in G_AllTeams){
				if(G_AllTeams[TeamKey].AllTeamMembers.exists(PlayerLogin)){//Check in all teams if a player that disconnect exist in the members of a team
					G_AllTeams[TeamKey] = DeleteDisconnectedFromTeam(G_AllTeams[TeamKey], PlayerLogin);
					G_PlayerLoginToRemove.remove(PlayerLogin);
					G_PlayersWaitingForAnAutoFillTeam.remove(PlayerLogin);
					G_PlayersInAutoJoinTimer = Now;
					G_LeadersToDisplay.remove(PlayerLogin);
					G_PlayersInAutoJoinTimer = Now;
					G_PlayersWaiting.remove(PlayerLogin);
					G_LeadersInFullTeam.remove(PlayerLogin);
					G_IdsOfPlayerInTeam.removekey(PlayerLogin);
					G_PlayerInTeams.remove(PlayerLogin);
					G_AllPlayersInAnyTeam.remove(PlayerLogin);
					declare netwrite Text[] Net_AllPlayersInTeam for Teams[0];
					Net_AllPlayersInTeam = G_AllPlayersInAnyTeam;
					declare netwrite Integer Net_AllPlayersInTeamTimer for Teams[0];
					Net_AllPlayersInTeamTimer = Now;
					declare netwrite Text[] PlayersInTeamList for Teams[0];
					PlayersInTeamList.remove(PlayerLogin);
					declare netwrite Integer TeamRefresh for Teams[0];
					TeamRefresh = Now;
				}

			if(G_AllTeams[TeamKey].Leader == PlayerLogin){	//Check if the login to remove correspond to the leader of his team
				declare NewLeader = CPlayer;
				//Check if the position 0 exist
				if(G_AllTeams[TeamKey].AllTeamMembers.count > 0){
					declare KTeam NewTeam;
					declare Text NewLeaderLogin;
					declare netwrite Text[] Net_LeaderSpawnedList for Teams[0];
					NewLeaderLogin = G_AllTeams[TeamKey].AllTeamMembers[0];
					NewLeader = GetPlayerFromLogin(NewLeaderLogin);
					if(NewLeader != Null){
						declare UIOfNewLeader <=> UIManager.GetUI(NewLeader);
						NewTeam = G_AllTeams[TeamKey];
						NewTeam.Leader = NewLeaderLogin;
						G_AllTeams[NewLeaderLogin] = NewTeam;
						if(G_PlayersJoiningAnAutoFillTeamAndCanGoesLeader.exists(NewLeaderLogin)){
							G_AllTeams[NewLeaderLogin].TeamInAutoFill = True;
							G_AllTeams[NewLeaderLogin].TeamReady = True;
							G_AllTeams[NewLeaderLogin].MaxMatesNumber = G_AllTeams[TeamKey].MaxMatesNumber;
							declare netwrite Integer TeamRefresh for Teams[0];
							TeamRefresh = Now;
							if(!G_LeadersToDisplay.exists(NewLeaderLogin)){
								G_PlayersInAutoJoinTimer = Now;
								G_LeadersToDisplay.add(NewLeaderLogin);
								declare netwrite Integer AutoAutoFillTimer for UIOfNewLeader;
								AutoAutoFillTimer = Now;
								G_LeadersReady.add(NewLeaderLogin);
							}
						}
						G_AllTeams.removekey(TeamKey);
						if(Net_LeaderSpawnedList.exists(PlayerLogin)){
							Net_LeaderSpawnedList.add(NewLeaderLogin);
							Net_LeaderSpawnedList.remove(PlayerLogin);
						}
						if(G_PlayersWaitingForAnAutoFillTeam.exists(NewLeaderLogin)){
							if(!G_LeadersToDisplay.exists(NewLeaderLogin)){
								G_LeadersToDisplay.add(NewLeaderLogin);
								G_PlayersInAutoJoinTimer = Now;
								G_AllTeams[TeamKey].TeamInAutoFill = True;
							}
						}
					}
				
				}
				//Position 0 doesn't exist, the team is empty, destroy it
				else if (G_AllTeams[TeamKey].AllTeamMembers.count <= 0){
					SetColorNotUsed(G_AllTeams[TeamKey].TeamColor);
					SetClanIdNotUsed(G_AllTeams[TeamKey].ClanId);
					G_AllTeams.removekey(TeamKey);
				}
			}
			else G_PlayerLoginToRemove.remove(PlayerLogin);
		}
		G_PlayerLoginToRemove.remove(PlayerLogin);
	}

	foreach (Spectator in	G_PlayerSpectating){
		
		if(GetPlayerinAllPlayersFromLogin(Spectator) != Null){
			declare UI <=> UIManager.GetUI(GetPlayerinAllPlayersFromLogin(Spectator));
			declare netwrite Text[] SquadForClient for UI;
			declare netwrite Boolean IsInTeam for UI;
			declare netwrite Integer IsInTeamTimer for UI;
			declare netwrite Boolean IsPlayerSpawned for UI;
			declare netwrite Integer IsPlayerSpawnedTimer for UI;
			declare netwrite Integer UpdateClientSquad for UI;
			declare Boolean PlayerCanGoInTeam for GetPlayerinAllPlayersFromLogin(Spectator);
			PlayerCanGoInTeam = False;	
			IsInTeam = False;
			IsInTeamTimer = Now;
			IsPlayerSpawned = False;
			IsPlayerSpawnedTimer = Now;
			UpdateClientSquad = Now;
			if(!G_InvitersToDelete.exists(Spectator)){
				G_InvitersToDelete.add(Spectator);
				SendInvitersToDeleteToClient(G_InvitersToDelete);
				declare netwrite Integer InvitersUpdatedTime for Teams[0];
				InvitersUpdatedTime = Now;
			}
			if(SquadForClient.exists(Spectator)){
				SquadForClient = [];
			}
			if(G_PlayerLoginToRemove.exists(Spectator)){
				G_PlayerLoginToRemove.remove(Spectator);
			}
			if(G_PlayersWaitingForAnAutoFillTeam.exists(Spectator)){
				G_PlayersWaitingForAnAutoFillTeam.remove(Spectator);
				G_PlayersInAutoJoinTimer = Now;
			}
			if(G_LeadersToDisplay.exists(Spectator)){
				G_LeadersToDisplay.remove(Spectator);
				G_PlayersInAutoJoinTimer = Now;
			}
			if(G_PlayersWaiting.exists(Spectator)){
				G_PlayersWaiting.remove(Spectator);
			}
			if(G_LeadersInFullTeam.exists(Spectator)){
				G_LeadersInFullTeam.remove(Spectator);
			}
			if(G_IdsOfPlayerInTeam.existskey(Spectator)){
				G_IdsOfPlayerInTeam.removekey(Spectator);
			}
			if(G_PlayerInTeams.exists(Spectator)){
				G_PlayerInTeams.remove(Spectator);
			}
			if(G_AllPlayersInAnyTeam.exists(Spectator)){
				G_AllPlayersInAnyTeam.remove(Spectator);
			}
			declare netwrite Text[] PlayersInTeamList for Teams[0];
			if(PlayersInTeamList.exists(Spectator)){
				PlayersInTeamList.remove(Spectator);
			}
			G_PlayersWithNoTeam.remove(Spectator);
			if(G_LeadersReady.exists(Spectator)){
				G_LeadersReady.remove(Spectator);
			}
			foreach(TeamKey => Team in G_AllTeams){
				
				if(G_AllTeams[TeamKey].AllTeamMembers.exists(Spectator)){//Check in all teams if a player that disconnect exist in the members of a team
				
					G_AllTeams[TeamKey] = DeleteDisconnectedFromTeam(G_AllTeams[TeamKey], Spectator);
					G_PlayerLoginToRemove.remove(Spectator);
					G_PlayersWaitingForAnAutoFillTeam.remove(Spectator);
					G_PlayersInAutoJoinTimer = Now;
					G_LeadersToDisplay.remove(Spectator);
					G_PlayersWaiting.remove(Spectator);
					G_LeadersInFullTeam.remove(Spectator);
					G_IdsOfPlayerInTeam.removekey(Spectator);
					G_PlayerInTeams.remove(Spectator);
					G_AllPlayersInAnyTeam.remove(Spectator);
					declare netwrite Text[] Net_AllPlayersInTeam for Teams[0];
					Net_AllPlayersInTeam = G_AllPlayersInAnyTeam;
					declare netwrite Integer Net_AllPlayersInTeamTimer for Teams[0];
					Net_AllPlayersInTeamTimer = Now;
					declare netwrite Text[] PlayersInTeamList for Teams[0];
					PlayersInTeamList.remove(Spectator);
					declare netwrite Integer TeamRefresh for Teams[0];
					TeamRefresh = Now;
				}

				if(G_AllTeams[TeamKey].Leader == Spectator){	//Check if the login to remove correspond to the leader of his team
					declare NewLeader = CPlayer;
					//Check if the position 0 exist
					if(G_AllTeams[TeamKey].AllTeamMembers.count > 0){
						declare KTeam NewTeam;
						declare Text NewLeaderLogin;
						declare netwrite Text[] Net_LeaderSpawnedList for Teams[0];
						NewLeaderLogin = G_AllTeams[TeamKey].AllTeamMembers[0];
						NewLeader = GetPlayerFromLogin(NewLeaderLogin);
						NewTeam = G_AllTeams[TeamKey];
						NewTeam.Leader = NewLeaderLogin;
						G_AllTeams[NewLeaderLogin] = NewTeam;
						G_AllTeams.removekey(TeamKey);
						if(Net_LeaderSpawnedList.exists(Spectator)){
							Net_LeaderSpawnedList.add(NewLeaderLogin);
							Net_LeaderSpawnedList.remove(Spectator);
						}
						if(G_PlayersWaitingForAnAutoFillTeam.exists(NewLeaderLogin)){
							if(!G_LeadersToDisplay.exists(NewLeaderLogin)){
								G_LeadersToDisplay.add(NewLeaderLogin);
								G_PlayersInAutoJoinTimer = Now;
							}
						}
					}
					//Position 0 doesn't exist, the team is empty, destroy it
					else if (G_AllTeams[TeamKey].AllTeamMembers.count <= 0){
						SetColorNotUsed(G_AllTeams[TeamKey].TeamColor);
						SetClanIdNotUsed(G_AllTeams[TeamKey].ClanId);
						G_AllTeams.removekey(TeamKey);
					}
				}
			}
			declare netwrite Integer TeamRefresh for Teams[0];
			TeamRefresh = Now;
			declare netwrite Text[] Net_AllPlayersInTeam for Teams[0];
			Net_AllPlayersInTeam = G_AllPlayersInAnyTeam;
			declare netwrite Integer Net_AllPlayersInTeamTimer for Teams[0];
			Net_AllPlayersInTeamTimer = Now;
		}
		G_InvitersToDelete = [];
	}


}

/** Put Player in the list of autofill leader that already spawned
 *
 */
Void FillSpawnedTeam(){
	foreach(TeamKey => Team in G_AllTeams){
		declare LeaderLogin = G_AllTeams[TeamKey].AllTeamMembers[0];
		declare PlayerFromLogin <=> GetPlayerFromLogin(LeaderLogin);
		if(PlayerFromLogin != Null){
			declare UIOfPotentialLeaderToFillTeam <=> UIManager.GetUI(PlayerFromLogin);
			declare netwrite Boolean IsPlayerSpawned for UIOfPotentialLeaderToFillTeam;
			declare netwrite Integer Net_TS2_PlayersPerTeam for Teams[0];
			if(G_AllTeams[TeamKey].AllTeamMembers.count < Net_TS2_PlayersPerTeam && IsPlayerSpawned == True){
				if(!G_LeadersToDisplay.exists(LeaderLogin)){
					G_LeadersToDisplay.add(LeaderLogin);
					G_PlayersInAutoJoinTimer = Now;
				}
			}
			else if(G_AllTeams[TeamKey].AllTeamMembers.count >= Net_TS2_PlayersPerTeam){
				G_LeadersToDisplay.remove(LeaderLogin);
				G_PlayersInAutoJoinTimer = Now;
			}
		}
	}
}

/** Get the mates of a CPlayer
 *
 *	@param	_Player												The CPlayer
 *	@return	MyTeamMembers									Return an array of Text with all the Members's Login of the _Player
 */
Text[] GetPlayerTeamMembers(CPlayer _Player){
	declare Text[] MyTeamMembers;
	if(_Player != Null){
		foreach (Team in G_AllTeams){
			foreach(PotentialMember in Team.AllTeamMembers){
				if (PotentialMember == _Player.User.Login){
					MyTeamMembers = Team.AllTeamMembers;
					return MyTeamMembers;
				}
			}
		}
	}
		
	return MyTeamMembers;
}

Void AddPlayerRoundCount(CPlayer _Player){
	if(_Player != Null) {
		declare UI <=> UIManager.GetUI(_Player);
		if(UI != Null){
			declare netwrite Integer Net_TeamSelection2_RoundCount for UI;
			Net_TeamSelection2_RoundCount += 1;
		}
	}
	
}

Text[] GetCPlayerTeamMembers(CPlayer _Player){
	declare Text[] MyTeamMembers;
	if(_Player != Null){
		foreach (Team in G_AllTeams){
			foreach(PotentialMember in Team.AllTeamMembers){
				if (PotentialMember == _Player.User.Login){
					MyTeamMembers = Team.AllTeamMembers;
					return MyTeamMembers;
				}
			}
		}
	} else return [];
		
	return MyTeamMembers;
}

Text[] GetCSmPlayerTeamMembers(CSmPlayer _Player){
	declare Text[] MyTeamMembers;
	if(_Player != Null){
		foreach (Team in G_AllTeams){
			foreach(PotentialMember in Team.AllTeamMembers){
				if (PotentialMember == _Player.User.Login){
					MyTeamMembers = Team.AllTeamMembers;
					return MyTeamMembers;
				}
			}
		}
	} else return [];
		
	return MyTeamMembers;
}

Text[] GetCTmPlayerTeamMembers(CTmPlayer _Player){
	declare Text[] MyTeamMembers;
		foreach (Team in G_AllTeams){
			foreach(PotentialMember in Team.AllTeamMembers){
				if (PotentialMember == _Player.User.Login){
					MyTeamMembers = Team.AllTeamMembers;
					return MyTeamMembers;
				}
			}
		}
	return MyTeamMembers;
}

Boolean GetIfPlayerInATeam(CPlayer _Player){
	foreach(TeamKey => Team in G_AllTeams){
		if(G_AllTeams[TeamKey].AllTeamMembers.exists(_Player.User.Login)){
			return True;
		}
	}
	return False;
}

Boolean GetAllPlayersInTeam(CPlayer _Player){
	declare netwrite Text[] Net_AllPlayersInTeam for Teams[0];
	if(_Player != Null){
		foreach(TeamKey => Team in G_AllTeams){
			if(G_AllTeams[TeamKey].AllTeamMembers.exists(_Player.User.Login)){
				if(!G_AllPlayersInAnyTeam.exists(_Player.User.Login)) G_AllPlayersInAnyTeam.add(_Player.User.Login);
				Net_AllPlayersInTeam = G_AllPlayersInAnyTeam;
				declare netwrite Integer Net_AllPlayersInTeamTimer for Teams[0];
				Net_AllPlayersInTeamTimer = Now;
				if(!G_AllTeams.existskey(_Player.User.Login)){
					return True;
				} 
			}
		}
	}

	return False;
}

Integer GetMaxPlayerNumber(Integer _S_PlayerNumber){
	declare MaxPlayer = 9;
	if(_S_PlayerNumber > MaxPlayer){
		return MaxPlayer;
	}
	return _S_PlayerNumber;
}

Boolean IsPlayerInTeam(CPlayer _Player){
	if(_Player != Null){
		foreach(TeamKey => Team in G_AllTeams){
			if(Team.AllTeamMembers.exists(_Player.User.Login)){
				return True;
			}
		}
		return False;
	}
	return False;
}

Void GetPlayersWithNoTeam(){
	foreach(Player in Players){
		declare Boolean IsThePlayerInTeam;
		IsThePlayerInTeam = IsPlayerInTeam(Player);
		if(!IsThePlayerInTeam){
			if(!G_PlayersWithNoTeam.exists(Player.User.Login)){
				G_PlayersWithNoTeam.add(Player.User.Login);
			}
		} else G_PlayersWithNoTeam.remove(Player.User.Login);
	}
}

Void PutPlayerWithNoTeamInAutoJoin(Text _PlayerLogin) {
	declare netwrite Text[] Net_PlayersInAutoJoin for Teams[0];
	if(!G_PlayersWaitingForAnAutoFillTeam.exists(_PlayerLogin)){
		G_PlayersWaitingForAnAutoFillTeam.add(_PlayerLogin);
		G_PlayersInAutoJoinTimer = Now;
		declare PlayerOfPlayerInAutoJoin <=> GetPlayerFromLogin(_PlayerLogin);
		if(PlayerOfPlayerInAutoJoin != Null){
			declare UI <=> UIManager.GetUI(PlayerOfPlayerInAutoJoin);
			declare netwrite Boolean PutInAutoJoin for UI;
			PutInAutoJoin = True;
		}
	} 
	Net_PlayersInAutoJoin = G_PlayersWaitingForAnAutoFillTeam;
}

Void RemoveAutoFillLeaderInFullTeam(){
	declare netwrite Integer Net_TS2_PlayersPerTeam for Teams[0];
	foreach(TeamKey => Team in G_AllTeams){
		if(Team.AllTeamMembers.count >= Net_TS2_PlayersPerTeam){
			if(G_LeadersToDisplay.exists(TeamKey)){
				G_LeadersToDisplay.remove(TeamKey);
				G_AllTeams[TeamKey].TeamInAutoFill = False;
			}
		}
	}
}

Void GetAllPlayersInATeam(){
	declare netwrite Text[] Net_AllPlayersInTeam for Teams[0];
	declare netwrite Integer Net_AllPlayersInTeamTimer for Teams[0];
	foreach(Player in Players){
		foreach(TeamKey => Team in G_AllTeams){
			if(Team.AllTeamMembers.exists(Player.User.Login)){
				if(!Net_AllPlayersInTeam.exists(Player.User.Login)){
					Net_AllPlayersInTeam.add(Player.User.Login);
					Net_AllPlayersInTeamTimer = Now;
				}
			}
		}
	}
	
}

Void ResetJoiningPlayersAndWaitingLeaders(){
	G_PlayersWaitingForAnAutoFillTeam.clear();
	G_LeadersToDisplay.clear();
}

Void DestroyTeamWithOnePlayer(){
	declare netwrite Integer TeamRefresh for Teams[0];
	foreach(TeamIndex => Team in G_AllTeams){
		if(Team.AllTeamMembers.count <= 1){
			SetColorNotUsed(G_AllTeams[TeamIndex].TeamColor);
			SetClanIdNotUsed(G_AllTeams[TeamIndex].ClanId);
			G_AllTeams.removekey(TeamIndex);
			declare PlayerWithNoMates <=> GetPlayerFromLogin(TeamIndex);
			if(PlayerWithNoMates != Null){
				declare UI <=> UIManager.GetUI(PlayerWithNoMates);
				declare netwrite Boolean IsInTeam for UI;
				declare netwrite Integer IsInTeamTimer for UI;
				declare netwrite Text[] SquadForClient for UI;
				SquadForClient.clear();
				IsInTeam = False;
				IsInTeamTimer = Now;
				TeamRefresh = Now;
			}
		}
	}
}

Void ResetAutoJoinStateIfNotInAutoJoin(){
	foreach(Player in Players){
		declare UI <=> UIManager.GetUI(Player);
		declare netwrite Boolean PutInAutoJoin for UI;
		if(!G_PlayersWaitingForAnAutoFillTeam.exists(Player.User.Login)){
			PutInAutoJoin = False;
		} else PutInAutoJoin = True;
		
	}
}

Void UpdatePlayersPerTeam(Integer _PlayersPerTeam){
	declare netwrite Integer Net_TS2_PlayersPerTeam for Teams[0];
	Net_TS2_PlayersPerTeam = _PlayersPerTeam;
	foreach(Player in Players){
		declare UI <=> UIManager.GetUI(Player);
		if(UI != Null){
			declare netwrite Integer Net_S_PlayersPerTeam for UI;
			Net_S_PlayersPerTeam = _PlayersPerTeam;
		}
	}
}

Void CheckLeadersReadyToFillTheirTeam(Text[] _G_LeadersReady){
	foreach(LeaderLogin => Team in G_AllTeams){
		foreach(LeaderReady in _G_LeadersReady){
			if(LeaderLogin == LeaderReady){
				declare PlayerOfLeader = GetPlayerFromLogin(LeaderReady);
				if(Team.AllTeamMembers.count < Team.MaxMatesNumber){
					if(PlayerOfLeader != Null){
						declare UIOfPotentialLeaderToFillTeam <=> UIManager.GetUI(PlayerOfLeader);
						declare netwrite Boolean IsPlayerSpawned for UIOfPotentialLeaderToFillTeam;
						declare netwrite Integer Net_TS2_PlayersPerTeam for Teams[0];
						if(!G_LeadersToDisplay.exists(LeaderLogin)){
							G_LeadersToDisplay.add(LeaderLogin);
							G_AllTeams[LeaderLogin].TeamInAutoFill = True;
							G_PlayersInAutoJoinTimer = Now;
						} 
					}
				} else if(Team.AllTeamMembers.count >= Team.MaxMatesNumber){
					G_LeadersToDisplay.remove(LeaderLogin);
					G_PlayersInAutoJoinTimer = Now;
					G_AllTeams[LeaderLogin].TeamInAutoFill = False;
				}
			}
		}
	}
}

Void InitTeamConfigs(){
	G_PlacesAvailable[4] = 0;
	G_PlacesAvailable[3] = 0;
	G_PlacesAvailable[2] = 0;
	G_PlacesAvailable[1] = 0;
}

Void UpdatePlacesAvailableToClient(){
	foreach(Player in Players){
		declare UI <=> UIManager.GetUI(Player);
		declare netwrite Integer[Integer] Net_PlacesAvailable for UI;
		Net_PlacesAvailable = G_PlacesAvailable;
	}
}

Void SendPlacesAvailableToClient(){
	InitTeamConfigs();
	foreach(LeaderLogin => Team in G_AllTeams){
		if(G_LeadersToDisplay.exists(LeaderLogin)){
			declare PlacesAvailable = Team.MaxMatesNumber - Team.AllTeamMembers.count;
			G_PlacesAvailable[Team.MaxMatesNumber] += PlacesAvailable;
		}
	}
	UpdatePlacesAvailableToClient();
}

Integer GetTeamsReadyCount(){
	declare ReadyCount = 0;
	foreach(Team in G_AllTeams){
		if(Team.TeamReady){
			ReadyCount += 1;
		}
	}
	return ReadyCount;
}

Void InstantiateColorList(){
	foreach(ColorFromList in ColorList){
		declare KTeamColorSet NewKTeamColor;
		NewKTeamColor.NewColor = ColorFromList;
		NewKTeamColor.IsUsed = False;

		if(!G_TeamColor.existskey(ColorFromList)){
			G_TeamColor[ColorFromList] = NewKTeamColor;
		}
	}
}

Void InstantiateClansIds() {
	foreach(ClanId in ClansIds){
		declare KTeamClanId NewKTeamClanId;
		NewKTeamClanId.ClanId = ClanId;
		NewKTeamClanId.IsUsed = False;

		if(!G_ClansIds.existskey(ClanId)){
			G_ClansIds[ClanId] = NewKTeamClanId;
		}
	}
}

Void GetIfPlayerIsSpawningToUI(CPlayer _Player, Boolean _PlayerIsInSpawning){
	if(_Player != Null){
		declare UI <=> UIManager.GetUI(_Player);
		if(UI != Null){
			declare netwrite Boolean Net_RS_PlayerIsSpawning for UI;
			Net_RS_PlayerIsSpawning = _PlayerIsInSpawning;
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update the library
Void Yield() {
	if(G_IsColorListInstantiate != True){
		InstantiateColorList();
		InstantiateClansIds();
		G_IsColorListInstantiate = True;
	}
	declare netwrite Text[] Net_PlayersWithNoTeam for Teams[0];
	declare netwrite Text[] Net_PlayersInAutoJoin for Teams[0];
	declare netwrite Text[] Net_PlayersInATeam for Teams[0];
	declare netwrite Integer TeamRefresh for Teams[0];
	declare netwrite Boolean Net_NewMap for Teams[0];
	ManagePlayers(Net_NewMap);
	if(TeamRefresh > G_PrevTeamRefresh && Net_NewMap == False){
		GetAllPlayersInATeam();
		RemoveAutoFillLeaderInFullTeam();
		GetPlayersWithNoTeam();
		SendPlacesAvailableToClient();
		if(TeamRefresh > PrevTeamRefresh){
			PrevTeamRefresh = TeamRefresh;
			foreach(Player in Players){
				declare IsPlayerInATeam = False;
				IsPlayerInATeam = GetAllPlayersInTeam(Player);
				if(IsPlayerInATeam){
					if(!Net_PlayersInATeam.exists(Player.User.Login)){
						Net_PlayersInATeam.add(Player.User.Login);
					}
				} else Net_PlayersInATeam.remove(Player.User.Login);		
			}
		}
		G_PrevTeamRefresh = TeamRefresh;
	}

	if(G_LeadersReady.count > 0){
		CheckLeadersReadyToFillTheirTeam(G_LeadersReady);
	}
	Net_PlayersInAutoJoin = G_PlayersWaitingForAnAutoFillTeam;
	Net_PlayersWithNoTeam = G_PlayersWithNoTeam;
	foreach (Event in UIManager.PendingEvents) {
		if (Event.Type == CUIConfigEvent::EType::OnLayerCustomEvent) {
			switch (Event.CustomEventType) {
				case Const::C_UIEvent_TeamSelection_PlayersNeedHelpReceived: {
					if(Event.UI != Null && Event.CustomEventData.existskey(0)){
						declare LoginOfPlayerRestored = Event.CustomEventData[0];
						declare PlayerOfRestored <=> GetPlayerFromLogin(LoginOfPlayerRestored);
						declare PlayerRestoredMembers = GetCPlayerTeamMembers(PlayerOfRestored);
						foreach(MemberOfRestored in PlayerRestoredMembers){
							declare PlayerMemberOfRestored <=> GetPlayerFromLogin(MemberOfRestored);
							if(PlayerMemberOfRestored != Null){
								declare UI <=> UIManager.GetUI(PlayerMemberOfRestored);
								declare netwrite Text[] Net_PlayersNeedHelp for UI;
								Net_PlayersNeedHelp.remove(LoginOfPlayerRestored);
							}
						}
					}
				}	
				case Const::C_UI_Event_TeamSelection_TeamIsReadyToPlay: {
					if(Event.UI != Null && Event.CustomEventData.existskey(0)){
						declare LoginOfLeaderReadyToPlay = Event.CustomEventData[0];
						declare netwrite Integer TeamRefresh for Teams[0];
						TeamRefresh = Now;
						foreach(LeaderLogin => Team in G_AllTeams){
							if(LeaderLogin == LoginOfLeaderReadyToPlay){
								G_AllTeams[LeaderLogin].TeamReady = True;
								if(!G_LeadersReady.exists(LeaderLogin)){
									G_LeadersReady.add(LeaderLogin);
								}
							}
						}
						
					}
				}
				case Const::C_UI_Event_TeamSelection_CancelTeamIsReadyToPlay: {
					if(Event.UI != Null && Event.CustomEventData.existskey(0)){
						declare LoginOfLeaderReadyToPlay = Event.CustomEventData[0];
						declare netwrite Integer TeamRefresh for Teams[0];
						TeamRefresh = Now;
						foreach(LeaderLogin => Team in G_AllTeams){
							if(LeaderLogin == LoginOfLeaderReadyToPlay){
								G_AllTeams[LeaderLogin].TeamReady = False;
								if(!G_LeadersReady.exists(LeaderLogin)){
									G_LeadersReady.remove(LeaderLogin);
								}
							}
						}
					}
				}

				case Const::C_UI_Event_TeamSelection_AddMembersNumbers: {
					if(Event.UI != Null && Event.CustomEventData.existskey(0)){
						declare LoginOfEvent = Event.CustomEventData[0];
						foreach(LeaderLogin => Team in G_AllTeams){
							if(LeaderLogin == LoginOfEvent){
								G_AllTeams[LeaderLogin].MaxMatesNumber = Team.MaxMatesNumber + 1;
								foreach(Member in Team.AllTeamMembers){
									declare PlayerMember <=> GetPlayerFromLogin(Member);
									if(PlayerMember != Null){
										declare UI <=> UIManager.GetUI(PlayerMember);
										declare netwrite Integer Net_MatesNumberSet for UI;
										declare netwrite Integer Net_MatesNumbersChanged for UI;
										Net_MatesNumbersChanged = Now;
										Net_MatesNumberSet = G_AllTeams[LeaderLogin].MaxMatesNumber;
									}
								}
							}
						}
					}
				}

				case Const::C_UI_Event_TeamSelection_ResetMembersNumbers: {
					if(Event.UI != Null && Event.CustomEventData.existskey(0)){
						declare LoginOfEvent = Event.CustomEventData[0];
						declare netwrite Integer Net_TS2_PlayersPerTeam for Teams[0];
						foreach(LeaderLogin => Team in G_AllTeams){
							if(LeaderLogin == LoginOfEvent){
								G_AllTeams[LeaderLogin].MaxMatesNumber = Net_TS2_PlayersPerTeam;
								foreach(Member in Team.AllTeamMembers){
									declare PlayerMember <=> GetPlayerFromLogin(Member);
									if(PlayerMember != Null){
										declare UI <=> UIManager.GetUI(PlayerMember);
										declare netwrite Integer Net_MatesNumberSet for UI;
										declare netwrite Integer Net_MatesNumbersChanged for UI;
										Net_MatesNumbersChanged = Now;
										Net_MatesNumberSet = G_AllTeams[LeaderLogin].MaxMatesNumber;
									}
								}
							}
						}
					}
				}

				case Const::C_UI_Event_TeamSelection_RemoveMembersNumbers: {
					if(Event.UI != Null && Event.CustomEventData.existskey(0)){
						declare LoginOfEvent = Event.CustomEventData[0];
						foreach(LeaderLogin => Team in G_AllTeams){
							if(LeaderLogin == LoginOfEvent){
								G_AllTeams[LeaderLogin].MaxMatesNumber = Team.MaxMatesNumber - 1;
								foreach(Member in Team.AllTeamMembers){
									declare PlayerMember <=> GetPlayerFromLogin(Member);
									if(PlayerMember != Null){
										declare UI <=> UIManager.GetUI(PlayerMember);
										declare netwrite Integer Net_MatesNumberSet for UI;
										declare netwrite Integer Net_MatesNumbersChanged for UI;
										Net_MatesNumbersChanged = Now;
										Net_MatesNumberSet = G_AllTeams[LeaderLogin].MaxMatesNumber;
									}
								}
							}
						}
					}
				}
				case Const::C_UI_Event_TeamSelection_NeedHelp: {
					if(Event.UI != Null && Event.CustomEventData.existskey(0)){
						declare LoginOfPlayerNeedHelp = Event.CustomEventData[0];
						declare PlayerNeedHelp <=> GetPlayerFromLogin(LoginOfPlayerNeedHelp);
						if(PlayerNeedHelp != Null){
							declare PlayerNeedHelpMembers = GetCPlayerTeamMembers(PlayerNeedHelp);
							//Send Notification to all mates of player that need help
							foreach(MemberOfNeeder in PlayerNeedHelpMembers){
								declare PlayerMemberOfNeeder <=> GetPlayerFromLogin(MemberOfNeeder);
								if(PlayerMemberOfNeeder != Null){
									declare UI <=> UIManager.GetUI(PlayerMemberOfNeeder);
									declare netwrite Text[] Net_PlayersNeedHelp for UI;
									if(!Net_PlayersNeedHelp.exists(LoginOfPlayerNeedHelp)){
										Net_PlayersNeedHelp.add(LoginOfPlayerNeedHelp);
									}
								}
							}
						}
					
					}
				}
				case Const::C_UI_Event_TeamSelection_PlayerInAutoJoin: {
					if(Event.UI != Null && Event.CustomEventData.existskey(0)){
						declare NewMemberLogin = Event.CustomEventData[0];
						declare PlayerFromLogin <=> GetPlayerFromLogin(NewMemberLogin);
						if(PlayerFromLogin != Null){
							declare UI <=> UIManager.GetUI(PlayerFromLogin);
							declare netread Integer[] Net_SquadOptionsCheck for UI;
							if(!G_PlayersWaitingForAnAutoFillTeam.exists(NewMemberLogin)){
								G_PlayersWaitingForAnAutoFillTeam.add(NewMemberLogin);
								G_PlayersInAutoJoinTimer = Now;
								declare Integer TimeInWaitingList for PlayerFromLogin;
								TimeInWaitingList = Now;
							}
							declare netwrite Integer InvitersUpdatedTime for Teams[0];
							if(!G_InvitersToDelete.exists(NewMemberLogin)){
								G_InvitersToDelete.add(NewMemberLogin);
								SendInvitersToDeleteToClient(G_InvitersToDelete);
								InvitersUpdatedTime = Now;
							}
						}
						
					}
				}

				case Const::C_UI_Event_TeamSelection_PlayerCancelAutoJoin: {
					if(Event.UI != Null && Event.CustomEventData.existskey(0)){
						declare LoginOfCanceler = Event.CustomEventData[0];
						declare CancelerPlayer = CPlayer;
						CancelerPlayer = GetPlayerFromLogin(LoginOfCanceler);
						G_PlayersWaitingForAnAutoFillTeam.remove(LoginOfCanceler);
						G_PlayersInAutoJoinTimer = Now;
						//Savoir si le joueur est leader de sa team (Impossible d'annuler si le joueur trouve une team directement)
						//Dans ce cas, le supprimer de la team, si un autre joueur existe dans cette team, le mettre leader de cette team et l'ajouter dans la liste des leaders en attente
						if(G_LeadersToDisplay.exists(LoginOfCanceler)){
							G_LeadersToDisplay.remove(LoginOfCanceler);
							G_PlayersInAutoJoinTimer = Now;
						}
						declare netwrite Text[] Net_LeaderSpawnedList for Teams[0];
						if(Net_LeaderSpawnedList.exists(LoginOfCanceler)){
							Net_LeaderSpawnedList.remove(LoginOfCanceler);
						}
						if(G_PlayerInTeams.exists(LoginOfCanceler)){
							G_PlayerInTeams.remove(LoginOfCanceler);
						}
						declare netwrite Text[] PlayersInTeamList for Teams[0];
						PlayersInTeamList = G_PlayerInTeams;
						
						if(CancelerPlayer != Null){
							declare Boolean PlayerCanGoInTeam for CancelerPlayer;
							PlayerCanGoInTeam = False;
							foreach(TeamKey => Team in G_AllTeams){
								if(G_AllTeams[TeamKey].AllTeamMembers.exists(LoginOfCanceler)){
									//His name exist so we delete him from the members of the team
									G_AllTeams[TeamKey] = DeleteMembersFromHisTeam(Team, LoginOfCanceler);
									G_AllPlayersInAnyTeam.remove(LoginOfCanceler);
									declare netwrite Text[] Net_AllPlayersInTeam for Teams[0];
									declare netwrite Integer Net_AllPlayersInTeamTimer for Teams[0];
									declare UIOfCanceler <=> UIManager.GetUI(CancelerPlayer);
									declare netwrite Boolean IsInTeam for UIOfCanceler;
									IsInTeam = False;
									declare netwrite Integer IsInTeamTimer for UIOfCanceler;
									IsInTeamTimer = Now;
									Net_AllPlayersInTeam = G_AllPlayersInAnyTeam;
									Net_AllPlayersInTeamTimer = Now;
								}
								if(G_AllTeams[TeamKey].Leader == CancelerPlayer.User.Login){
									declare NewLeader = CPlayer;
									//Check if the position 0 exist
									if(G_AllTeams[TeamKey].AllTeamMembers.count > 0){
										declare KTeam NewTeam;
										declare Text NewLeaderLogin;
										NewLeaderLogin = G_AllTeams[TeamKey].AllTeamMembers[0];
										NewLeader = GetPlayerFromLogin(NewLeaderLogin);
										NewTeam = G_AllTeams[TeamKey];
										NewTeam.Leader = NewLeader.User.Login;
										G_AllTeams[NewLeaderLogin] = NewTeam;
										G_AllTeams.removekey(TeamKey);
										if(!G_LeadersToDisplay.exists(NewLeaderLogin)){
											G_LeadersToDisplay.add(NewLeaderLogin);
											G_PlayersInAutoJoinTimer = Now;
											G_AllTeams[TeamKey].TeamInAutoFill = True;
										}
									}
									//Position 0 doesn't exist, the team is empty, destroy it
									else if (G_AllTeams[TeamKey].AllTeamMembers.count <= 0){
										SetColorNotUsed(G_AllTeams[TeamKey].TeamColor);
										SetClanIdNotUsed(G_AllTeams[TeamKey].ClanId);
										G_AllTeams.removekey(TeamKey);
									}
								}
							}
						}	
					}
				}

				case Const::C_UI_Event_TeamSelection_LeaveTeam: {
					if(Event.UI != Null && Event.CustomEventData.existskey(0)){
						declare Leaver = Event.CustomEventData[0];
						declare LeaverPlayer = CPlayer;
						LeaverPlayer = GetPlayerFromLogin(Leaver);
						declare netwrite Integer InvitersUpdatedTime for Teams[0];
						declare netwrite Text[] Net_LeaderSpawnedList for Teams[0];
						if(G_LeadersReady.exists(Leaver)){
							G_LeadersReady.remove(Leaver);
						}
						XmlRpc.SendCallbackArray("stats", ["Leave Team", ""^Leaver, "1"]);
						XmlRpc.SendCallbackArray("stats", ["Leave Team", "Total leave", "1"]);
						if(G_LeadersToDisplay.exists(Leaver)){
							G_LeadersToDisplay.remove(Leaver);
							G_PlayersInAutoJoinTimer = Now;
						}
						if(G_PlayersWaitingForAnAutoFillTeam.exists(Leaver)){
							G_PlayersWaitingForAnAutoFillTeam.remove(Leaver);
						}
						if(!G_InvitersToDelete.exists(Leaver)){
							G_InvitersToDelete.add(Leaver);
							SendInvitersToDeleteToClient(G_InvitersToDelete);
							InvitersUpdatedTime = Now;
						}
						if(G_PlayerInTeams.exists(Leaver)){
							G_PlayerInTeams.remove(Leaver);
						}
						
						declare netwrite Text[] PlayersInTeamList for Teams[0];
						PlayersInTeamList = G_PlayerInTeams;
						//Check all teams saved in G_AllTeams
						foreach (TeamIndex => Team in G_AllTeams) {
							//Check if in a team, we can see the login of the leaver in the player members
							if(G_AllTeams[TeamIndex].AllTeamMembers.exists(Leaver)){
								//His name exist so we delete him from the members of the team
								G_AllTeams[TeamIndex] = DeleteMembersFromHisTeam(Team, Leaver);
								G_AllPlayersInAnyTeam.remove(Leaver);
								declare netwrite Text[] Net_AllPlayersInTeam for Teams[0];
								
								if(LeaverPlayer != Null){
									declare Boolean PlayerCanGoInTeam for LeaverPlayer;
									PlayerCanGoInTeam = False;
									declare UIOfLeaver <=> UIManager.GetUI(LeaverPlayer);
									declare netwrite Boolean IsPlayerSpawned for UIOfLeaver;
									declare netwrite Integer IsPlayerSpawnedTimer for UIOfLeaver;
									declare netwrite Boolean IsInTeam for UIOfLeaver;
									declare netwrite Integer Net_AllPlayersInTeamTimer for Teams[0];
									declare netwrite Integer Net_TS2_PlayersPerTeam for Teams[0];
									declare netwrite Integer Net_MatesNumberSet for UIOfLeaver;
									Net_MatesNumberSet = Net_TS2_PlayersPerTeam;
									declare netwrite Integer Net_MatesNumbersChanged for UIOfLeaver;
									Net_MatesNumbersChanged = Now;
									Net_AllPlayersInTeamTimer = Now;
									IsInTeam = False;
									declare netwrite Integer IsInTeamTimer for UIOfLeaver;
									IsInTeamTimer = Now;
									IsPlayerSpawnedTimer = Now;
									Net_AllPlayersInTeam = G_AllPlayersInAnyTeam;
									IsPlayerSpawned = False;
								}
							}
							if(LeaverPlayer != Null){
								if(G_AllTeams[TeamIndex].Leader == LeaverPlayer.User.Login){
									declare NewLeader = CPlayer;
									//Check if the position 0 exist
									if(G_AllTeams[TeamIndex].AllTeamMembers.count > 0){
										declare KTeam NewTeam;
										declare Text NewLeaderLogin;
										NewLeaderLogin = G_AllTeams[TeamIndex].AllTeamMembers[0];
										NewLeader = GetPlayerFromLogin(NewLeaderLogin);
										if(NewLeader != Null){
											declare UIOfNewLeader <=> UIManager.GetUI(NewLeader);
											if(G_PlayersJoiningAnAutoFillTeamAndCanGoesLeader.exists(NewLeaderLogin)){
												if(!G_LeadersToDisplay.exists(NewLeaderLogin)){
													G_LeadersToDisplay.add(NewLeaderLogin);
													G_PlayersInAutoJoinTimer = Now;
													G_PlayersJoiningAnAutoFillTeamAndCanGoesLeader.remove(NewLeaderLogin);
													G_AllTeams[TeamIndex].TeamInAutoFill = True;
												}
											}
											if(Net_LeaderSpawnedList.exists(Leaver)){
												Net_LeaderSpawnedList.add(NewLeaderLogin);
												Net_LeaderSpawnedList.remove(Leaver);
											}
											NewTeam = G_AllTeams[TeamIndex];
											NewTeam.Leader = NewLeader.User.Login;
											G_AllTeams[NewLeaderLogin] = NewTeam;
											declare netwrite Integer AutoAutoFillTimer for UIOfNewLeader;
											AutoAutoFillTimer = Now;
											G_LeadersReady.add(NewLeaderLogin);
											G_AllTeams[NewLeaderLogin].TeamInAutoFill = True;
											if(G_LeadersToDisplay.exists(NewLeaderLogin)){
												G_AllTeams[NewLeaderLogin].TeamReady = True;
											}
											declare netwrite Integer TeamRefresh for Teams[0];
											TeamRefresh = Now;
											G_AllTeams.removekey(TeamIndex);
										}
										
									}
									//Position 0 doesn't exist, the team is empty, destroy it
									else if (G_AllTeams[TeamIndex].AllTeamMembers.count <= 0){
										SetColorNotUsed(G_AllTeams[TeamIndex].TeamColor);
										SetClanIdNotUsed(G_AllTeams[TeamIndex].ClanId);
										G_AllTeams.removekey(TeamIndex);
									}
								}	
							}
							//Check if the leaver his the leader of his team
						}

						if(Net_LeaderSpawnedList.exists(Leaver)){
							Net_LeaderSpawnedList.remove(Leaver);
						}
					}
				}
				case Const::C_UIEvent_TeamSelection_InvitersToDestroyUpdated: {
					if(Event.UI != Null && Event.CustomEventData.existskey(0)){
						declare InviterDeleted = Event.CustomEventData[0];
						
						if(G_InvitersToDelete.exists(InviterDeleted)){
							G_InvitersToDelete.remove(InviterDeleted);
							SendInvitersToDeleteToClient(G_InvitersToDelete);
						}
					}

				}
				case Const::C_UIEvent_TeamSelection_LeaveTeamCreation: {
					//Can be send if a player was in the team creation menu but not in team
					if(Event.UI != Null && Event.CustomEventData.existskey(0)){
						declare InviterToDelete = Event.CustomEventData[0];
						declare netwrite Text[] Client_PlayersInTeamList for Teams[0];
						declare netwrite Integer InvitersUpdatedTime for Teams[0];
						InvitersUpdatedTime = Now;
						if(G_LeadersReady.exists(InviterToDelete)){
							G_LeadersReady.remove(InviterToDelete);
						}
						if(!G_InvitersToDelete.exists(InviterToDelete)){
							G_InvitersToDelete.add(InviterToDelete);
							SendInvitersToDeleteToClient(G_InvitersToDelete);
						}
					}
				}

				case Const::C_UIEvent_TeamSelection_OpenTeamCreation: {
					if(Event.UI != Null && Event.CustomEventData.existskey(0)){
						declare InviterToDeleteFromInvitersToDelete = Event.CustomEventData[0];
						declare CPlayer Chief;
						declare KTeam	TeamCreated;
						
						Chief <=> GetPlayerFromLogin(InviterToDeleteFromInvitersToDelete);
						if(Chief != Null){
							if(G_InvitersToDelete.exists(InviterToDeleteFromInvitersToDelete)){
								G_InvitersToDelete.remove(InviterToDeleteFromInvitersToDelete);
								SendInvitersToDeleteToClient(G_InvitersToDelete);
							}
							if(!G_AllTeams.existskey(InviterToDeleteFromInvitersToDelete)){
								declare UI <=> UIManager.GetUI(Chief);
								declare netwrite Integer Net_MatesNumberSet for UI;
								TeamCreated = CreateNewTeam(Chief, 4);
								G_AllTeams[InviterToDeleteFromInvitersToDelete].MaxMatesNumber = 4;
								Net_MatesNumberSet = G_AllTeams[InviterToDeleteFromInvitersToDelete].MaxMatesNumber;
								declare netwrite Integer Net_MatesNumbersChanged for UI;
								Net_MatesNumbersChanged = Now;
							}
							if(G_LeadersToDisplay.exists(InviterToDeleteFromInvitersToDelete)){
								G_LeadersToDisplay.remove(InviterToDeleteFromInvitersToDelete);
							}	
						}
						
					}
				}

				case Const::C_UIEvent_TeamSelection_LeaderInFullTeam: {
					if(Event.UI != Null && Event.CustomEventData.existskey(0)){
						declare LeaderToRemove = Event.CustomEventData[0];
						declare Leader = CPlayer;
						declare netwrite Integer InvitersUpdatedTime for Teams[0];
						Leader <=> GetPlayerFromLogin(LeaderToRemove);
						XmlRpc.SendCallbackArray("stats", ["Event Team Full", "Full Team", "1"]);

						if(!G_InvitersToDelete.exists(LeaderToRemove)){
							G_InvitersToDelete.add(LeaderToRemove);
							SendInvitersToDeleteToClient(G_InvitersToDelete);
							InvitersUpdatedTime = Now;
						}

						if(G_LeadersToDisplay.exists(LeaderToRemove)){
							G_LeadersToDisplay.remove(LeaderToRemove);
							G_PlayersInAutoJoinTimer = Now;
						}
						declare netwrite Text[] Net_LeaderSpawnedList for Teams[0];
						if(!Net_LeaderSpawnedList.exists(LeaderToRemove)){
							Net_LeaderSpawnedList.add(LeaderToRemove);
						}
						if(Leader != Null){
							foreach (LeaderLogin => Team in G_AllTeams) {
								if(G_AllTeams[LeaderLogin].Leader == Leader.User.Login){
									G_AllTeams[LeaderLogin].TeamInAutoFill = False;
									foreach(Member in G_AllTeams[LeaderLogin].AllTeamMembers){
										if(G_PlayersWaitingForAnAutoFillTeam.exists(Member)){
											G_PlayersWaitingForAnAutoFillTeam.remove(Member);
										}
									}
								}
							}
						}
						
					}
				}

				case Const::C_UIEvent_TeamSelection_AllPlayersInTeam: {
					if(Event.UI != Null && Event.CustomEventData.existskey(0)){
						declare PlayerNameInTeam = Event.CustomEventData[0];

						if(!G_AllPlayersInAnyTeam.exists(PlayerNameInTeam)){
							G_AllPlayersInAnyTeam.add(PlayerNameInTeam);
						}
						declare netwrite Text[] Net_AllPlayersInTeam for Teams[0];
						Net_AllPlayersInTeam = G_AllPlayersInAnyTeam;
						declare netwrite Integer Net_AllPlayersInTeamTimer for Teams[0];
						Net_AllPlayersInTeamTimer = Now;
					}
				}
				//Each time a player is in a team -> Send the player in a PlayerInTeam array
				case Const::C_UIEvent_TeamSelection_MemberInTeam: {
					if(Event.UI != Null && Event.CustomEventData.existskey(0)){
						declare PlayerInTeam = Event.CustomEventData[0];
						declare netwrite Text[] Client_PlayersInTeamList for Teams[0];
						if(!G_PlayerInTeams.exists(PlayerInTeam)){
							G_PlayerInTeams.add(PlayerInTeam);
						}
						declare netwrite Text[] PlayersInTeamList for Teams[0];
						PlayersInTeamList = G_PlayerInTeams;
						G_PlayerInTeams = Client_PlayersInTeamList;
					
					}
				}
				//Each time a player is selected by a player -> Send invitation
				case Const::C_UIEvent_TeamSelection_SelectPlayer: {
					if (Event.UI != Null && Event.CustomEventData.existskey(0)) {
						declare LoginOfInvited = Event.CustomEventData[0]; 
						declare Requested = CPlayer;
						declare FakePlayerRequested = CPlayer;
						declare Chief = CPlayer;
						declare Requester = CPlayer;
						declare KTeam	TeamCreated;

						Requested <=> GetRequestedFromLogin(LoginOfInvited);
						FakePlayerRequested <=> GetPlayerFromLogin(LoginOfInvited);
						Requester <=> GetRequesterFromEvent(Event);
						Chief <=> GetRequesterFromEvent(Event);
						if (!AreRequestedAndRequesterNotNull(Requested, Requester)) {
							continue;
						}
						if(G_PlayersWaitingForAnAutoFillTeam.exists(LoginOfInvited)){
							if(Requested != Null && Requester != Null){
								declare UIOfInvited <=> UIManager.GetUI(Requested);
								declare netread Integer[] Net_SquadOptionsCheck for UIOfInvited;
								if(!G_AllTeams.existskey(Requester.User.Login)){
									declare UI <=> UIManager.GetUI(Requester);
									declare netwrite Integer Net_MatesNumberSet for UI;
									TeamCreated = CreateNewTeam(Requester, Net_MatesNumberSet);
								}	
								if(G_AllTeams.existskey(Requester.User.Login)){
									if(G_AllTeams[Requester.User.Login].Leader == Requester.User.Login && Net_SquadOptionsCheck.exists(G_AllTeams[Requester.User.Login].MaxMatesNumber)){
										G_AllTeams[Requester.User.Login] = AddMembersInExistingTeam(G_AllTeams[Requester.User.Login], Requested); // On ajoute dans la team le member concerné
										if(G_PlayersWaitingForAnAutoFillTeam.exists(LoginOfInvited)){
											G_PlayersWaitingForAnAutoFillTeam.remove(LoginOfInvited);
										}
										if(G_LeadersToDisplay.exists(LoginOfInvited)){
											G_LeadersToDisplay.remove(LoginOfInvited);
											G_PlayersInAutoJoinTimer = Now;
										}
										if(G_AllTeams.existskey(LoginOfInvited)){
											SetColorNotUsed(G_AllTeams[LoginOfInvited].TeamColor);
											SetClanIdNotUsed(G_AllTeams[LoginOfInvited].ClanId);
											G_AllTeams.removekey(LoginOfInvited);
										}
										if(!G_PlayersJoiningAnAutoFillTeamAndCanGoesLeader.exists(LoginOfInvited)){
											G_PlayersJoiningAnAutoFillTeamAndCanGoesLeader.add(LoginOfInvited);
										}	
										declare UIOfChief <=> UIManager.GetUI(Requester);
										declare netwrite Boolean IsInTeam for UIOfChief; 
										IsInTeam = True;
										declare netwrite Integer IsInTeamTimer for UIOfChief;
										IsInTeamTimer = Now;
									}
								}
							}
						
						} else	GiveInviteFromRequesterToRequested(Requester, Requested);

						/*if(FakePlayerRequested.IsFakePlayer && FakePlayerRequested.User.Login != "*fakeplayer6*"){
							declare KTeam	TeamCreated;
							//Check if a team with the leader login exist
							if(!G_AllTeams.existskey(Chief.User.Login)){
								TeamCreated = CreateNewTeam(Chief);
							}
							// The leader now exist, so we have to add the member into the KTeam of the leader...
							if(G_AllTeams.existskey(Chief.User.Login)){
								foreach(LeaderLogin => Team in G_AllTeams){
									if(G_AllTeams[LeaderLogin].Leader == Chief.User.Login){
										G_AllTeams[LeaderLogin] = AddMembersInExistingTeam(G_AllTeams[LeaderLogin], Requested); // On ajoute dans la team le member concerné
										declare UIOfChief <=> UIManager.GetUI(Chief);
										declare netwrite Boolean IsInTeam for UIOfChief; 
										IsInTeam = True;
										declare netwrite Integer IsInTeamTimer for UIOfChief;
										IsInTeamTimer = Now;
									}
								}
							}
						}*/
					}
				}
				//When a leader is requested by a Player, send to his Request List
				case Const::C_UIEvent_TeamSelection_RequestToLeader: {
					if (Event.UI != Null && Event.CustomEventData.existskey(0)) {
						declare LoginOfLeader = Event.CustomEventData[0];
						declare RequestedLeader = CPlayer;
						declare RequesterMember = CPlayer;

						RequestedLeader <=> GetChiefFromLogin(LoginOfLeader);
						RequesterMember <=> GetInvitedFromEvent(Event);

						if (!AreRequestedAndRequesterNotNull(RequesterMember, RequestedLeader)){
							continue;
						}
						SendInviteFromRequesterMemberToLeader(RequesterMember, RequestedLeader);
					}
				}
				case Const::C_UIEvent_TeamSelection_LeaderAcceptRequest: {
					if (Event.UI != Null && Event.CustomEventData.existskey(0)){
					
						declare LoginOfRequesterToLeader = Event.CustomEventData[0];
						declare SquadMember = CPlayer;
						declare Chief = CPlayer;
						
						Chief <=> GetInvitedFromEvent(Event);
						SquadMember <=> GetChiefFromLogin(LoginOfRequesterToLeader);
						
						foreach (LeaderLogin => Team in G_AllTeams) {
							//Si une team présente dans allteam à sa variable leader = au leader de la requete, alors on peut ajouter le membre dans cette team
							if(G_AllTeams[LeaderLogin].Leader == Chief.User.Login){
								G_AllTeams[LeaderLogin] = AddMembersInExistingTeam(G_AllTeams[LeaderLogin], SquadMember);// On ajoute dans la team le member concerné
								declare UIOfChiefToJoin <=> UIManager.GetUI(Chief);
								declare netwrite Boolean IsInTeam for UIOfChiefToJoin; 
								IsInTeam = True;
								declare netwrite Integer IsInTeamTimer for UIOfChiefToJoin;
								IsInTeamTimer = Now;
							}
						}
					}
				}
				case Const::C_UI_Event_TeamSelection_TeamInAutoFill: {
					if (Event.UI != Null && Event.CustomEventData.existskey(0)){
						//Add the leader list in the list of leaders to display
						//Then if a player click on the leader name, automatically join the leader team
						declare LoginOfLeader = Event.CustomEventData[0];
						if(!G_LeadersToDisplay.exists(LoginOfLeader)){
							G_LeadersToDisplay.add(LoginOfLeader);
							G_PlayersInAutoJoinTimer = Now;
						}
						if(!G_LeadersReady.exists(LoginOfLeader)){
							G_LeadersReady.add(LoginOfLeader);
						}
						declare netwrite Integer TeamRefresh for Teams[0];
						TeamRefresh = Now;
						foreach(LeaderLogin => Team in G_AllTeams){
							if(LeaderLogin == LoginOfLeader){
								G_AllTeams[LeaderLogin].TeamReady = True;
								G_AllTeams[LeaderLogin].TeamInAutoFill = True;
								declare netwrite Integer TeamRefresh for Teams[0];
								TeamRefresh = Now;
							}
						}
					}
				}
				case Const::C_UI_Event_TeamSelection_CancelTeamInAutoFill: {
					if(Event.UI != Null && Event.CustomEventData.existskey(0)){
						declare LoginOfLeader = Event.CustomEventData[0];
						if(G_LeadersToDisplay.exists(LoginOfLeader)){
							G_LeadersToDisplay.remove(LoginOfLeader);
							G_PlayersInAutoJoinTimer = Now;
						}
						if(G_LeadersReady.exists(LoginOfLeader)){
							G_LeadersReady.remove(LoginOfLeader);
						}
						declare netwrite Integer TeamRefresh for Teams[0];
						TeamRefresh = Now;
						foreach(LeaderLogin => Team in G_AllTeams){
							if(LeaderLogin == LoginOfLeader){
								G_AllTeams[LeaderLogin].TeamInAutoFill = False;
							}
						}
					}
				}
				case Const::C_UIEvent_TeamSelection_AcceptRequest: {
					if (Event.UI != Null && Event.CustomEventData.existskey(0)) {
						declare LoginOfChief = Event.CustomEventData[0];
						declare SquadMember = CPlayer;
						declare Chief = CPlayer;
								
						Chief <=> GetChiefFromLogin(LoginOfChief);
						SquadMember <=> GetInvitedFromEvent(Event);
						declare KTeam	TeamCreated;
						if(Chief != Null && SquadMember != Null){
							//Check if a team with the leader login exist
							if(!G_AllTeams.existskey(Chief.User.Login)){
								declare UI <=> UIManager.GetUI(Chief);
								declare netwrite Integer Net_MatesNumberSet for UI;
								TeamCreated = CreateNewTeam(Chief, Net_MatesNumberSet);
							}

							// The leader now exist, so we have to add the member into the KTeam of the leader...
							if(G_AllTeams.existskey(Chief.User.Login)){
								foreach(LeaderLogin => Team in G_AllTeams){
									if(G_AllTeams[LeaderLogin].Leader == Chief.User.Login){
										G_AllTeams[LeaderLogin] = AddMembersInExistingTeam(G_AllTeams[LeaderLogin], SquadMember); // On ajoute dans la team le member concerné
										declare UIOfChief <=> UIManager.GetUI(Chief);
										declare netwrite Boolean IsInTeam for UIOfChief; 
										IsInTeam = True;
										declare netwrite Integer IsInTeamTimer for UIOfChief;
										IsInTeamTimer = Now;
										
									}
								}
							}
						}
						
					}
				}

				case Const::C_UIEvent_TeamSelection_FindTeammate: {
					declare Player <=> FindPlayerFromUI(Event.UI);
					if (Player != Null) {
						UseRandomTeammate(True, Player);
					}
				}
				case Const::C_UIEvent_TeamSelection_CancelSearch: {
					declare Player <=> FindPlayerFromUI(Event.UI);
					if (Player != Null) {
						UseRandomTeammate(False, Player);
					}
				}
				case Const::C_UIEvent_TeamSelection_CancelInvite: {
					declare Player <=> FindPlayerFromUI(Event.UI);
					if (Player != Null) {
						SetTeammate(Null, Player);
					}
				}
				case Const::C_UIEvent_TeamSelection_LeaveTeam: {
					declare Player <=> FindPlayerFromUI(Event.UI);
					if (Player != Null) {
						declare ValidatedTeammate = GetValidatedTeammate(Player);
						if (ValidatedTeammate != Null) SetTeammate(Null, ValidatedTeammate);
						SetTeammate(Null, Player);
					}
				}
			}
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Initialize a player state when
 *	they join the server
 *
 *	@param	_Player										The player to initialize
 */
Void InitializePlayer(CPlayer _Player) {
	Enable(False, _Player);
	SetTeammate(Null, _Player);
	UseRandomTeammate(False, _Player);
	declare UI <=> UIManager.GetUI(_Player);
	declare netwrite Integer[Integer] Net_PlacesAvailable for UI;
	Net_PlacesAvailable = G_PlacesAvailable;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Unload the library
Void Unload() {
	foreach (Player in AllPlayers) {
		InitializePlayer(Player);
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Load the library
Void Load() {
	Unload();
}