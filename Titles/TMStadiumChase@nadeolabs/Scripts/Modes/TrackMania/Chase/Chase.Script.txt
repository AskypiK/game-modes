/**
 *	Chase Attack mode
 */
#Extends "Modes/TrackMania/Base/ModeTrackmania.Script.txt"

#Const	CompatibleMapTypes	"Race"
#Const	Version							"2018-07-13"
#Const	ScriptName					"Modes/TrackMania/Chase/Chase.Script.txt"

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Libraries
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Include "TextLib" as TL
#Include "MathLib" as ML
#Include "Libs/Nadeo/TrackMania/Chase/Common.Script.txt" as Chase
#Include "Libs/Nadeo/TrackMania/Chase/Constants2.Script.txt" as Const
#Include "Libs/Nadeo/TrackMania/Chase/Clans.Script.txt" as Clans
#Include "ManiaApps/Nadeo/TrackMania/Chase/ChaseAttack_Server.Script.txt" as ChaseUI
#Include "ManiaApps/Nadeo/TrackMania/Chase/ChaseTuto_Server.Script.txt" as ChaseTuto
#Include "ManiaApps/Nadeo/TrackMania/Chase/Team_Server.Script.txt" as TeamUI
#Include "ManiaApps/Nadeo/TrackMania/Chase/TeamSelection_Server.Script.txt" as TeamSelectionUI
#Include "ManiaApps/Nadeo/TrackMania/Chase/Winners_Server.Script.txt" as WinnersUI
#Include "ManiaApps/Nadeo/TrackMania/Chase/Medal_Server.Script.txt" as MedalUI
#Include "ManiaApps/Nadeo/TrackMania/Chase/Ladder_Server.Script.txt" as LadderUI
#Include "ManiaApps/Nadeo/TrackMania/Chase/TeamConfirm_Server.Script.txt" as TeamConfirmUI
#Include "ManiaApps/Nadeo/TrackMania/Chase/FinishTimeout_Server.Script.txt" as FinishTimeoutUI
#Include "ManiaApps/Nadeo/TrackMania/Chase/CheckpointTime_Server.Script.txt" as CheckpointTimeUI
#Include "ManiaApps/Nadeo/TrackMania/Chase/CheckpointRanking_Server.Script.txt" as CheckpointRankingUI
#Include "ManiaApps/Nadeo/TrackMania/Chase/Restart_Server.Script.txt" as RestartUI
#Include "ManiaApps/Nadeo/TrackMania/Chase/Relay_Server.Script.txt" as RelayUI

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Settings
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
#Setting S_TimeLimit 300 as _("Time limit :")
#Setting S_ForceLapsNb -1 as _("Number of Laps :")
#Const S_TeamPlayersNb 2 //as _("Number of players in a team :")
#Const S_FailedRelayPenalty -1 //as _("Failed relay penalty time :")
#Const S_RespawnPenalty -1 //as _("Respawn penalty time :")
#Setting S_FinishTimeout 5 as _("Finish timeout :")
#Setting S_DisplayWarning True as _("Display a warning message when relay fails :")
#Setting S_WaypointEventDelay 300 as "<hidden>" // _("Waypoint event delay :")
#Setting S_WarmUpNb 0 as _("Number of warm up :")
#Setting S_WarmUpDuration 0 as _("Duration of one warm up :")
#Setting S_ChatTime 20 //< Override default chat time to give more time for the LP ranking

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Performance computing properties
#Const C_PerfLow 5000
#Const C_PerfHigh 15000
#Const C_RatioLow 0.7
#Const C_RatioHigh 0.3

// Checkpoint grades
#Const C_Checkpoint_Grades [
	//L16N [Chase] Grade given when doing an really really relay at the checkpoint
	_("|Chase|Legendary"),
	//L16N [Chase] Grade given when doing a really good relay at the checkpoint
	_("|Chase|Excellent"),
	//L16N [Chase] Grade given when doing a good relay at the checkpoint
	_("|Chase|Good"),
	//L16N [Chase] Grade given when doing a nice relay at the checkpoint
	_("|Chase|Nice"),
	//L16N [Chase] Grade given when validating a relay at the checkpoint without a good time
	" "//_("|Chase|Safe")
	
]
#Const C_Checkpoint_Scores [
	20000, //< Legendary
	9200, //< Excellent
	5000, //< Good
	1200, //< Nice
	1 //< Safe
]
#Const C_Checkpoint_Colors [
	<0.36, 0.8, 0.4>, //< Legendary
	<0.93, 0.83, 0.13>, //< Excellent
	<0.53, 0.54, 0.58>, //< Good
	<0.71, 0.45, 0.27>, //< Nice
	<0.9, 0., 0.> //< Safe
]
//L16N [Chase] Grade given when leading the relay at the checkpoint
#Const C_Checkpoint_RelayGrade _("|Chase|Relay")
#Const C_Checkpoint_RelayColor <0.79, 0., 0.84>

#Const C_CheckpointScoreMax 35000 ///< Maximum score at checkpoint
#Const C_NoNameCheckpoint "-" ///< Default name when no player is selected for next checkpoint /!\ Also used in the ManiaApp /!\
#Const C_RespawnPenaltyNbMax 3 ///< Maximum number of cumulated respawn penalty
#Const C_RespawnAfterFailedRelay True ///< Respawn the players when they fail a relay
#Const C_CheckpointMarkerDistance 160. ///< Maximum visibility distance for the checkpoint markers
#Const C_CheckpointTimeDisplayDuration 2000 ///< Duration of the display of the player's time at the checkpoint
#Const C_UseCollegialRestart True ///< Every player of a team must confirm before restarting the race with their teammates
#Const C_RestartDelay 3000 ///< Delay before restarting a team during the collegial restart
#Const C_MedalPopDuration 3000 ///< Display duration of the medal pop-up at the end of the race
#Const C_UnlockLesserMedals False ///< Also unlock medals below the one that was just one. eg: gold also unlock bronze and silver.
#Const C_RelayFailWarningDuration 3000 ///< Display duration of the failed relay warning
#Const C_SpawnLobbyPlayers False ///< Spawn players currently in the lobby or not
#Const C_WaypointEventLagProtection True ///< Try to ignore waypoint event from the previous player race
#Const C_BotsNb 0 ///< Number of bots on the server

#Const C_HudModulePath "Nadeo/TrackMania/Chase/ChaseAttack/Hud.Module.Gbx" ///< Path to the hud module
#Const C_ManiaAppUrl "file://Media/ManiaApps/Nadeo/TrackMania/Chase/ChaseAttack.Script.txt"

//L16N [Chase] Short description of the Chase Attack game mode
#Const Description _("""$fffIn $f00Chase Attack$fff mode, the goal is to set the $f00best time$fff with your team. To finish a race the $f00last$fff player of a team passing a checkpoint must be the $f00first$fff at the next one.""")

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Extends
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
***Match_LogVersions***
***
Log::RegisterScript(ScriptName, Version);
Log::RegisterScript(Chase::ScriptName, Chase::Version);
Log::RegisterScript(ChaseUI::ScriptName, ChaseUI::Version);
Log::RegisterScript(ChaseTuto::ScriptName, ChaseTuto::Version);
Log::RegisterScript(TeamUI::ScriptName, TeamUI::Version);
Log::RegisterScript(TeamSelectionUI::ScriptName, TeamSelectionUI::Version);
Log::RegisterScript(WinnersUI::ScriptName, WinnersUI::Version);
Log::RegisterScript(MedalUI::ScriptName, MedalUI::Version);
Log::RegisterScript(LadderUI::ScriptName, LadderUI::Version);
Log::RegisterScript(TeamConfirmUI::ScriptName, TeamConfirmUI::Version);
Log::RegisterScript(FinishTimeoutUI::ScriptName, FinishTimeoutUI::Version);
Log::RegisterScript(CheckpointTimeUI::ScriptName, CheckpointTimeUI::Version);
Log::RegisterScript(CheckpointRankingUI::ScriptName, CheckpointRankingUI::Version);
Log::RegisterScript(RestartUI::ScriptName, RestartUI::Version);
Log::RegisterScript(RelayUI::ScriptName, RelayUI::Version);
***

***Match_LoadLibraries***
***
ChaseUI::Load();
ChaseTuto::Load();
TeamUI::Load();
TeamSelectionUI::Load();
WinnersUI::Load();
MedalUI::Load();
LadderUI::Load();
TeamConfirmUI::Load();
FinishTimeoutUI::Load();
CheckpointTimeUI::Load();
CheckpointRankingUI::Load();
RestartUI::Load();
RelayUI::Load();
***

***Match_UnloadLibraries***
***
RelayUI::Unload();
RestartUI::Unload();
CheckpointRankingUI::Unload();
CheckpointTimeUI::Unload();
FinishTimeoutUI::Unload();
TeamConfirmUI::Unload();
LadderUI::Unload();
MedalUI::Unload();
WinnersUI::Unload();
TeamSelectionUI::Unload();
TeamUI::Unload();
ChaseTuto::Unload();
ChaseUI::Unload();
***

***Match_Settings***
***
MB_Settings_UseDefaultHud = False;
MB_Settings_UseDefaultPodiumSequence = False;
***

***Match_Rules***
***
ModeInfo::SetName("Chase Attack");
ModeInfo::SetType(ModeInfo::C_Type_MultiTeams);
ModeInfo::SetRules(Description);
ModeInfo::SetStatusMessage(_("TYPE: Multi teams\nOBJECTIVE: Set the best time on the track."));
***

***Match_LoadHud***
***
ClientManiaAppUrl = C_ManiaAppUrl;
Hud_Load(C_HudModulePath);
MB_SortScores(CTmMode::ETmScoreSortOrder::TotalPoints);

if (Hud != Null && Hud.ScoresTable != Null) {
	Hud.ScoresTable.SetColumnVisibility(CModulePlaygroundScoresTable::EColumnType::Tools, True);
	Hud.ScoresTable.SetColumnVisibility(CModulePlaygroundScoresTable::EColumnType::Tags, True);
	Hud.ScoresTable.SetColumnVisibility(CModulePlaygroundScoresTable::EColumnType::ManiaStars, True);
	Hud.ScoresTable.SetColumnVisibility(CModulePlaygroundScoresTable::EColumnType::TMBestTime, True);
	Hud.ScoresTable.ResetCustomColumns();
	Hud.ScoresTable.SetColumnVisibility("Combo", False);
	Hud.ScoresTable.SetColumnVisibility("Legendary", False);
	Hud.ScoresTable.SetColumnVisibility("BestCheckpoint", False);
}

// Initialize UI modules
UI::LoadModules([
	UIModules::C_Module_Chrono,
	UIModules::C_Module_PrevBestTime,
	UIModules::C_Module_SpeedAndDistance,
	UIModules::C_Module_Countdown,
	UIModules::C_Module_Laps,
	UIModules::C_Module_MapInfo,
	UIModules::C_Module_MapRanking,
	UIModules::C_Module_LiveInfo,
	UIModules::C_Module_SpectatorInfo,
	UIModules::C_Module_ViewersCount
]);
UI::DisplayTimeDiff(False);
UI::SetTimeGapMode("BestRace");
UI::SetCheckpointTimeMode("BestRace");

ChaseUI::SetHeaderVisibility(False);
ChaseUI::SetPenaltiesVisibility(S_FailedRelayPenalty > 0);
ChaseUI::SetFinishVisibility(True);
foreach (Player in AllPlayers) {
	ChaseUI::SetVisibility(False, Player);
}
ChaseTuto::Enable(False);
TeamUI::Enable(False);
WinnersUI::Enable(False);
RestartUI::Enable(False);
MedalUI::UnlockLesserMedal(C_UnlockLesserMedals);

// Disable respawn/restart tutorial
UiDisableHelpMessage = True;

UIManager.UIAll.OverlayHideCheckPointList = True;
UIManager.UIAll.OverlayHideCheckPointTime = True;
UIManager.UIAll.OverlayHidePosition = True;
UIManager.UIAll.OverlayHideEndMapLadderRecap = True;
UIManager.UIAll.OverlayHideRoundScores = True;
***

***Match_Yield***
***
foreach (Event in PendingEvents) {
	if (Event.Type == CTmModeEvent::EType::OnPlayerAdded) {
		ChaseUI::SetVisibility(False, Event.Player);
		ChaseTuto::InitializePlayer(Event.Player);
		TeamSelectionUI::InitializePlayer(Event.Player);
		MedalUI::InitializePlayer(Event.Player);
		LadderUI::InitializePlayer(Event.Player);
		FinishTimeoutUI::InitializePlayer(Event.Player);
		RelayUI::InitializePlayer(Event.Player);
		CheckpointRankingUI::InitializePlayer(Event.Player);
	}
}

TeamSelectionUI::Yield();
TeamConfirmUI::Yield();
***

***Match_StartServer***
***
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Initialize mode
UseClans = False;
IndependantLaps = False;
RespawnBehaviour::Set(CTmMode::ETMRespawnBehaviour::Normal);
WarmUp::SetAvailability(True);
Pause::SetAvailability(False);
ChannelProgression::Enable(S_IsChannelServer);

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Force round/lap synchro of the cars
// In time attack mode the synchro of the car is less strict, 
// creating a small delay between the real position of the player 
// and the position of his car on the screen
UiRounds = True;
UiLaps = True;

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Initialize UI
UIManager.UIAll.TeamLabelsVisibility = CUIConfig::ELabelsVisibility::Never;
UIManager.UIAll.TeamLabelsShowNames = CUIConfig::EVisibility::ForcedVisible;
UIManager.UIAll.OpposingTeamLabelsVisibility = CUIConfig::ELabelsVisibility::Never;
UIManager.UIAll.OpposingTeamLabelsShowNames = CUIConfig::EVisibility::ForcedVisible;
// Force 3d markers display
UIManager.UIAll.LabelsVisibility = CUIConfig::EHudVisibility::Everything;
***

***Match_InitMap***
***
declare Integer Map_PrevTimeLimit; ///< Previous time limit of the map
declare Integer Map_StartTime; ///< Start time of the map
declare Integer Map_ScreenWinnersDuration; ///< Duration of the winners display at the end of the map
declare Integer Map_ScreenScoresTableDuration; ///< Duration of the scores table display at the end of the map
declare Integer Map_ScreenStayAsTeamDuration; ///< Duration of the stay as team display at the end of the map
declare Text Map_CheckpointMarkersXML; ///< The xml of the markers attached to the checkpoints and finishes
declare Ident[] Map_LobbyPlayers; ///< Id of the Players currently in the lobby
declare Integer Map_ClanPlayersNb; ///< Number of players in a clan
declare Ident Map_FinishBlockId; ///< Id of the finish block to use as default finish
***

***Match_BeforeIntroSequence***
***
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Reset the medal count
foreach (Score in Scores) {
	ResetMedals(Score);
}
foreach (Player in AllPlayers) {
	MedalUI::CancelMedalCounter(Player);
}
***

***Match_StartMap***
***
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Add bot when necessary
Users_SetNbFakeUsers(C_BotsNb, 0);

Map_ClanPlayersNb = ML::Max(2, S_TeamPlayersNb);
TeamSelectionUI::SetLobbyPlayers(Map_LobbyPlayers);

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Warm up
declare WarmUpDuration = S_WarmUpDuration * 1000;
MB_WarmUp(S_WarmUpNb, WarmUpDuration);

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Initialize race
Map_StartTime = Now + 3000;
Map_PrevTimeLimit = S_TimeLimit;
SetTimeLimit(Map_StartTime, S_TimeLimit);
SetLapsNb(S_ForceLapsNb, Map_StartTime, S_TimeLimit);
foreach (Player in AllPlayers) {
	ChaseUI::SetPenalties(0, Player);
	ChaseUI::SetFinishTime(-1, Player);
	MedalUI::CancelMedalCounter(Player);
	RelayUI::CancelFailWarning(Player);
	TeamSelectionUI::Enable(False, Player);
	ChaseTuto::IsInLobby(False, Player);
	declare UI <=> UIManager.GetUI(Player);
	if (UI != Null) {
		UI.UIStatus = CUIConfig::EUIStatus::None;
		UI.SpectatorForceCameraType = -1;
	}
	ResetMarkers(Player);
	declare ChaseAttack_PrevSpectatingClan for Player = -1;
	ChaseAttack_PrevSpectatingClan = -1;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Initialize scores
foreach (Score in Scores) {
	declare Chase_RoundsPerformance for Score = Real[];
	Chase_RoundsPerformance = Real[];
	InitScore(Score);
	SetPlayerBestCheckpointTimes(Integer[Ident][Integer], Score);
	SetPlayerBestCheckpointPoints(Integer[Ident][Integer], Score);
	ResetStats(Score);
}
declare Clans = Clans::GetClans();
foreach (Clan => PlayerIds in Clans) {
	Clans::ResetBestTime(Clan);
	Clans::ResetRelays(Clan);
}
if (Hud != Null && Hud.ScoresTable != Null) {
	Hud.ScoresTable.ResetCustomColumns();
}
UpdateRanking();

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Initialize checkpoints
declare I = 0;
foreach (Pos in MapCheckpointPos) {
	Map_CheckpointMarkersXML ^= """<marker pos="{{{Pos.X}}} {{{Pos.Y+3}}} {{{Pos.Z}}}" visibility="WhenVisible" distmax="{{{C_CheckpointMarkerDistance}}}" manialinkframeid="marker-checkpoint-{{{I}}}" />""";
	I += 1;
}
foreach (Pos in MapFinishLinePos) {
	Map_CheckpointMarkersXML ^= """<marker pos="{{{Pos.X}}} {{{Pos.Y+3}}} {{{Pos.Z}}}" visibility="WhenVisible" distmax="{{{C_CheckpointMarkerDistance}}}" manialinkframeid="marker-checkpoint-{{{I}}}" />""";
	I += 1;
}
declare netwrite Integer Net_Chase_NextPlayerUpdate for Teams[0];
declare netwrite Text[Integer] Net_Chase_NextPlayer for Teams[0];
declare netwrite Integer[Integer] Net_Chase_NextCheckpoint for Teams[0];
declare netwrite Integer[Integer] Net_Chase_RelayTime for Teams[0];
Net_Chase_NextPlayer.clear();
Net_Chase_NextCheckpoint.clear();
Net_Chase_RelayTime.clear();
Net_Chase_NextPlayerUpdate = Now;
ChaseUI::ResetRelayPlayers();

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Initialize race
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
ChaseTuto::Enable(True);
TeamUI::Enable(True);
RestartUI::Enable(True);
***

***Match_PlayLoop***
***
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Manage switching between player and spectator
declare Integer[] MarkersClansToUpdate;
foreach (Spectator in Spectators) {
	// Player switch to spectator
	declare ChaseAttack_IsPlayer for Spectator = True;
	if (ChaseAttack_IsPlayer) {
		ChaseAttack_IsPlayer = False;
		declare UI <=> UIManager.GetUI(Spectator);
		if (UI != Null) {
			UI.UIStatus = CUIConfig::EUIStatus::None;
			UI.SpectatorForceCameraType = -1;
		}
	}
	// Spectated clan
	declare ChaseAttack_PrevSpectatingClan for Spectator = -1;
	declare SpectatingClan = ChaseUI::GetSpectatingClan(Spectator);
	if (ChaseAttack_PrevSpectatingClan != SpectatingClan) {
		ChaseAttack_PrevSpectatingClan = SpectatingClan;
		UpdateMarkers(Map_CheckpointMarkersXML, Clans::GetNextCheckpointPlayerIds(), SpectatingClan, Spectator);
	}
}
foreach (Player in Players) {
	// Spectator switch to player
	declare ChaseAttack_IsPlayer for Player = True;
	declare ChaseAttack_PrevSpectatingClan for Player = -1;
	if (!ChaseAttack_IsPlayer) {
		ChaseAttack_IsPlayer = True;
		ChaseAttack_PrevSpectatingClan = -1;
	}
}
	
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Manage lobby players
declare Ident[] RemoveFromLobby;
foreach (PlayerId in Map_LobbyPlayers) {
	// Player left the server or switch to spectator
	if (!Players.existskey(PlayerId)) {
		if (!RemoveFromLobby.exists(PlayerId)) {
			RemoveFromLobby.add(PlayerId);
		}
	}
	// Player is in a clan
	else if (Clans::GetPlayerClan(PlayerId) != Const::C_NoClan) {
		if (!RemoveFromLobby.exists(PlayerId)) {
			RemoveFromLobby.add(PlayerId);
		}
	}
}
if (RemoveFromLobby.count > 0) {
	Map_LobbyPlayers = RemovePlayersFromLobby(Map_LobbyPlayers, RemoveFromLobby);
	RemoveFromLobby.clear(); //< The array is re-used below
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Manage lobby
declare Ident[] PlayersSearchingTeammates;
declare Ident[][] PlayersWithTeammates;
// Players that already have a teammate and cannot be matched with someone else
// This array contains the same players than PlayersWithTeammates but with only 
// one dimension to speed up look up
declare Ident[] PlayersMatched; 
foreach (Player in Players) {
	declare PlayerClan = Clans::GetPlayerClan(Player.Id);
	// Add player without clan to the lobby
	if (
		PlayerClan == Const::C_NoClan &&
		!Map_LobbyPlayers.exists(Player.Id)
	) {
		Map_LobbyPlayers = AddPlayerToLobby(Map_LobbyPlayers, Player);
	}
	
	// Check if the player want to join a clan
	if (
		PlayerClan == Const::C_NoClan &&
		Map_LobbyPlayers.exists(Player.Id) &&
		!PlayersMatched.exists(Player.Id)
	) {
		// Another player accepted this player invitation
		declare ValidatedTeammate = TeamSelectionUI::GetValidatedTeammate(Player);
		if (
			ValidatedTeammate != Null &&
			Clans::GetPlayerClan(ValidatedTeammate.Id) == Const::C_NoClan &&
			Map_LobbyPlayers.exists(ValidatedTeammate.Id) &&
			!PlayersMatched.exists(ValidatedTeammate.Id)
		) {
			PlayersWithTeammates.add([Player.Id, ValidatedTeammate.Id]);
			PlayersMatched.add(Player.Id);
			PlayersMatched.add(ValidatedTeammate.Id);
			declare Removed = False;
			Removed = PlayersSearchingTeammates.remove(Player.Id);
			Removed = PlayersSearchingTeammates.remove(ValidatedTeammate.Id);
		} else {
			// This player invited a player that is searching for a random teammate
			declare RequestedTeammate = TeamSelectionUI::GetRequestedTeammate(Player);
			if (
				RequestedTeammate != Null &&
				TeamSelectionUI::HasRandomTeammate(RequestedTeammate) &&
				Clans::GetPlayerClan(RequestedTeammate.Id) == Const::C_NoClan &&
				Map_LobbyPlayers.exists(RequestedTeammate.Id) &&
				!PlayersMatched.exists(RequestedTeammate.Id)
			) {
				PlayersWithTeammates.add([Player.Id, RequestedTeammate.Id]);
				PlayersMatched.add(Player.Id);
				PlayersMatched.add(RequestedTeammate.Id);
				declare Removed = False;
				Removed = PlayersSearchingTeammates.remove(Player.Id);
				Removed = PlayersSearchingTeammates.remove(RequestedTeammate.Id);
			} else {
				// This player is searching for a random teammate
				if (
					TeamSelectionUI::HasRandomTeammate(Player) &&
					!PlayersSearchingTeammates.exists(Player.Id)
				) {
					PlayersSearchingTeammates.add(Player.Id);
				}
			}
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Associate players searching for a random teammate
declare SomethingWrongHappened = False;
while (!SomethingWrongHappened && PlayersSearchingTeammates.count >= Map_ClanPlayersNb) {
	declare PlayerIds = Ident[];
	for (I, 1, Map_ClanPlayersNb) {
		declare PlayerId = PlayersSearchingTeammates[0];
		if (!PlayerIds.exists(PlayerId)) {
			PlayerIds.add(PlayerId);
		}
		declare Removed = PlayersSearchingTeammates.removekey(0);
		if (!Removed) SomethingWrongHappened = True;
	}
	if (!SomethingWrongHappened && PlayerIds.count == Map_ClanPlayersNb) {
		PlayersWithTeammates.add(PlayerIds);
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Send the players in their new clan
foreach (PlayerIds in PlayersWithTeammates) {
	declare NewClan = Clans::Create();
	declare CreatedClan = Clans::GetClan(NewClan);
	if (CreatedClan.count == 0) {
		foreach (PlayerId in PlayerIds) {
			Clans::Join(NewClan, PlayerId);
			if (!RemoveFromLobby.exists(PlayerId)) {
				RemoveFromLobby.add(PlayerId);
			}
			if (AllPlayers.existskey(PlayerId)) {
				AddPlayerToClan(NewClan, AllPlayers[PlayerId]);
			}
		}
	}
}
if (RemoveFromLobby.count > 0) {
	Map_LobbyPlayers = RemovePlayersFromLobby(Map_LobbyPlayers, RemoveFromLobby);
	RemoveFromLobby.clear();
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Players want to leave their clan
// Note : When two players press the leave team button
// at the same time, we can receive the input of
// the players at a different frame because of the ping.
// This means that a player returned by GetPlayersWantingToLeaveTeam()
// might already have left their team because of the input
// of their teammate that the server received first.
declare PlayersWantingToLeaveTeam = TeamSelectionUI::GetPlayersWantingToLeaveTeam();
foreach (Player in PlayersWantingToLeaveTeam) {
	declare Clan = Clans::GetPlayerClan(Player.Id);
	Clans::Leave(Player.Id);
	declare Stats = Integer[Integer];
	if (Clan != Const::C_NoClan) {
		Stats = Clans::GetStats(Clan);
	}
	RemovePlayersFromClan(Clan, [Player.Id], Stats);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Not enough players in the clan
declare ClansPlayerIds = Clans::GetClans();
foreach (Clan => ClanPlayerIds in ClansPlayerIds) {
	foreach (PlayerId in ClanPlayerIds) {
		if (!Players.existskey(PlayerId)) {
			Clans::Leave(PlayerId);
			RemovePlayersFromClan(Clan, [PlayerId], Clans::GetStats(Clan));
		}
	}
	declare NewClanPlayerIds = Clans::GetClan(Clan);
	if (NewClanPlayerIds.count < Map_ClanPlayersNb) {
		declare ClanStats = Clans::GetStats(Clan);
		Clans::Destroy(Clan);
		RemovePlayersFromClan(Clan, NewClanPlayerIds, ClanStats);
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Manage events
foreach (Event in PendingEvents) {
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
	// GiveUp
	if (Event.Type == CTmModeEvent::EType::GiveUp) {
		if (Event.Player != Null) {
			declare PlayerCurrentClan = Clans::GetPlayerClan(Event.Player.Id);
			
			if (PlayerCurrentClan != Const::C_NoClan) {
				// The player is in the 3,2,1,GO countdown
				if (Event.Player.RaceStartTime > Now) {
					Events::Invalid(Event);
				}
				// If the player is watching the race outro, skip it
				else if (TM::IsWatchingOutro(Event.Player)) {
					if (Clans::GetRespawnTime(PlayerCurrentClan) != Const::C_NoRespawnTime) {
						Events::Invalid(Event);
					} else {
						declare NoClanPlayersIsRacing = True;
						declare ClanPlayerIds = Clans::GetClan(PlayerCurrentClan);
						foreach (PlayerId in ClanPlayerIds) {
							if (Players.existskey(PlayerId) && TM::IsRacing(Players[PlayerId])) {
								NoClanPlayersIsRacing = False;
								break;
							}
						}
						if (NoClanPlayersIsRacing) {
							TM::WaitRace(Event.Player);
							Events::Valid(Event);
						} else {
							Events::Invalid(Event);
						}
					}
				}
				else if (C_UseCollegialRestart) {
					SetPlayerWantsToRestart(True, Event.Player);
					declare Restart = True;
					declare ClanPlayerIds = Clans::GetClan(PlayerCurrentClan);
					foreach (PlayerId in ClanPlayerIds) {
						if (Players.existskey(PlayerId)) {
							if (!PlayerWantsToRestart(Players[PlayerId])) {
								Restart = False;
								break;
							}
						}
					}
					if (Restart) {
						Clans::SetRespawnTime(PlayerCurrentClan, Now);
					} else {
						declare CurrentRespawnTime = Clans::GetRespawnTime(PlayerCurrentClan);
						declare NewRespawnTime = Now + C_RestartDelay;
						if (
							CurrentRespawnTime == Const::C_NoRespawnTime ||
							CurrentRespawnTime > NewRespawnTime
						) {
							Clans::SetRespawnTime(PlayerCurrentClan, NewRespawnTime);
							foreach (PlayerId in ClanPlayerIds) {
								if (Players.existskey(PlayerId)) {
									RestartUI::SetRestart(NewRespawnTime, Event.Player, Players[PlayerId]);
								}
							}
						}
					}
					Events::Invalid(Event);
				} else {
					if (Clans::GetRespawnTime(PlayerCurrentClan) == Const::C_NoRespawnTime) {
						Clans::SetRespawnTime(PlayerCurrentClan, Now);
					}
					
					Events::Valid(Event);
				}
			}
			// Player is in lobby
			else {
				TM::WaitRace(Event.Player);
				Events::Valid(Event);
			}
		}
	} else {
		declare Processed = Events::Valid(Event);
		if (Processed) {
			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
			// Waypoint
			if (Event.Type == CTmModeEvent::EType::WayPoint) {
				// Player is in Chase
				if (Event.Player != Null) {
					declare PlayerCurrentClan = Clans::GetPlayerClan(Event.Player.Id);
					if (PlayerCurrentClan != Const::C_NoClan) {
						// The event we just receive for this player
						// can come from its previous race.
						// eg : the mode decide to respawn the players
						// of a clan because of a collegial restart
						// or a relay failed. But before the player
						// receive the order from the server (ping) they
						// manage to cross a checkpoint.
						// The server has already respawned both players
						// but will then receive the checkpoint event.
						// If it is the case we must ignore this event.
						if (!C_WaypointEventLagProtection || IsValidRaceStartTime(Event.Player)) {
							declare IsEndRace = Event.IsEndRace;
							declare BlockId = Event.BlockId;
							if (IsEndRace) {
								TM::EndRace(Event.Player);
								// Override multiple finishes block id by a main one
								// to avoid failed relay when two players choose a
								// different finish.
								if (Map_FinishBlockId == NullId) {
									Map_FinishBlockId = Event.BlockId;
								}
								BlockId = Map_FinishBlockId;
							}
							
							// Delay event for chase players
							Clans::AddWaypointEvent(
								PlayerCurrentClan, Event.RaceTime, Event.Player.Id, BlockId, IsEndRace, Event.CheckpointInRace, Event.Player.CurrentNbLaps, Event.Speed
							);
						} else {
							declare CurRaceTime = -1;
							if (Event.Player.CurRace != Null) CurRaceTime = Event.Player.CurRace.Time;
							Log::Log("""[ChaseAttack] We received an event from a previous race, ignore it > {{{Event.Player.User.Login}}} {{{Event.Player.Id}}} | CurRaceTime : {{{CurRaceTime}}} | Event.RaceTime : {{{Event.RaceTime}}}""");
						}
					}
					// Player is in lobby
					else {
						if (Event.IsEndRace) {
							TM::EndRace(Event.Player);
						}
					}
				}
			}
			// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
			// Start line
			else if (Event.Type == CTmModeEvent::EType::StartLine) {
				if (C_WaypointEventLagProtection) {
					ValidRaceStartTime(Event.Player);
				}
			}
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Process waypoint events
ClansPlayerIds = Clans::GetClans();
foreach (Clan => ClanPlayerIds in ClansPlayerIds) {
	declare EventIdsToProcess = Clans::GetWaypointEventsToProcess(Clan, S_WaypointEventDelay);
	foreach (EventId in EventIdsToProcess) {
		declare EventRaceTime = Clans::GetWaypointEventRaceTime(Clan, EventId);
		declare EventPlayerId = Clans::GetWaypointEventPlayerId(Clan, EventId);
		declare EventBlockId = Clans::GetWaypointEventBlockId(Clan, EventId);
		declare EventIsEndRace = Clans::GetWaypointEventIsEndRace(Clan, EventId);
		declare EventCheckpointInRace = Clans::GetWaypointEventCheckpointInRace(Clan, EventId);
		declare EventCurrentNbLaps = Clans::GetWaypointEventCurrentNbLaps(Clan, EventId);
		declare EventSpeed = Clans::GetWaypointEventSpeed(Clan, EventId);
		
		Log::Log("""[ChaseAttack] Waypoint event > RaceTime : {{{EventRaceTime}}} | PlayerId : {{{EventPlayerId}}} | BlockId : {{{EventBlockId}}} | IsEndRace : {{{EventIsEndRace}}} | CheckpointInRace : {{{EventCheckpointInRace}}} | EventCurrentNbLaps : {{{EventCurrentNbLaps}}} | EventSpeed : {{{EventSpeed}}}""");
		
		if (ClanPlayerIds.exists(EventPlayerId) && AllPlayers.existskey(EventPlayerId)) {
			declare EventPlayer <=> AllPlayers[EventPlayerId];
			declare NewCheckpoint = Clans::UpdateCheckpointsProgress(Clan, EventCurrentNbLaps, EventBlockId, EventPlayerId);
			
			// New checkpoint
			if (NewCheckpoint) {
				
				declare RelaySuccess = False;
				
				// If it's not the first checkpoint
				declare ClanAlreadyCrossedFirstCheckpoint = Clans::HasCrossedFirstCheckpoint(Clan);
				if (ClanAlreadyCrossedFirstCheckpoint) {
					// Get the players that already crossed the previous checkpoint and the player that must cross the next checkpoint
					declare PreviousCheckpointPlayerIds = Clans::GetCurrentCheckpointPlayerIds(Clan);
					declare NextCheckpointPlayerId = Clans::GetNextCheckpointPlayerId(Clan);
					
					// Relay successful
					if (
						PreviousCheckpointPlayerIds.count >= Map_ClanPlayersNb &&
						NextCheckpointPlayerId != NullId &&
						NextCheckpointPlayerId == EventPlayerId
					) {
						RelaySuccess = True;
					}
					// Relay failed 
					else {
						RelaySuccess = False;
						
						Log::Log("""[ChaseAttack] Relay failed for clan {{{Clan}}} > PreviousCheckpointPlayerIds : {{{PreviousCheckpointPlayerIds}}} | Map_ClanPlayersNb : {{{Map_ClanPlayersNb}}} | NextCheckpointPlayerId : {{{NextCheckpointPlayerId}}} | EventPlayerId : {{{EventPlayerId}}} | event properties - RaceTime : {{{EventRaceTime}}} | PlayerId : {{{EventPlayerId}}} | BlockId : {{{EventBlockId}}} | IsEndRace : {{{EventIsEndRace}}} | CheckpointInRace : {{{EventCheckpointInRace}}} | EventCurrentNbLaps : {{{EventCurrentNbLaps}}} | EventSpeed : {{{EventSpeed}}}""");
						
						// Update penalties
						Clans::IncrementPenalties(Clan);
						declare PenaltiesNb = Clans::GetPenalties(Clan);
						
						// Invalid the race
						Clans::SetValidRace(Clan, False);
						foreach (ClanPlayerId in ClanPlayerIds) {
							if (AllPlayers.existskey(ClanPlayerId)) {
								declare ClanPlayer <=> AllPlayers[ClanPlayerId];
								ChaseUI::SetPenalties(PenaltiesNb, ClanPlayer);
								
								declare UI <=> UIManager.GetUI(ClanPlayer);
								if (UI != Null) {
									UI.UIStatus = CUIConfig::EUIStatus::Warning;
								}
								
								declare DisplayWaitForTeammates = (S_DisplayWarning && EventPlayerId == ClanPlayerId);
								RelayUI::PopFailWarning(C_RelayFailWarningDuration, DisplayWaitForTeammates, ClanPlayer);
							}
						}
						
						if (C_RespawnAfterFailedRelay) {
							Clans::SetRespawnTime(Clan, Now);
						}
					}
					
					ComputeCheckpointGrade(EventPlayer, RelaySuccess, RelaySuccess, 0);
					Clans::UpdateRelays(Clan, RelaySuccess);
				}
				
				Clans::SetCurrentCheckpoint(
					Clan, EventCurrentNbLaps, EventBlockId, EventPlayerId, RelaySuccess, EventRaceTime, EventSpeed, EventPlayer.Score.Id, 0
				);
				
				declare NewRelayStartTimes = SetNextCheckpointPlayer(
					Null, Clan, C_NoNameCheckpoint, EventCheckpointInRace + 1, EventRaceTime, Clans::GetRelayStartTimes()
				);
				Clans::SetRelayStartTimes(NewRelayStartTimes);
				Clans::ResetNextCheckpointPlayerId(Clan);
				if (!MarkersClansToUpdate.exists(Clan)) {
					MarkersClansToUpdate.add(Clan);
				}
				
				// Save the checkpoint time and score
				Clans::UpdateCheckpointTimes(Clan, EventCurrentNbLaps, EventBlockId, EventRaceTime);
				AddCheckpointsPoints(EventCurrentNbLaps, EventBlockId, GetRacePoints(EventPlayer.Score), EventPlayer.Score);
				
				// This is the finish
				if (EventIsEndRace) {
					// Start finish countdown
					declare Timeout = GetFinishTimeout(S_FinishTimeout);
					if (Clans::RaceIsValid(Clan)) {
						Clans::SetRespawnTime(Clan, Timeout);
					}
					foreach (ClanPlayerId in ClanPlayerIds) {
						if (AllPlayers.existskey(ClanPlayerId)) {
							declare ClanPlayer <=> AllPlayers[ClanPlayerId];
							FinishTimeoutUI::SetTimeout(Timeout, ClanPlayer);
							RestartUI::ResetRestart(ClanPlayer);
						}
					}
					
					// Compute new time
					declare TimePenalty = 0;
					if (S_FailedRelayPenalty > 0) {
						TimePenalty = Clans::GetPenalties(Clan) * S_FailedRelayPenalty * 1000;
					}
					Clans::UpdateFinishTime(Clan, EventPlayerId, EventRaceTime + TimePenalty);
					
					Log::Log("""[ChaseAttack] Clan {{{Clan}}} finish > NewTime : {{{Clans::GetFinishTimes(Clan)}}} | RaceTime : {{{EventRaceTime}}} | Penalties : {{{Clans::GetPenalties(Clan)}}} | S_FailedRelayPenalty : {{{S_FailedRelayPenalty}}}""");
				}
			}
			// Existing checkpoint
			else if (Clans::IsCurrentCheckpoint(Clan, EventCurrentNbLaps, EventBlockId)) {
				Clans::UpdateCurrentCheckpoint(Clan, EventPlayerId);
				
				// Update checkpoint time with the time of the last player to cross it
				Clans::UpdateCheckpointTimes(Clan, EventCurrentNbLaps, EventBlockId, EventRaceTime);
				
				// Set checkpoints score
				declare RelaySuccess = Clans::CurrentCheckpointRelayIsValid(Clan);
				declare CheckpointScore = 0;
				if (RelaySuccess) {
					CheckpointScore = GetCheckpointScore(
						Clans::GetCurrentCheckpointLeaderTime(Clan),
						Clans::GetCurrentCheckpointLeaderSpeed(Clan),
						EventRaceTime,
						EventSpeed
					);
				}
				Clans::UpdateCurrentCheckpointScores(Clan, EventPlayer.Score.Id, CheckpointScore);
				ComputeCheckpointGrade(EventPlayer, RelaySuccess, False, CheckpointScore);
				AddRacePoints(CheckpointScore, EventPlayer.Score);
				AddCheckpointsPoints(EventCurrentNbLaps, EventBlockId, GetRacePoints(EventPlayer.Score), EventPlayer.Score);
				
				// We take the finish time of the last player of the team
				if (EventIsEndRace) {
					declare TimePenalty = 0;
					if (S_FailedRelayPenalty > 0) {
						TimePenalty = Clans::GetPenalties(Clan) * S_FailedRelayPenalty * 1000;
					}
					Clans::UpdateFinishTime(Clan, EventPlayerId, EventRaceTime + TimePenalty);
				}
				
				// Find the relay player
				declare NextCheckpointPlayerId = Clans::GetNextCheckpointPlayerId(Clan);
				declare CurrentCheckpointPlayerIds = Clans::GetCurrentCheckpointPlayerIds(Clan);
				if (CurrentCheckpointPlayerIds.count >= Map_ClanPlayersNb && NextCheckpointPlayerId == NullId) {
					declare ClansRelayStartTimes = Clans::GetRelayStartTimes();
					if (ClansRelayStartTimes.existskey(Clan)) {
						declare RelayDuration = EventRaceTime - ClansRelayStartTimes[Clan];
						Clans::UpdateRelayDuration(Clan, RelayDuration);
					}
					declare NewRelayStartTimes = SetNextCheckpointPlayer(
						EventPlayer.User, Clan, EventPlayer.User.Name, EventCheckpointInRace + 1, EventRaceTime, ClansRelayStartTimes
					);
					Clans::SetRelayStartTimes(NewRelayStartTimes);
					Clans::SetNextCheckpointPlayerId(Clan, EventPlayerId);
					Chase::ComputeRelayScore(
						Clans::GetCurrentCheckpointScores(), Clans::GetCurrentCheckpointValidRelays(), Clan, EventCurrentNbLaps, EventBlockId
					);
					if (!MarkersClansToUpdate.exists(Clan)) {
						MarkersClansToUpdate.add(Clan);
					}
					
					// Display the checkpoint time diff when the last player crosses the checkpoint
					foreach (ClanPlayerId in ClanPlayerIds) {
						if (AllPlayers.existskey(ClanPlayerId)) {
							declare ClanPlayer <=> AllPlayers[ClanPlayerId];
							declare BestCheckpointTime = -1;
							declare BestCheckpointTimes = GetPlayerBestCheckpointTimes(ClanPlayer.Score);
							if (BestCheckpointTimes.existskey(EventCurrentNbLaps) && BestCheckpointTimes[EventCurrentNbLaps].existskey(EventBlockId)) {
								BestCheckpointTime = BestCheckpointTimes[EventCurrentNbLaps][EventBlockId];
							}
							declare CurrentCheckpointPoints = 0;
							declare CurrentCheckpointsPoints = GetCheckpointsPoints(ClanPlayer.Score);
							if (CurrentCheckpointsPoints.existskey(EventCurrentNbLaps) && CurrentCheckpointsPoints[EventCurrentNbLaps].existskey(EventBlockId)) {
								CurrentCheckpointPoints = CurrentCheckpointsPoints[EventCurrentNbLaps][EventBlockId];
							}
							declare CheckpointRank = UpdateCheckpointRanking(ClanPlayer, EventCurrentNbLaps, EventBlockId, EventRaceTime, CurrentCheckpointPoints);
							CheckpointTimeUI::PopCheckpointTime(C_CheckpointTimeDisplayDuration, BestCheckpointTime, EventRaceTime, CheckpointRank, ClanPlayer);
						}
					}
				} else {
					ChaseUI::UpdateNextCheckpointPlayer();
				}
			}
		}
	}
	Clans::RemoveWaypointEvents(Clan, EventIdsToProcess);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Spawn players
declare CTmPlayer[][Integer] PlayersToSpawn;
foreach (Player in Players) {
	if (TM::IsWaiting(Player)) {
		declare PlayerCurrentClan = Clans::GetPlayerClan(Player.Id);
		declare ClanIsReady = True;
		
		if (PlayerCurrentClan != Const::C_NoClan) {
			// A clan is ready if there's no respawn scheduled
			ClanIsReady = (Clans::GetRespawnTime(PlayerCurrentClan) == Const::C_NoRespawnTime);
			
			// A clan is ready if all players of the team are ready
			if (ClanIsReady) {
				declare ClanPlayerIds = Clans::GetClan(PlayerCurrentClan);
				foreach (PlayerId in ClanPlayerIds) {
					if (PlayerId != Player.Id) {
						if (Players.existskey(PlayerId)) {
							if (!TM::IsWaiting(Players[PlayerId])) {
								ClanIsReady = False;
								break;
							}
						} else {
							ClanIsReady = False;
							break;
						}
					}
				}
			}
		}
		
		if (
			(PlayerCurrentClan != Const::C_NoClan && ClanIsReady) || 
			(C_SpawnLobbyPlayers && PlayerCurrentClan == Const::C_NoClan && Map_LobbyPlayers.exists(Player.Id))
		) {
			if (!PlayersToSpawn.existskey(PlayerCurrentClan)) {
				PlayersToSpawn[PlayerCurrentClan] = CTmPlayer[];
			}
			PlayersToSpawn[PlayerCurrentClan].add(Player);
		}
	}
}
foreach (Clan => ClanPlayers in PlayersToSpawn) {
	if (Clan == Const::C_NoClan || ClanPlayers.count >= Map_ClanPlayersNb) {
		foreach (Player in ClanPlayers) {
			CheckpointTimeUI::ResetCheckpointTime(Player);
			CheckpointRankingUI::ResetCheckpointRanking(Player);
			FinishTimeoutUI::SetTimeout(-1, Player);
			RestartUI::ResetRestart(Player);
			MedalUI::CancelRaceMedal(Player);
			// Race
			if (Clan != Const::C_NoClan) {
				MedalUI::PopMedalCounter(2500, Const::C_Medal_None, GetMedals(Player.Score), Player);
				ChaseUI::SetVisibility(True, Player);
				CheckpointRankingUI::Enable(True, Player);
			} 
			// Lobby
			else {
				MedalUI::PopMedalCounter(CutOffTimeLimit - Now, Const::C_Medal_None, GetMedals(Player.Score), Player);
				ChaseUI::SetVisibility(False, Player);
				CheckpointRankingUI::Enable(False, Player);
			}
			declare UI <=> UIManager.GetUI(Player);
			if (UI != Null) {
				if (Clan != Const::C_NoClan) {
					UI.UIStatus = CUIConfig::EUIStatus::None;
					UI.SpectatorForceCameraType = 2;
				} else {
					UI.UIStatus = CUIConfig::EUIStatus::Warning;
					UI.SpectatorForceCameraType = -1;
				}
			}
			ResetRacePoints(Player.Score);
			ResetCheckpointsPoints(Player.Score);
			SetPlayerWantsToRestart(False, Player);
			TM::StartRace(Player);
			// Make sure that the RaceTime is reset now and not at the end of the start countdown
			Player.CurRace = Null;
			if (C_WaypointEventLagProtection) {
				InvalidRaceStartTime(Player);
			}
		}
		if (Clan != Const::C_NoClan) {
			InitializeRace(Clan);
		}
		if (!MarkersClansToUpdate.exists(Clan)) {
			MarkersClansToUpdate.add(Clan);
		}
		ChaseUI::UpdateNextCheckpointPlayer();
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Manage clans respawn time
declare ClansToRespawn = Integer[];
declare ClansRespawnTime = Clans::GetRespawnTimes();
foreach (Clan => TimeLimit in ClansRespawnTime) {
	// Time limit reached
	if (Now >= TimeLimit) {
		ClansToRespawn.add(Clan);
		declare ClanPlayerIds = Clans::GetClan(Clan);
		foreach (ClanPlayerId in ClanPlayerIds) {
			if (AllPlayers.existskey(ClanPlayerId)) {
				declare ClanPlayer <=> AllPlayers[ClanPlayerId];
				FinishTimeoutUI::SetTimeout(-1, ClanPlayer);
				if (Clans::OnePlayerFinished(Clan)) FinishTimeoutUI::PopFinishFailed(3000, ClanPlayer);
			}
		}
	} else {
		// Check if all players finished
		if (Clans::OnePlayerFinished(Clan)) {
			declare EveryoneFinished = True;
			declare ClanPlayerIds = Clans::GetClan(Clan);
			declare ClanFinishTimes = Clans::GetFinishTimes(Clan);
			foreach (ClanPlayerId in ClanPlayerIds) {
				if (EveryoneFinished && !ClanFinishTimes.existskey(ClanPlayerId)) {
					EveryoneFinished = False;
					break;
				}
			}
			if (EveryoneFinished) {
				// Update clan best time
				if (Clans::RaceIsValid(Clan)) {
					// Validate race time of the last finisher
					declare ClanFinishTime = -1;
					foreach (Time in ClanFinishTimes) {
						if (Time > ClanFinishTime) ClanFinishTime = Time;
					}
					declare Medal = Const::C_Medal_None;
					if (ClanFinishTime >= 0) {
						if (ClanFinishTime <= Map.TMObjective_GoldTime) {
							Medal = Const::C_Medal_Gold;
						} else if (ClanFinishTime <= Map.TMObjective_SilverTime) {
							Medal = Const::C_Medal_Silver;
						} else if (ClanFinishTime <= Map.TMObjective_BronzeTime) {
							Medal = Const::C_Medal_Bronze;
						}
					}
					Log::Log("""[ChaseAttack] Every players of clan {{{Clan}}} finished. Time validated : {{{ClanFinishTime}}} | Medal : {{{Medal}}}""");
					
					declare ClanBestTime = Clans::GetBestTime(Clan);
					if (ClanBestTime < 0 || (ClanFinishTime >= 0 && ClanFinishTime < ClanBestTime)) {
						Clans::SetBestTime(Clan, ClanFinishTime);
					}
				
					foreach (ClanPlayerId in ClanPlayerIds) {
						if (AllPlayers.existskey(ClanPlayerId)) {
							declare ClanPlayer <=> AllPlayers[ClanPlayerId];
							
							declare PrevBestRaceTime = -1;
							if (ClanPlayer.Score.BestRace != Null) PrevBestRaceTime = ClanPlayer.Score.BestRace.Time;
							
							ClanPlayer.Score.TempResult.Time = ClanFinishTime;
							Scores::SetPlayerPrevRace(ClanPlayer.Score, ClanPlayer.Score.TempResult);
							declare Better = Scores::SetPlayerBestRaceIfBetter(ClanPlayer.Score, ClanPlayer.Score.TempResult, CTmResult::ETmRaceResultCriteria::Time);
							if (Better) {
								SetBestRacePoints(GetRacePoints(ClanPlayer.Score), ClanPlayer.Score);
								SetPlayerBestCheckpointTimes(Clans::GetCheckpointTimes(Clan), ClanPlayer.Score);
								SetPlayerBestCheckpointPoints(GetCheckpointsPoints(ClanPlayer.Score), ClanPlayer.Score);
								SetStats(Clan, Clans::GetClanScoreIds(Clan), ClanPlayer.Score);
							}
							if (S_FailedRelayPenalty > 0) {
								ChaseUI::SetFinishTime(ClanFinishTime, ClanPlayer);
							}
							
							declare TimeDiff = 0;
							if (PrevBestRaceTime >= 0 && ClanFinishTime >= 0) TimeDiff = ClanFinishTime - PrevBestRaceTime;
							GiveMedal(Medal, ClanPlayer.Score);
							MedalUI::PopRaceMedal(CutOffTimeLimit - Now, Medal, ClanFinishTime, TimeDiff, ClanPlayer);
							MedalUI::PopMedalCounter(CutOffTimeLimit - Now, Medal, GetMedals(ClanPlayer.Score), ClanPlayer);
							FinishTimeoutUI::SetTimeout(-1, ClanPlayer);
							CheckpointTimeUI::ResetCheckpointTime(ClanPlayer);
							CheckpointRankingUI::ResetCheckpointRanking(ClanPlayer);
						}
					}
				}
				// Update ranking
				UpdateRanking();
				
				ClansToRespawn.add(Clan);
			}
		}
	}
}
// Respawn clans
foreach (Clan in ClansToRespawn) {
	Clans::ResetRespawnTime(Clan);
	declare ClanPlayerIds = Clans::GetClan(Clan);
	foreach (ClanPlayerId in ClanPlayerIds) {
		if (AllPlayers.existskey(ClanPlayerId)) {
			// Unspawn player
			declare Player <=> AllPlayers[ClanPlayerId];
			if (TM::IsRacing(Player)) {
				TM::WaitRace(Player);
			}
		}
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Update markers
foreach (Clan in MarkersClansToUpdate) {
	UpdateMarkers(Map_CheckpointMarkersXML, Clans::GetNextCheckpointPlayerIds(), Clan);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Update the map duration setting
if (Map_PrevTimeLimit != S_TimeLimit) {
	Map_PrevTimeLimit = S_TimeLimit;
	SetTimeLimit(Map_StartTime, S_TimeLimit);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// End the map when time limit is reached
if (CutOffTimeLimit > 0 && Now >= CutOffTimeLimit) {
	MB_StopMatch();
}
***

***Match_EndMap***
***
// Ensure that we stop the match (after a vote for the next map, ...)
MB_StopMatch();

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Update UI
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
Message::CleanAllMessages();
foreach (Player in AllPlayers) {
	declare UI <=> UIManager.GetUI(Player);
	if (UI != Null) {
		UI.UIStatus = CUIConfig::EUIStatus::None;
		UI.SpectatorForceCameraType = -1;
	}
	TeamSelectionUI::Enable(False, Player);
	TeamSelectionUI::SetLobbyPlayers(Map_LobbyPlayers);
	ChaseTuto::IsInLobby(False, Player);
	MedalUI::CancelMedalCounter(Player);
	MedalUI::CancelRaceMedal(Player);
	RelayUI::CancelFailWarning(Player);
	CheckpointTimeUI::ResetCheckpointTime(Player);
	CheckpointRankingUI::ResetCheckpointRanking(Player);
	FinishTimeoutUI::SetTimeout(-1, Player);
	RestartUI::ResetRestart(Player);
	ResetMarkers(Player);
}
ChaseTuto::Enable(False);
TeamUI::Enable(False);
RestartUI::Enable(False);

CutOffTimeLimit = -1;
UpdateRanking();
Scores::SetDefaultLadderSort(Scores::C_Sort_MapPoints);
Scores::SetPlayerWinner(Scores::GetBestPlayer(Scores::C_Sort_MapPoints, Scores::C_Order_Ascending));

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Update UI
Scores::UnspawnLosers();
MB_Sleep(1000);
foreach (Player in Players) {
	Player.IsSpawned = True; //< Bug : spawn players to be able to clear the status message
	ChaseUI::SetVisibility(False, Player);
}
UIManager.UIAll.StatusMessage = "";
Message::CleanAllMessages();
MB_Sleep(250);
TM::WaitRaceAll();
***

***Match_BeforeCloseLadder***
***
// Setup the ladder specific to Chase
Ladder::SetResultsVersion(3);
***

***Match_BeforePodiumSequence***
***
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Find winners
declare BestPoints = -1;
declare CTmScore BestScore;
foreach (Score in Scores) {
	declare Points = Scores::GetPlayerMapPoints(Score);
	if (Points > 0 && Points > BestPoints) {
		BestScore <=> Score;
		BestPoints = Points;
	}
}
declare WinnerIds = Ident[Ident];
declare WinnersSorting = Integer[CTmScore];
declare Winners = CTmScore[];
declare Stats = Integer[Integer];
if (BestScore != Null) {
	declare ValidClan = GetStats_ValidClan(BestScore);
	if (ValidClan != Const::C_NoClan) {
		WinnerIds = GetStats_SavedTeammateScoreIds(BestScore);
		Stats = Clans::GetStats(ValidClan);
	} else {
		WinnerIds = GetStats_SavedTeammateScoreIds(BestScore);
		Stats = GetStats_SavedStats(BestScore);
	}
	foreach (ScoreId in WinnerIds) {
		if (Scores.existskey(ScoreId)) {
			declare Score <=> Scores[ScoreId];
			WinnersSorting[Score] = -Scores::GetPlayerMapPoints(Score);
		}
	}
	if (!WinnersSorting.existskey(BestScore)) {
		WinnersSorting[BestScore] = -Scores::GetPlayerMapPoints(BestScore);
	}
}
if (WinnersSorting.count > 0) {
	WinnersSorting = WinnersSorting.sort();
	foreach (Score => Points in WinnersSorting) {
		Winners.add(Score);
	}
	WinnersUI::SetWinners(Winners, Stats);
	WinnersUI::Enable(True);
} else {
	UIManager.UIAll.BigMessage = _("|Match|Draw");
}

Map_ScreenWinnersDuration = ML::NearestInteger((S_ChatTime * 1000) / 3.);
Map_ScreenScoresTableDuration = ML::NearestInteger((S_ChatTime * 1000) / 3.);
Map_ScreenStayAsTeamDuration = ML::NearestInteger((S_ChatTime * 1000) / 3.);
***

***Match_PodiumSequence***
***
declare PrevUISequence = UIManager.UIAll.UISequence;
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedHidden;
MB_Sleep(Map_ScreenWinnersDuration);
WinnersUI::Enable(False);
UIManager.UIAll.BigMessage = "";
LadderUI::Enable(True);
foreach (Player in Players) {
	LadderUI::PlayLadderProgression(Player);
	MedalUI::PopMedalCounter(Map_ScreenScoresTableDuration, GetMedals(Player.Score), Player);
}
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
MB_Sleep(Map_ScreenScoresTableDuration);
LadderUI::Enable(False);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
foreach (Player in AllPlayers) {
	declare UI <=> UIManager.GetUI(Player);
	if (UI != Null) {
		if (Clans::GetPlayerClan(Player.Id) == Const::C_NoClan) {
			UI.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
		} else {
			UI.ScoreTableVisibility = CUIConfig::EVisibility::ForcedHidden;
		}
	}
}
TeamConfirmUI::PopConfirmation(Map_ScreenStayAsTeamDuration);
MB_Sleep(Map_ScreenStayAsTeamDuration);
foreach (Player in AllPlayers) {
	declare UI <=> UIManager.GetUI(Player);
	if (UI != Null) {
		UI.ScoreTableVisibility = CUIConfig::EVisibility::None;
	}
}
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
UIManager.UIAll.UISequence = PrevUISequence;
***

***Match_AfterPodiumSequence***
***
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Special behavior for the current teammate system
// Disband clans where players do not have a teammate anymore
MB_Sleep(500);
declare ClansPlayerIds = Clans::GetClans();
foreach (Clan => ClanPlayerIds in ClansPlayerIds) {
	foreach (PlayerId in ClanPlayerIds) {
		if (AllPlayers.existskey(PlayerId)) {
			declare Player <=> AllPlayers[PlayerId];
			declare Teammate <=> TeamSelectionUI::GetValidatedTeammate(Player);
			if (Teammate == Null || !ClanPlayerIds.exists(Teammate.Id)) {
				Clans::Leave(PlayerId);
				RemovePlayersFromClan(Clan, [PlayerId], Clans::GetStats(Clan));
			}
		}
	}
	declare NewClanPlayerIds = Clans::GetClan(Clan);
	if (NewClanPlayerIds.count < Map_ClanPlayersNb) {
		declare ClanStats = Clans::GetStats(Clan);
		Clans::Destroy(Clan);
		RemovePlayersFromClan(Clan, NewClanPlayerIds, ClanStats);
	}
}
TeamConfirmUI::UnpopConfirmation();
***

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Functions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //

Void ValidRaceStartTime(CTmPlayer _Player) {
	if (_Player == Null) return;
	declare CA_ValidRaceStartTime for _Player = -1;
	CA_ValidRaceStartTime = _Player.RaceStartTime;
}

Void InvalidRaceStartTime(CTmPlayer _Player) {
	if (_Player == Null) return;
	declare CA_ValidRaceStartTime for _Player = -1;
	CA_ValidRaceStartTime = -1;
}

Boolean IsValidRaceStartTime(CTmPlayer _Player) {
	if (_Player == Null) return False;
	declare CA_ValidRaceStartTime for _Player = -1;
	return CA_ValidRaceStartTime == _Player.RaceStartTime;
}

Void SetPlayerWantsToRestart(Boolean _WantToRestart, CTmPlayer _Player) {
	if (_Player == Null) return;
	declare ChaseAttack_WantToRestart for _Player = False;
	ChaseAttack_WantToRestart = _WantToRestart;
}

Boolean PlayerWantsToRestart(CTmPlayer _Player) {
	if (_Player == Null) return False;
	declare ChaseAttack_WantToRestart for _Player = False;
	return ChaseAttack_WantToRestart;
}

Void SetStats(Integer _Clan, Integer[Integer] _Stats, Ident[Ident] _TeammateScoreIds, CTmScore _Score) {
	if (_Score == Null) return;
	
	declare CA_ValidClan for _Score = Const::C_NoClan;
	declare CA_SavedStats for _Score = Integer[Integer];
	declare CA_SaveTeammateScoreIds for _Score = Ident[Ident];
	
	if (_Clan != Const::C_NoClan) { //< Finish time improved with the clan
		CA_SavedStats.clear();
		declare TeammateScoreIds = _TeammateScoreIds;
		declare Removed = TeammateScoreIds.remove(_Score.Id);
		CA_SaveTeammateScoreIds = TeammateScoreIds;
	} else { //< Clan destroyed
		if (CA_ValidClan != Const::C_NoClan) { //< But finish time was improved previously with this clan
			CA_SavedStats = _Stats;
			// Update teammate stats in case they left the server
			foreach (TeammateScoreId in CA_SaveTeammateScoreIds) {
				if (Scores.existskey(TeammateScoreId)) {
					declare TeammateScore = Scores[TeammateScoreId];
					declare CA_ValidClan as TeammateValidClan for TeammateScore = Const::C_NoClan;
					if (CA_ValidClan == TeammateValidClan) {
						declare CA_SavedStats as TeammateSavedStats for TeammateScore = Integer[Integer];
						TeammateValidClan = _Clan;
						TeammateSavedStats = _Stats;
					}
				}
			}
		}
	}
	CA_ValidClan = _Clan;
		
	if (Hud != Null && Hud.ScoresTable != Null) {
		declare TeammateNames = "";
		foreach (ScoreId in CA_SaveTeammateScoreIds) {
			if (Scores.existskey(ScoreId)) {
				if (TeammateNames != "") TeammateNames ^= " + ";
				TeammateNames ^= "$<"^Scores[ScoreId].User.Name^"$>";
			}
		}
		if (TeammateNames == "") TeammateNames = "-";
		Hud.ScoresTable.SetColumnValue(_Score, "BestTeammate", TeammateNames);
	}
}
Void SetStats(Integer _Clan, Ident[Ident] _TeammateScoreIds, CTmScore _Score) {
	SetStats(_Clan, Integer[Integer], _TeammateScoreIds, _Score);
}
Void SetStats(Integer[Integer] _Stats, CTmScore _Score) {
	SetStats(Const::C_NoClan, _Stats, Ident[Ident], _Score);
}

Void ResetStats(CTmScore _Score) {
	declare CA_ValidClan for _Score = Const::C_NoClan;
	declare CA_SavedStats for _Score = Integer[Integer];
	declare CA_SaveTeammateScoreIds for _Score = Ident[Ident];
	CA_ValidClan = Const::C_NoClan;
	CA_SavedStats.clear();
	CA_SaveTeammateScoreIds.clear();
}

Integer GetStats_ValidClan(CTmScore _Score) {
	declare CA_ValidClan for _Score = Const::C_NoClan;
	return CA_ValidClan;
}
Integer[Integer] GetStats_SavedStats(CTmScore _Score) {
	declare CA_SavedStats for _Score = Integer[Integer];
	return CA_SavedStats;
}
Ident[Ident] GetStats_SavedTeammateScoreIds(CTmScore _Score) {
	declare CA_SaveTeammateScoreIds for _Score = Ident[Ident];
	return CA_SaveTeammateScoreIds;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Update the names of the players
 *	displayed in the team UI for the
 *	given team
 *
 *	@param	_ClanPlayerIds						The ids of the players of the team
 */
Void UpdateTeamUI(Ident[] _ClanPlayerIds) {
	declare ClanPlayers = CTmPlayer[];
	foreach (PlayerId in _ClanPlayerIds) {
		if (AllPlayers.existskey(PlayerId)) {
			ClanPlayers.add(AllPlayers[PlayerId]);
		}
	}
	foreach (Player in ClanPlayers) {
		TeamUI::SetTeam(ClanPlayers, Player);
	}
}

Void AddPlayerToClan(Integer _Clan, CTmPlayer _Player) {
	if (_Player == Null) return;
	
	TeamSelectionUI::UseRandomTeammate(False, _Player);
	ChaseUI::SetChaseAttackClan(_Clan, _Player);
	CheckpointRankingUI::Enable(True, _Player);
	
	declare ClanPlayerIds = Clans::GetClan(_Clan);
	UpdateTeamUI(ClanPlayerIds);
	
	// Special behavior for the current teammate system
	if (ClanPlayerIds.count == 2) {
		if (
			AllPlayers.existskey(ClanPlayerIds[0]) &&
			AllPlayers.existskey(ClanPlayerIds[1])
		) {
			declare Player1 <=> AllPlayers[ClanPlayerIds[0]];
			declare Player2 <=> AllPlayers[ClanPlayerIds[1]];
			TeamSelectionUI::SetTeammate(Player1, Player2);
			TeamSelectionUI::SetTeammate(Player2, Player1);
		}
	}
		
	Log::Log("""[ChaseAttack] {{{_Player.Id}}} joins clan {{{_Clan}}}""");
}

Void RemovePlayersFromClan(Integer _Clan, Ident[] _PlayerIdsToRemove, Integer[Integer] _Stats) {
	declare Integer[] ClansLosingPlayers;
	foreach (PlayerId in _PlayerIdsToRemove) {
		if (AllPlayers.existskey(PlayerId)) {
			declare Player <=> AllPlayers[PlayerId];
			TeamSelectionUI::SetTeammate(Null, Player);
			ChaseUI::SetChaseAttackClan(Const::C_NoClan, Player);
			CheckpointRankingUI::Enable(False, Player);
			TeamUI::SetTeam(CTmPlayer[], Player);
			CheckpointTimeUI::ResetCheckpointTime(Player);
			CheckpointRankingUI::ResetCheckpointRanking(Player);
			FinishTimeoutUI::SetTimeout(-1, Player);
			RestartUI::ResetRestart(Player);
			MedalUI::CancelRaceMedal(Player);
			MedalUI::CancelMedalCounter(Player);
			ChaseUI::SetVisibility(False, Player);
			
			declare UI <=> UIManager.GetUI(Player);
			if (UI != Null) {
				UI.UIStatus = CUIConfig::EUIStatus::None;
			}
			
			SetStats(_Stats, Player.Score);
			
			if (TM::IsRacing(Player)) {
				TM::WaitRace(Player);
			}
		}
		Log::Log("""[ChaseAttack] {{{PlayerId}}} leaves clan {{{_Clan}}}""");
	}
	UpdateTeamUI(Clans::GetClan(_Clan));
}

Ident[] AddPlayerToLobby(Ident[] _LobbyPlayers, CTmPlayer _Player) {
	if (_Player == Null || _LobbyPlayers.exists(_Player.Id)) return _LobbyPlayers;
	
	declare LobbyPlayers = _LobbyPlayers;
	LobbyPlayers.add(_Player.Id);
	TeamSelectionUI::Enable(True, _Player);
	ChaseTuto::IsInLobby(True, _Player);
	TeamSelectionUI::SetLobbyPlayers(LobbyPlayers);
	declare UI <=> UIManager.GetUI(_Player);
	if (UI != Null) {
		UI.SpectatorForceCameraType = 2;
	}
	Log::Log("""[ChaseAttack] {{{_Player.Id}}} joins the lobby""");
	
	return LobbyPlayers;
}

Ident[] RemovePlayersFromLobby(Ident[] _LobbyPlayers, Ident[] _PlayerIdsToRemove) {
	declare LobbyPlayers = _LobbyPlayers;
	
	foreach (PlayerId in _PlayerIdsToRemove) {
		declare Removed = LobbyPlayers.remove(PlayerId);
		if (AllPlayers.existskey(PlayerId)) {
			declare Player <=> AllPlayers[PlayerId];
			TeamSelectionUI::Enable(False, Player);
			ChaseTuto::IsInLobby(False, Player);
			declare UI <=> UIManager.GetUI(Player);
			if (UI != Null) {
				UI.SpectatorForceCameraType = -1;
			}
			
			if (TM::IsRacing(Player)) {
				TM::WaitRace(Player);
			}
		}
		Log::Log("""[ChaseAttack] {{{PlayerId}}} leaves the lobby""");
	}
	
	TeamSelectionUI::SetLobbyPlayers(LobbyPlayers);
	
	return LobbyPlayers;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Set the best checkpoint times of a
 *	player
 *
 *	@param	_CheckpointTimes					The time at each checkpoint of the race
 *	@param	_Score										The player's score
 */
Void SetPlayerBestCheckpointTimes(Integer[Ident][Integer] _CheckpointTimes, CTmScore _Score) {
	if (_Score == Null) return;
	declare ChaseAttack_BestCheckpointTimes for _Score = Integer[Ident][Integer];
	ChaseAttack_BestCheckpointTimes = _CheckpointTimes;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the best checkpoint times of a
 *	player
 *
 *	@param	_Score										The score of the player to check
 *
 *	@return														The time at each checkpoint [LapNb => [BlockId => Time]]
 */
Integer[Ident][Integer] GetPlayerBestCheckpointTimes(CTmScore _Score) {
	if (_Score == Null) return Integer[Ident][Integer];
	declare ChaseAttack_BestCheckpointTimes for _Score = Integer[Ident][Integer];
	return ChaseAttack_BestCheckpointTimes;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Set the best checkpoint cumulated
 *	points of a player
 *
 *	@param	_CheckpointPoints					The points cumulated by the player since the start 
 *																		of the race at each checkpoint
 *	@param	_Score										The player's score
 */
Void SetPlayerBestCheckpointPoints(Integer[Ident][Integer] _CheckpointPoints, CTmScore _Score) {
	if (_Score == Null) return;
	declare ChaseAttack_BestCheckpointPoints for _Score = Integer[Ident][Integer];
	ChaseAttack_BestCheckpointPoints = _CheckpointPoints;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the best checkpoint points of a
 *	player
 *
 *	@param	_Score										The score of the player to check
 *
 *	@return														The points cumulated at each checkpoint [LapNb => [BlockId => Points]]
 */
Integer[Ident][Integer] GetPlayerBestCheckpointPoints(CTmScore _Score) {
	if (_Score == Null) return Integer[Ident][Integer];
	declare ChaseAttack_BestCheckpointPoints for _Score = Integer[Ident][Integer];
	return ChaseAttack_BestCheckpointPoints;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Give a medal to a player
 *
 *	@param	_Medal										The medal to give
 *	@param	_Score										The score of the player receiving the medal
 */
Void GiveMedal(Integer _Medal, CTmScore _Score) {
	if (_Score == Null) return;
	
	declare CA_Medals for _Score = Integer[Integer];
	if (C_UnlockLesserMedals) {
		declare Medals = [Const::C_Medal_Bronze, Const::C_Medal_Silver, Const::C_Medal_Gold];
		declare MedalKey = Medals.keyof(_Medal);
		foreach (Key => Medal in Medals) {
			if (MedalKey >= Key) {
				if (!CA_Medals.existskey(Medal)) {
					CA_Medals[Medal] = 0;
				}
				CA_Medals[Medal] += 1;
			}
		}
	} else {
		if (!CA_Medals.existskey(_Medal)) {
			CA_Medals[_Medal] = 0;
		}
		CA_Medals[_Medal] += 1;
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the medals owned by player
 *
 *	@param	_Score										The socre of the player to check
 *
 *	@return														The players' medal
 *																		[Const::C_Medal_XXX => Number of medals]
 */
Integer[Integer] GetMedals(CTmScore _Score) {
	if (_Score == Null) return Integer[Integer];
	
	declare CA_Medals for _Score = Integer[Integer];
	return CA_Medals;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Reset the medals of a player
 *
 *	@param	_Score										The score of the player to reset
 */
Void ResetMedals(CTmScore _Score) {
	if (_Score == Null) return;
	
	declare CA_Medals for _Score = Integer[Integer];
	CA_Medals = Integer[Integer];
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the time left to the players to
 *	finish the map after the first player
 *
 *	@param	_FinishTimeout						The value of the timeout setting
 *
 *	@return 				The time left in ms
 */
Integer GetFinishTimeout(Integer _FinishTimeout) {
	return Chase::GetFinishTimeout(_FinishTimeout) + S_WaypointEventDelay + 10;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Give race points to a player
 *
 *	@param	_Points										The number of points to add
 *	@param	_Score										The score to update
 */
Void AddRacePoints(Integer _Points, CTmScore _Score) {
	if (_Score == Null) return;
	declare ChaseAttack_RacePoints for _Score = 0;
	ChaseAttack_RacePoints += _Points;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Give checkpoint points to a player
 *
 *	@param	_LapNb										The lap number
 *	@param	_BlockId									The block id of the checkpoint
 *	@param	_Points										The number of points to add
 *	@param	_Score										The score to update
 */
Void AddCheckpointsPoints(Integer _LapNb, Ident _BlockId, Integer _Points, CTmScore _Score) {
	if (_Score == Null) return;
	declare ChaseAttack_CheckpointsPoints for _Score = Integer[Ident][Integer];
	if (!ChaseAttack_CheckpointsPoints.existskey(_LapNb)) {
		ChaseAttack_CheckpointsPoints[_LapNb] = Integer[Ident];
	}
	ChaseAttack_CheckpointsPoints[_LapNb][_BlockId] = _Points;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Update the best race points of a player
 *
 *	@param	_Points										The number of points
 *	@param	_Score										The score to update
 */
Void SetBestRacePoints(Integer _Points, CTmScore _Score) {
	if (_Score == Null) return;
	declare ChaseAttack_BestRacePoints for _Score = 0;
	ChaseAttack_BestRacePoints = _Points;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Reset the number of race points of a player
 *
 *	@param	_Score										The score of the player to reset
 */
Void ResetRacePoints(CTmScore _Score) {
	if (_Score == Null) return;
	declare ChaseAttack_RacePoints for _Score = 0;
	ChaseAttack_RacePoints = 0;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Reset the checkpoints points of a player
 *
 *	@param	_Score										The score of the player to reset
 */
Void ResetCheckpointsPoints(CTmScore _Score) {
	if (_Score == Null) return;
	declare ChaseAttack_CheckpointsPoints for _Score = Integer[Ident][Integer];
	ChaseAttack_CheckpointsPoints.clear();
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Reset the best race points of a player
 *
 *	@param	_Score										The score of the player to reset
 */
Void ResetBestRacePoints(CTmScore _Score) {
	if (_Score == Null) return;
	declare ChaseAttack_BestRacePoints for _Score = 0;
	ChaseAttack_BestRacePoints = 0;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the number of race points of a player
 *
 *	@param	_Score										The score of the player to check
 *
 *	@return														The number of race points if found
 *																		0 otherwise
 */
Integer GetRacePoints(CTmScore _Score) {
	if (_Score == Null) return 0;
	declare ChaseAttack_RacePoints for _Score = 0;
	return ChaseAttack_RacePoints;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the points cumulated by a player
 *	at each checkpoint
 *
 *	@param	_Score										The score of the player to check
 *
 *	@return														The checkpoints points
 */
Integer[Ident][Integer] GetCheckpointsPoints(CTmScore _Score) {
	if (_Score == Null) return Integer[Ident][Integer];
	declare ChaseAttack_CheckpointsPoints for _Score = Integer[Ident][Integer];
	return ChaseAttack_CheckpointsPoints;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the best race points of a player
 *
 *	@param	_Score										The score of the player to check
 *
 *	@return														The best race points if found
 *																		0 otherwise
 */
Integer GetBestRacePoints(CTmScore _Score) {
	if (_Score == Null) return 0;
	declare ChaseAttack_BestRacePoints for _Score = 0;
	return ChaseAttack_BestRacePoints;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Initialize a score beginning
 *	a new race
 *
 *	@param	_Score										The score to initialize
 */
Void InitScore(CTmScore _Score) {
	if (_Score == Null) return;
	
	_Score.BestRace = Null;
	_Score.BestLap = Null;
	_Score.PrevRace = Null;
	_Score.TempResult = Null;
	
	declare Chase_Combo for _Score = 0;
	declare Chase_PerfLow for _Score = 0;
	declare Chase_PerfHigh for _Score = 0;
	declare Chase_BestCheckpoint for _Score = 0;
	declare Chase_LegendaryNb for _Score = 0;
	declare Chase_BestCombo for _Score = 0;
	Chase_Combo = 0;
	Chase_PerfLow = 0;
	Chase_PerfHigh = 0;
	Chase_BestCheckpoint = 0;
	Chase_LegendaryNb = 0;
	Chase_BestCombo = 0;
	
	ResetRacePoints(_Score);
	ResetCheckpointsPoints(_Score);
	ResetBestRacePoints(_Score);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/// Update the players ranking
Void UpdateRanking() {
	declare SortingTime = Integer[CTmScore][Integer];
	declare SortingNoTime = Integer[CTmScore];
	
	foreach (Score in Scores) {
		declare Time = Scores::GetPlayerBestRaceTime(Score);
		declare Points = GetBestRacePoints(Score);
		if (Time < 0) {
			SortingNoTime[Score] = -Points;
		} else {
			if (!SortingTime.existskey(Time)) {
				SortingTime[Time] = Integer[CTmScore];
			}
			SortingTime[Time][Score] = -Points;
		}
	}
	
	declare Points = Scores.count + 1;
	SortingTime = SortingTime.sortkey();
	foreach (Time => SortingScores in SortingTime) {
		declare SortedScores = SortingScores.sort();
		foreach (Score => SortedPoints in SortedScores) {
			Scores::SetPlayerMapPoints(Score, Points);
			Points -= 1;
		}
	}
	SortingNoTime = SortingNoTime.sort();
	foreach (Score => SortedPoints in SortingNoTime) {
		Scores::SetPlayerMapPoints(Score, 0);
		Points -= 1;
	}
	
	MB_SortScores(CTmMode::ETmScoreSortOrder::TotalPoints);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
// Send checkpoint ranking to the UI
Void UpdateCheckpointRankingUI(Integer[CTmScore] _RankedScores, Integer[CTmScore] _ScoreTimes, Integer _Rank, CTmPlayer _Player) {
	declare Integer[] Times;
	declare Text[] Names;
	declare Integer[] Ranks;
	declare PlayerKey = 1;
	declare Count = 1;
	declare Min = _Rank - Const::C_CheckpointRanking_PlayersNb + 2;
	if (Min < 1) Min = 1;
	declare Max = _Rank;
	if (Max < Const::C_CheckpointRanking_PlayersNb) Max = Const::C_CheckpointRanking_PlayersNb;
	
	foreach (Score => Points in _RankedScores) {
		if (Count == 1 || (Count >= Min && Count <= Max)) {
			Times.add(_ScoreTimes[Score]);
			Names.add(Score.User.Name);
			Ranks.add(Count);
			if (Score == _Player.Score) PlayerKey = Times.count - 1;
		}
		if (Times.count >= Const::C_CheckpointRanking_PlayersNb) break;
		Count += 1;
	}
	
	CheckpointRankingUI::UpdateCheckpointRanking(Ranks, Names, Times, PlayerKey, _Player);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/**	Update the rank of a player at a given
 *	checkpoint
 *
 *	@param	_Player										The player whose you want to know the rank
 *
 *	@return														The rank of the player
 */
Integer UpdateCheckpointRanking(CTmPlayer _Player, Integer _LapNb, Ident _BlockId, Integer _Time, Integer _Points) {
	if (_Player == Null) return 0;
	
	// Determine the worst rank the player can get
	MB_SortScores(CTmMode::ETmScoreSortOrder::TotalPoints);
	declare WorstRank = 1;
	declare CurrentRank = 1;
	declare NobodyFinished = True;
	foreach (Rank => Score in Scores) {
		if (Score != _Player.Score && Score.BestRace.Time >= 0) WorstRank += 1;
		if (Score == _Player.Score) CurrentRank = Rank + 1;
		if (Score.BestRace.Time >= 0) NobodyFinished = False;
	}
	if (CurrentRank > WorstRank) WorstRank = CurrentRank;
	
	// If nobody finished yet the player can only be ranked first
	// If the worst rank the player can get is first, then just return it now
	if (NobodyFinished || WorstRank <= 1) {
		CheckpointRankingUI::UpdateCheckpointRanking([1], [_Player.User.Name], [_Time], 0, _Player);
		return 1;
	}
	
	// If the player do not have a time, return the worst rank
	if (_Time < 0) return WorstRank;
	
	declare Integer[CTmScore][Integer] SortingTime;
	
	// Insert the time and points of the player to rank
	SortingTime[_Time] = Integer[CTmScore];
	SortingTime[_Time][_Player.Score] = -_Points;
	
	// Get all players (except the player to rank) best time and points
	foreach (Score in Scores) {
		if (Score.Id != _Player.Score.Id) {
			declare BestCheckpointTimes = GetPlayerBestCheckpointTimes(Score);
			declare BestCheckpointPoints = GetPlayerBestCheckpointPoints(Score);
			if (
				BestCheckpointTimes.existskey(_LapNb) &&
				BestCheckpointTimes[_LapNb].existskey(_BlockId) &&
				BestCheckpointPoints.existskey(_LapNb) &&
				BestCheckpointPoints[_LapNb].existskey(_BlockId)
			) {
				declare Time = BestCheckpointTimes[_LapNb][_BlockId];
				declare Points = BestCheckpointPoints[_LapNb][_BlockId];
				if (!SortingTime.existskey(Time)) {
					SortingTime[Time] = Integer[CTmScore];
				}
				SortingTime[Time][Score] = -Points;
			}
		}
	}
	
	// Sort the players time and points
	declare Integer[CTmScore] RankedScores;
	declare Integer[CTmScore] ScoreTimes;
	declare Points = Scores.count + 1;
	SortingTime = SortingTime.sortkey();
	foreach (Time => SortingScores in SortingTime) {
		declare SortedScores = SortingScores.sort();
		foreach (Score => SortedPoints in SortedScores) {
			RankedScores[Score] = -Points;
			ScoreTimes[Score] = Time;
			Points -= 1;
		}
	}
	
	// Find the player rank
	RankedScores = RankedScores.sort();
	declare Rank = 1;
	foreach (Score => Points in RankedScores) {
		if (Score == _Player.Score) break;
		Rank += 1;
	}
	
	UpdateCheckpointRankingUI(RankedScores, ScoreTimes, Rank, _Player);
	
	return Rank;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Update the time limit
 *
 *	@param	_StartTime								The starting time of the map
 *	@param	_NewTimeLimit							The time limit before going to the next map
 */
Void SetTimeLimit(Integer _StartTime, Integer _NewTimeLimit) {
	// User define time limit with a setting
	if (_NewTimeLimit > 0) {
		CutOffTimeLimit = _StartTime + (_NewTimeLimit * 1000);
		if (Hud != Null) Hud.ScoresTable.SetFooterText(TL::Compose("%1 "^TL::TimeToText(_NewTimeLimit * 1000, False), _("Time Limit :")));
	} 
	// No time limit
	else if (_NewTimeLimit == 0) {
		CutOffTimeLimit = -1;
		if (Hud != Null) Hud.ScoresTable.SetFooterText(TL::Compose("%1 -", _("Time Limit :")));
	} 
	// Time limit auto adjusted
	else {
		declare ObjectiveNbLaps = Map.TMObjective_NbLaps;
		if (ObjectiveNbLaps <= 0) ObjectiveNbLaps = 1;
		declare TimePerLap = ML::NearestInteger((Map.TMObjective_BronzeTime + (Map.TMObjective_BronzeTime * 0.1)) / ObjectiveNbLaps);
		declare Laps = NbLaps;
		if (Laps < 0) Laps = Map.TMObjective_NbLaps;
		CutOffTimeLimit = _StartTime + (TimePerLap * Laps);
		if (Hud != Null) Hud.ScoresTable.SetFooterText(TL::Compose("%1 "^TL::TimeToText(TimePerLap * Laps, False), _("Time Limit :")));
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Set the number of laps 
 *
 *	@param _LapsNb			The number of laps
 *	@param _StartTime		The time at which the race started
 */
Void SetLapsNb(Integer _LapsNb, Integer _StartTime, Integer _TimeLimit) {
	if (_LapsNb < 0) NbLaps = -1;
	else NbLaps = _LapsNb;
	SetTimeLimit(_StartTime, _TimeLimit);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Set the name of the next checkpoint player
 *
 *	@param	_User											User of the player
 *	@param	_Clan											Clan of the player
 *	@param	_Name											Name of the player
 *	@param	_CheckpointNb							Number of the checkpoint
 *	@param	_RaceTime									Race time if the player
 *	@param	_RelayStartTime						Start time of the relay for each team
 */
Integer[Integer] SetNextCheckpointPlayer(CUser _User, Integer _Clan, Text _Name, Integer _CheckpointNb, Integer _RaceTime, Integer[Integer] _RelayStartTime) {
	return Chase::SetNextCheckpointPlayer(C_NoNameCheckpoint, _User, _Clan, _Name, _CheckpointNb, _RaceTime, _RelayStartTime);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Compute the checkpoint grade of a player
 *
 *	@param	_Player										The recipient
 *	@param	_RelaySuccess							Was the relay successful at this checkpoint?
 *	@param	_IsRelayer								This player is the relayer
 *	@param	_Score										The score of the player at the checkpoint
 */
Void ComputeCheckpointGrade(CTmPlayer _Player, Boolean _RelaySuccess, Boolean _IsRelayer, Integer _Score) {
	Chase::ComputeCheckpointGrade(C_Checkpoint_Scores, C_Checkpoint_Grades, C_Checkpoint_Colors, C_Checkpoint_RelayGrade, C_Checkpoint_RelayColor, C_PerfLow, C_PerfHigh, _Player, _RelaySuccess, _IsRelayer, _Score, False);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Get the checkpoint score
 *
 *	@param	_LeaderTime								Time at the checkpoint of the first player
 *	@param	_LeaderSpeed							Speed at the checkpoint of the first player
 *	@param	_PlayerTime								Time at the checkpoint of the scoring player
 *	@param	_PlayerSpeed							Speed at the checkpoint of the scoring player
 *
 *	@return														The points scored by the player at the checkpoints
 */
Integer GetCheckpointScore(Integer _LeaderTime, Real _LeaderSpeed, Integer _PlayerTime, Real _PlayerSpeed) {
	return Chase::GetCheckpointScore(C_CheckpointScoreMax, _LeaderTime, _LeaderSpeed, _PlayerTime, _PlayerSpeed);
}

Void InitializeRace(Integer _Clan) {
	Clans::ResetRespawnTime(_Clan);
	Clans::ResetNextCheckpointPlayerId(_Clan);
	Clans::ResetCheckpointsProgress(_Clan);
	Clans::ResetCurrentCheckpoint(_Clan);
	Clans::ResetPenalties(_Clan);
	Clans::ClearWaypointEvents(_Clan);
	Clans::ResetRelayStartTime(_Clan);
	Clans::ResetCheckpointTimes(_Clan);
	Clans::ResetFinishTimes(_Clan);
	Clans::SetValidRace(_Clan, True);
	
	declare netwrite Integer Net_Chase_NextPlayerUpdate for Teams[0];
	declare netwrite Text[Integer] Net_Chase_NextPlayer for Teams[0];
	declare netwrite Integer[Integer] Net_Chase_NextCheckpoint for Teams[0];
	declare netwrite Integer[Integer] Net_Chase_RelayTime for Teams[0];
	declare Removed = False;
	Removed = Net_Chase_NextPlayer.removekey(_Clan);
	Removed = Net_Chase_NextCheckpoint.removekey(_Clan);
	Removed = Net_Chase_RelayTime.removekey(_Clan);
	Net_Chase_NextPlayerUpdate = Now;
	
	declare Tmp = SetNextCheckpointPlayer(Null, _Clan, "", -1, -1, Integer[Integer]);
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Reset the markers of a player
 *
 *	@param	_Player										The player to reset
 */
Void ResetMarkers(CTmPlayer _Player) {
	if (_Player == Null) return;
	ChaseUI::SendRelayInfo(Ident[Integer], Integer[CTmPlayer], _Player);
	ChaseUI::SetCheckpointMarkersVisibility(False, _Player);
	
	declare UI <=> UIManager.GetUI(_Player);
	if (UI != Null) {
		UI.MarkersXML = "";
	}
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //
/** Update the clan's marker
 *
 *	@param	_CheckpointMarkers				The xml for the markers attached to the
 *																		Checkpoints and finishes
 *	@param	_NextCheckpointPlayerId	Id of the player that must cross
 *																		the next checkpoint for each clan
 *																		[Clan => PlayerId]
 *	@param	_Clan											The clan to update
 *	@param	_TargetPlayer							Apply the update only to the given player
 *																		If null apply the update to all members and spectators of the clan
 */
Void UpdateMarkers(Text _CheckpointMarkers, Ident[Integer] _NextCheckpointPlayerId, Integer _Clan, CTmPlayer _TargetPlayer) {
	declare NextCheckpointPlayerId = NullId;
	if (_NextCheckpointPlayerId.existskey(_Clan)) NextCheckpointPlayerId = _NextCheckpointPlayerId[_Clan];
	
	declare TeammateKey = 0;
	declare NextCheckpointPlayerMarker = "";
	declare TeammatesMarkers = "";
	declare Integer[CTmPlayer] TeammatesClan;
	declare CTmPlayer[] PlayersToUpdate;
	
	foreach (Player in Players) {
		if (Clans::GetPlayerClan(Player.Id) == _Clan) {
			if (_TargetPlayer == Null || _TargetPlayer == Player) PlayersToUpdate.add(Player);
			if (Player.Id == NextCheckpointPlayerId) {
				NextCheckpointPlayerMarker ^= """<marker box="0 2 0" playerlogin="{{{Player.User.Login}}}" manialinkframeid="marker-relay-clan1" />""";
			} else {
				TeammatesMarkers ^= """<marker box="0 2 0" playerlogin="{{{Player.User.Login}}}" visibility="WhenInFrustum" manialinkframeid="marker-player-{{{TeammateKey}}}" />""";
				TeammatesClan[Player] = _Clan;
				TeammateKey += 1;
				
			}
		}
	}
	foreach (Spectator in Spectators) {
		if (ChaseUI::GetSpectatingClan(Spectator) == _Clan) {
			if (_TargetPlayer == Null || _TargetPlayer == Spectator) PlayersToUpdate.add(Spectator);
		}
	}
	
	foreach (Player in PlayersToUpdate) {
		ResetMarkers(Player);
		if (_Clan >= 0) {
			declare UI <=> UIManager.GetUI(Player);
			if (UI != Null) {
				UI.MarkersXML ^= _CheckpointMarkers^NextCheckpointPlayerMarker^TeammatesMarkers;
				
				ChaseUI::SendRelayInfo(_NextCheckpointPlayerId, TeammatesClan, Player);
				ChaseUI::SetCheckpointMarkersVisibility(True, Player);
			}
		}
	}
}
Void UpdateMarkers(Text _CheckpointMarkers, Ident[Integer] _NextCheckpointPlayerId, Integer _Clan) {
	UpdateMarkers(_CheckpointMarkers, _NextCheckpointPlayerId, _Clan, Null);
}