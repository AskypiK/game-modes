<manialink version="2" name="{( LayerName )}">

	<stylesheet>
		<style class="pos-center" halign="center" valign="center" />
	</stylesheet>

	<framemodel id="circlewave">
		<quad id="image" posn="0 0 0" sizen="16 16" halign="center" valign="center" image="{( CircleWaveImageUrl )}" colorize="5af" />
	</framemodel>

	<framemodel id="castle">

		<label id="goldincome" posn="0 8 14" halign="center" valign="center" textsize="3" textcolor="fa0" />

		<label id="name" class="pos-center" posn="0 7 13" scale="1" text="Une planÃ¨te" textemboss="1" style="TextRaceMessageBig" textsize="1" textcolor="ddff" />

		<frame posn="0 0 12">
			<quad id="attacktext" class="scalable" sizen="12 12" halign="left" valign="bottom" image="{( AttackTextImageUrl )}" hidden="1" data-scaleorig="1" data-scalevar="0.05" />
			<quad id="attackarrow" sizen="12 12" halign="left" valign="bottom" image="{( AttackArrowImageUrl )}" hidden="1" />

			<quad id="taketext" class="scalable" sizen="12 12" halign="left" valign="bottom" image="{( TakeTextImageUrl )}" hidden="1" data-scaleorig="1" data-scalevar="0.05" />
			<quad id="takearrow" sizen="12 12" halign="left" valign="bottom" image="{( TakeArrowImageUrl )}" hidden="1" />

			<quad id="blitztext" class="scalable" sizen="12 12" halign="left" valign="bottom" image="{( BlitzTextImageUrl )}" hidden="1" data-scaleorig="1" data-scalevar="0.05" />
			<quad id="blitzarrow" sizen="12 12" halign="left" valign="bottom" image="{( BlitzArrowImageUrl )}" hidden="1" />
		</frame>

		<quad id="reticle" class="rotable" posn="0 0 11" sizen="30 30" halign="center" valign="center" image="{( ReticleImageUrl )}" colorize="5af" hidden="1" data-rotvar="-0.1" />

		<frame id="defensegold" posn="0 2 9">
			<label id="defensegoldtext" posn="0 1" halign="center" valign="center" textsize="2" textcolor="fa0" text="0" />
			<quad id="defensegoldbg" posn="0 0" sizen="10 5" halign="center" valign="center" style="Bgs1" substyle="BgShadow" />
		</frame>
		
		<!-- EG: je cache le flag, trop moche pour actuellement --> 
		<!-- <quad id="flagcut" posn="-5 -1.5 9" sizen="10 1" style="Bgs1" substyle="BgShadow" opacity="0" /> -->
		<quad id="flagcut" posn="-5 -1.5 9" sizen="10 1" bgcolor="0000" opacity="0" />
		<frame posn="2 5 8" clip="1" clipsizen="32 32" clipposn="0 9">
			<frame  posn="5">
				<!--<quad id="flag" posn="0 0" sizen="20 20" halign="center" valign="center" image="file://Media/Manialinks/ShootMania/Warlords/Textures/World/Flag2.png"  opacity="0"/>-->
				<quad id="flag" posn="0 0" sizen="20 20" halign="center" valign="center" image="" bgcolor="0000" opacity="0"/>
			</frame>
		</frame>

		<quad id="capital" posn="0 0 7" sizen="6 6" halign="right" valign="top" image="{( CapitalImageUrl )}" hidden="1" />
		<quad id="owneremblem" posn="0 0 6" sizen="10 10" halign="right" valign="top" hidden="1" />

		<frame id="circlewaves" posn="0 0 1" hidden="1">
			<frameinstance id="circlewave1" modelid="circlewave" scale="0.75" />
			<frameinstance id="circlewave2" modelid="circlewave" scale="1.5" />
		</frame>

		<frame id="scale">

			<quad id="focus" posn="0 0 13" sizen="20 20" scale="0.75" halign="center" valign="center" scriptevents="1" />

			<quad id="goldvein" class="rotable" posn="0 0 5" sizen="24 24" halign="center" valign="center" image="{( GoldVeinImageUrl )}" opacity="0.9" hidden="1" data-rotvar="-0.1" />

			<quad id="startpoint" class="pos-center rotable" posn="0 0 4" sizen="20 20" scale="0.75" image="{( StartPointImageUrl )}" colorize="0af" hidden="1" data-rotvar="-0.2" />

			<quad id="lightproj" class="pos-center" rot="-45" posn="0 0 3" scale="0.75" sizen="20.5 20.5" image="{( LightProjImageUrl )}" />
			<quad posn="0 0 2" id="typeimage" class="pos-center rotable" sizen="20 20" scale="0.75" image="{( CastleTypeImageUrl )}" opacity="0.98" data-rotvar="0.1" />

			<quad id="halo" posn="0 0 0" sizen="40 40" halign="center" valign="center" style="Bgs1" substyle="Glow" opacity="0.75" />
			
		</frame>
	</framemodel>
	
	<framemodel id="link">
		<quad id="front" posn="0 0 2" sizen="0 0.6" halign="left" valign="center" image="{( LinkFrontImageUrl )}" hidden="1" />
		<quad id="backw" posn="0 0 1" sizen="0 3" opacity="0.2" halign="left" valign="center" style="Bgs1" substyle="BgWindow4" />
		<quad id="backb" posn="0 0 0" sizen="0 0.7" opacity="0.6" halign="left" valign="center" style="Bgs1" substyle="BgProgressBar" />
	</framemodel>

	<frame id="content" posn="0 0 -80">

		<quad id="castlehighlighterbg" posn="0 0 19" sizen="320 180" halign="center" valign="center" bgcolor="000" opacity="0" />

		<frame id="world" posn="0 0 1">
			<frame id="castleinstances" posn="0 0 3">
				{( CastleFrameInstances )}
			</frame>

			<frame id="linkinstances" posn="0 0 1">
				{( LinkFrameInstances )}
			</frame>
		</frame>

		<quad id="world_bg" posn="0 0 0" sizen="320 180" halign="center" valign="center" image="{( BackgroundImageUrl )}" />

	</frame>
	
	<frame id="debugposition" hidden="1">
		<label id="Label_position"/>
	</frame>

	<script><!--

		#Include "TextLib" as TL
		#Include "MathLib" as ML 
		#Include "AnimLib" as AL

		// ---------------------------------- //

		#Const C_BaseCastlesFrameLocationX				60.
		#Const C_BaseCastlesFrameLocationY				15.
		#Const C_BaseLinkSize							2.
		#Const C_CastlePosZHighlighted					14.
		#Const C_CastlePosZNormal						0.
		#Const C_CastleHighlighterFadeDuration			1000
		#Const C_EmpireHighlightAnimationDuration		1000
		#Const C_GoldPerCastlePerYear					{( GoldPerCastlePerYear )}
		#Const C_GoldAmountForCapitals					{( GoldAmountForCapitals )}
		#Const C_BlitzGold								{( BlitzGold )}

		#Const C_GoldMoveAimPos							<-40., -80.>

		#Const C_OwnedCastleHaloScale					1.4
		#Const C_NotOwnedCastleHaloScale				0.75

		#Const C_PhaseSetup								-1
		#Const C_PhaseDomination						0
		#Const C_PhaseSuddenDeath						1

		#Const C_FocusSound								"{( FocusSoundUrl )}"
		#Const C_EmblemBaseUrl							"{( EmblemBaseUrl )}"
		#Const C_GoldIncomeLabelAnimDuration			{( GoldIncomeLabelAnimDuration )}
		#Const C_FlagAnimationDuration					200
		#Const C_GoldIncomeLabelAnimShift				1500

		#Const C_DebugPosition							False

		#Const C_PlanetTypeUrl [
			0 => "file://Media/Manialinks/ShootMania/Warlords/Textures/World/Castles/Castle60.png",
			1 => "file://Media/Manialinks/ShootMania/Warlords/Textures/World/Castles/Castle61.png",
			2 => "file://Media/Manialinks/ShootMania/Warlords/Textures/World/Castles/Castle62.png",
			3 => "file://Media/Manialinks/ShootMania/Warlords/Textures/World/Castles/Castle63.png",
			4 => "file://Media/Manialinks/ShootMania/Warlords/Textures/World/Castles/Castle64.png",
			5 => "file://Media/Manialinks/ShootMania/Warlords/Textures/World/Castles/Castle65.png"
		]
		
		declare Boolean G_CastlesDrawn;
		declare Boolean G_LinksDrawn;

		// ---------------------------------- //
		/**
		 * Gets the frame which contains all frame instances.
		 *
		 * @return The world frame.
		 */
		CMlFrame GetWorldFrame() {
			return (Page.GetFirstChild("world") as CMlFrame);
		}

		// ---------------------------------- //
		/**
		 * Gets the frame which contains all castle frame instances.
		 *
		 * @return The frame containing all castle frame instances.
		 */
		CMlFrame GetCastleFrameInstancesParentFrame() {
			return (Page.GetFirstChild("castleinstances") as CMlFrame);
		}

		// ---------------------------------- //
		/**
		 * Gets the frame which contains all link frame instances.
		 *
		 * @return The frame containing all link frame instances.
		 */
		CMlFrame GetLinkInstancesParentFrame() {
			return (Page.GetFirstChild("linkinstances") as CMlFrame);
		}

		// ---------------------------------- //
		/**
		 * Returns all castle frame instances.
		 *
		 * @return An array containing CMlFrames.
		 */
		CMlFrame[] GetCastleFrameInstances() {
			declare CMlFrame[] Castles;
			declare CMlFrame ParentFrame = GetCastleFrameInstancesParentFrame();
			foreach (Control in ParentFrame.Controls) {
				if (!(Control is CMlFrame)) continue;
				Castles.add((Control as CMlFrame));
			}
			return Castles;
		}

		// ---------------------------------- //
		/**
		 * Returns all link frame instances.
		 *
		 * @return An array containing CMlFrames.
		 */
		CMlFrame[] GetLinkInstances() {
			declare CMlFrame[] Links;
			declare CMlFrame ParentFrame = GetLinkInstancesParentFrame();
			foreach (Control in ParentFrame.Controls) {
				if (!(Control is CMlFrame)) continue;
				Links.add((Control as CMlFrame));
			}
			return Links;
		}

		// ---------------------------------- //
		/**
		 * Gets the castle frame instance associated with the given id.
		 *
		 * @param	_Id	The frame instance id.
		 * @return	The associated frame.
		 */
		CMlFrame GetCastleInstance(Integer _Id) {
			return GetCastleFrameInstances()[_Id];
		}

		// ---------------------------------- //
		/**
		 * Returns all link frame instances.
		 *
		 * @return An array containing CMlFrames.
		 */
		CMlFrame GetLinkInstance(Integer _Id) {
			return GetLinkInstances()[_Id];
		}

		// ---------------------------------- //
		/**
		 * Gets the frame that supports scale in a castle frame instance.
		 *
		 * @param _CastleFrameInstance The concerned castle frame instance.
		 * @return The scale frame.
		 */
		CMlFrame CFI_GetCastleScaleFrame(CMlFrame _CastleFrameInstance) {
			return (_CastleFrameInstance.GetFirstChild("scale") as CMlFrame);
		}

		// ---------------------------------- //
		/**
		 * Gets the castle defense gold frame in a castle frame instance.
		 *
		 * @param _CastleFrameInstance The concerned castle frame instance.
		 * @return The castle defense gold frame.
		 */
		CMlFrame CFI_GetCastleDefenseGoldFrame(CMlFrame _CastleFrameInstance) {
			return (_CastleFrameInstance.GetFirstChild("defensegold") as CMlFrame);
		}

		// ---------------------------------- //
		/**
		 * Gets the castle defense gold label in a castle frame instance.
		 *
		 * @param _CastleFrameInstance The concerned castle frame instance.
		 * @return The castle defense gold label.
		 */
		CMlLabel CFI_GetCastleDefenseGoldLabel(CMlFrame _CastleFrameInstance) {
			return (_CastleFrameInstance.GetFirstChild("defensegoldtext") as CMlLabel);
		}

		// ---------------------------------- //
		/**
		 * Gets the castle defense gold background quad in a castle frame instance.
		 *
		 * @param The concerned castle frame instance.
		 * @return The castle defense gold background quad.
		 */
		CMlQuad CFI_GetCastleDefenseGoldQuad(CMlFrame _CastleFrameInstance) {
			return (_CastleFrameInstance.GetFirstChild("defensegoldbg") as CMlQuad);
		}

		// ---------------------------------- //
		/**
		 * Gets the castle type image in a castle frame instance.
		 *
		 * @param _CastleFrameInstance The concerned castle frame instance.
		 * @return The castle type image.
		 */
		CMlQuad CFI_GetCastleImage(CMlFrame _CastleFrameInstance) {
			return (_CastleFrameInstance.GetFirstChild("typeimage") as CMlQuad);
		}

		// ---------------------------------- //
		/**
		 * Gets the castle attack text quad in a castle frame instance.
		 *
		 * @param _CastleFrameInstance The concerned castle frame instance.
		 * @return The castle attack text quad.
		 */
		CMlQuad CFI_GetCastleAttackTextQuad(CMlFrame _CastleFrameInstance) {
			return (_CastleFrameInstance.GetFirstChild("attacktext") as CMlQuad);
		}

		// ---------------------------------- //
		/**
		 * Gets the castle attack arrow quad in a castle frame instance.
		 *
		 * @param _CastleFrameInstance The concerned castle frame instance.
		 * @return The castle attack arrow quad.
		 */
		CMlQuad CFI_GetCastleAttackArrowQuad(CMlFrame _CastleFrameInstance) {
			return (_CastleFrameInstance.GetFirstChild("attackarrow") as CMlQuad);
		}

		// ---------------------------------- //
		/**
		 * Gets the castle take text quad in a castle frame instance.
		 *
		 * @param _CastleFrameInstance The concerned castle frame instance.
		 * @return The castle take text quad.
		 */
		CMlQuad CFI_GetCastleTakeTextQuad(CMlFrame _CastleFrameInstance) {
			return (_CastleFrameInstance.GetFirstChild("taketext") as CMlQuad);
		}

		// ---------------------------------- //
		/**
		 * Gets the castle take arrow quad in a castle frame instance.
		 *
		 * @param _CastleFrameInstance The castle frame instance.
		 * @return The castle take arrow quad.
		 */
		CMlQuad CFI_GetCastleTakeArrowQuad(CMlFrame _CastleFrameInstance) {
			return (_CastleFrameInstance.GetFirstChild("takearrow") as CMlQuad);
		}

		// ---------------------------------- //
		/**
		 * Gets the castle blitz text quad in a castle frame instance.
		 *
		 * @param _CastleFrameInstance The concerned castle frame instance.
		 * @return The castle blitz text quad.
		 */
		CMlQuad CFI_GetCastleBlitzTextQuad(CMlFrame _CastleFrameInstance) {
			return (_CastleFrameInstance.GetFirstChild("blitztext") as CMlQuad);
		}

		// ---------------------------------- //
		/**
		 * Gets the castle blitz arrow quad in a castle frame instance.
		 *
		 * @param _CastleFrameInstance The castle frame instance.
		 * @return The castle blitz arrow quad.
		 */
		CMlQuad CFI_GetCastleBlitzArrowQuad(CMlFrame _CastleFrameInstance) {
			return (_CastleFrameInstance.GetFirstChild("blitzarrow") as CMlQuad);
		}

		// ---------------------------------- //
		/**
		 * Gets the castle name label in a castle frame instance.
		 *
		 * @param _CastleFrameInstance The concerned castle frame instance.
		 * @return The castle name label.
		 */
		CMlLabel CFI_GetCastleNameLabel(CMlFrame _CastleFrameInstance) {
			return (_CastleFrameInstance.GetFirstChild("name") as CMlLabel);
		}

		// ---------------------------------- //
		/**
		 * Gets the castle reticle quad in a castle frame instance.
		 *
		 * @param _CastleFrameInstance The concerned castle frame instance.
		 * @return The castle reticle quad.
		 */
		CMlQuad CFI_GetCastleReticle(CMlFrame _CastleFrameInstance) {
			return (_CastleFrameInstance.GetFirstChild("reticle") as CMlQuad);
		}

		// ---------------------------------- //
		/**
		 * Gets the castle gold income label in a castle frame instance.
		 *
		 * @param _CastleFrameInstance The concerned castle frame instance.
		 * @return The castle gold income label.
		 */
		CMlLabel CFI_GetCastleGoldIncomeLabel(CMlFrame _CastleFrameInstance) {
			return (_CastleFrameInstance.GetFirstChild("goldincome") as CMlLabel);
		}

		// ---------------------------------- //
		/**
		 * Gets the castle halo quad in a castle frame instance.
		 *
		 * @param _CastleFrameInstance The concerned castle frame instance.
		 * @return The castle halo quad.
		 */
		CMlQuad CFI_GetCastleHaloQuad(CMlFrame _CastleFrameInstance) {
			return (_CastleFrameInstance.GetFirstChild("halo") as CMlQuad);
		}

		// ---------------------------------- //
		/**
		 * TODO REPRENDRE ICI
		 *
		 * @param 
		 * @return 
		 */
		CMlQuad CFI_GetFlagQuad(CMlFrame _CastleFrameInstance) {
			return (_CastleFrameInstance.GetFirstChild("flag") as CMlQuad);
		}

		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		CMlQuad CFI_GetFlagCutQuad(CMlFrame _CastleFrameInstance) {
			return (_CastleFrameInstance.GetFirstChild("flagcut") as CMlQuad);
		}

		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		CMlQuad LFI_GetLinkFrontImage(CMlFrame _LinkFrameInstance) {
			return (_LinkFrameInstance.GetFirstChild("front") as CMlQuad);
		}

		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		CMlQuad LFI_GetLinkBackWhiteImage(CMlFrame _LinkFrameInstance) {
			return (_LinkFrameInstance.GetFirstChild("backw") as CMlQuad);
		}

		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		CMlQuad LFI_GetLinkBackBlackImage(CMlFrame _LinkFrameInstance) {
			return (_LinkFrameInstance.GetFirstChild("backb") as CMlQuad);
		}

		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		CMlQuad CFI_GetFocusQuad(CMlFrame _CastleFrameInstance) {
			return (_CastleFrameInstance.GetFirstChild("focus") as CMlQuad);
		}

		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		CMlFrame GetCastleFrameInstanceFromFocusQuad(CMlQuad _FocusQuad) {
			foreach (CastleFrameInstance in GetCastleFrameInstances()) {
				declare CMlQuad FocusQuad = CFI_GetFocusQuad(CastleFrameInstance);
				if (FocusQuad == _FocusQuad) return CastleFrameInstance;
			}
			return Null;
		}


		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		CMlQuad CFI_GetCastleStartPointQuad(CMlFrame _CastleFrameInstance) {
			return (_CastleFrameInstance.GetFirstChild("startpoint") as CMlQuad);
		}

		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		CMlQuad CFI_GetCastleOwnerEmblemQuad(CMlFrame _CastleFrameInstance) {
			return (_CastleFrameInstance.GetFirstChild("owneremblem") as CMlQuad);
		}

		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		CMlQuad CFI_GetCastleCapitalQuad(CMlFrame _CastleFrameInstance) {
			return (_CastleFrameInstance.GetFirstChild("capital") as CMlQuad);
		}

		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		CMlQuad CFI_GetGoldVeinQuad(CMlFrame _CastleFrameInstance) {
			return (_CastleFrameInstance.GetFirstChild("goldvein") as CMlQuad);
		}

		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		CMlFrame CFI_GetCircleWavesFrame(CMlFrame _CastleFrameInstance) {
			return (_CastleFrameInstance.GetFirstChild("circlewaves") as CMlFrame);
		}

		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		CMlFrame CFI_GetFirstCircleWave(CMlFrame _CastleFrameInstance) {
			return (_CastleFrameInstance.GetFirstChild("circlewave1") as CMlFrame);
		}

		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		CMlFrame CFI_GetSecondCircleWave(CMlFrame _CastleFrameInstance) {
			return (_CastleFrameInstance.GetFirstChild("circlewave2") as CMlFrame);
		}

		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		CMlQuad CWFI_GetCircleWaveQuad(CMlFrame _CircleWaveFrameInstance) {
			return (_CircleWaveFrameInstance.GetFirstChild("image") as CMlQuad);
		}

		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		Integer CFI_GetCastleId(CMlFrame _CastleFrameInstance) {
			declare Integer CastleId for _CastleFrameInstance = -1;
			return CastleId;
		}

		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		CMlQuad GetCastleHighlighterBg() {
			return (Page.GetFirstChild("castlehighlighterbg") as CMlQuad);
		}

		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		Void HideAllCircleWaves() {
			foreach (CastleFrameInstance in GetCastleFrameInstances()) {
				CFI_GetCircleWavesFrame(CastleFrameInstance).Hide();
			}
		}

		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		Vec3 GetColorization(Integer _CastleId) {
			declare Vec3 Colorization = <0., 0., 0.>;

			declare netread Int3[Integer] Srv_World_G_CastlePropertiesBis for Teams[0];
			declare Integer CastleType = Srv_World_G_CastlePropertiesBis[_CastleId].Y;

			switch (CastleType) {
				case 0: { // Fire
					Colorization = <1., 0.1, 0.>;
				}
				case 1: { // Forest
					Colorization = <0. , 0.4, 0.>;
				}
				case 2: { // Ice
					Colorization = <0.4 , 0.75, 1.>;
				}
				case 3: { // Sand
					Colorization = <1. , 0.75, 0.4>;
				}
			}
			return Colorization;
		}

		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		Text GetPlanetPicture(Integer _CastleId) {
			declare Picture = C_PlanetTypeUrl[0];

			declare netread Int3[Integer] Srv_World_G_CastlePropertiesBis for Teams[0];
			declare Integer CastleType = Srv_World_G_CastlePropertiesBis[_CastleId].Y;

			switch (CastleType) {
				case 1: Picture = C_PlanetTypeUrl[1];
				case 2: Picture = C_PlanetTypeUrl[2];
				case 3: Picture = C_PlanetTypeUrl[3];
				case 4: Picture = C_PlanetTypeUrl[4];
				case 5: Picture = C_PlanetTypeUrl[5];
				default: Picture = C_PlanetTypeUrl[0];
			}
			return Picture;
		}

		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		Real Distance(Vec2 _Pos1, Vec2 _Pos2) {
			return ML::Distance(<_Pos1.X, _Pos1.Y, 0.>, <_Pos2.X, _Pos2.Y, 0.>);
		}

		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		Text GetEmblemUrl(Integer _OwnerId) {
			return C_EmblemBaseUrl ^ _OwnerId + 1 ^ ".dds";
		}

		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		Vec3 GetLinkColor(Integer _OwnerId) {
			declare Vec3 Color;
			switch (_OwnerId + 1) {
				case 1: Color = <0., 0.75, 1.>;
				case 2:	Color = <1., 0.75, 0.>;
				case 3:	Color = <1., 0.25, 0.25>;
				case 4:	Color = <1., 0.25, 1.>;
				case 5:	Color = <0.25, 1., 0.25>;
				case 6:	Color = <0.5, 1., 1.>;
			}
			return Color;
		}

		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		Integer GetPlayerId(Text _PlayerLogin) {
			declare netread Text[Integer] Srv_Player_G_Players for Teams[0];
			if(Srv_Player_G_Players.exists(_PlayerLogin)) {
				return Srv_Player_G_Players.keyof(_PlayerLogin);
			}
			
			return -1;
		}

		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		Integer GetInputPlayerId() {
			return GetPlayerId(InputPlayer.User.Login);
		}

		// ---------------------------------- //
		/**
		 * Gets the amount of gold possessed by the given player.
		 *
		 * @param _PlayerId The player to get the amount of gold from.
		 * @return The amount of gold.
		 */
		Integer GetPlayerGold(Integer _PlayerId) {
			declare netread Integer[Integer] Srv_Player_G_PlayersGold for Teams[0];
			if (!Srv_Player_G_PlayersGold.existskey(_PlayerId)) return -1;
			return Srv_Player_G_PlayersGold[_PlayerId];
		}

		// ---------------------------------- //
		/**
		 * Gets the local player's gold amount.
		 *
		 * @return The gold amount.
		 */
		Integer GetInputPlayerGold() {
			return GetPlayerGold(GetInputPlayerId());
		}

		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		Boolean IsCastleOwned(Integer _CastleId) {
			declare netread Int3[Integer]		Srv_World_G_CastleAttributes	for Teams[0];
			return (Srv_World_G_CastleAttributes[_CastleId].X != -1);
		}

		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		Integer GetCastleOwnerId(Integer _CastleId) {
			declare netread Int3[Integer]		Srv_World_G_CastleAttributes	for Teams[0];
			return Srv_World_G_CastleAttributes[_CastleId].X;
		}

		// ---------------------------------- //
		/**
		 * 
		 *
		 * @param 
		 * @return 
		 */
		Boolean IsSameOwner(Integer _Castle1Id, Integer _Castle2Id) {
			declare netread Int3[Integer]		Srv_World_G_CastleAttributes	for Teams[0];
			return (Srv_World_G_CastleAttributes[_Castle1Id].X == Srv_World_G_CastleAttributes[_Castle2Id].X);
		}
		
		Boolean BlitzAllowed() {
			return C_BlitzGold >= 0;
		}

		Void UpdateCastleGold(Integer _CastleId) {
			declare netread Integer[Integer]	Srv_World_G_CastleDefenseGoldAmounts	for Teams[0];
			declare CMlFrame					CastleFrame								= GetCastleInstance(_CastleId);
			declare CMlLabel					CastleDefenseGoldLabel					= CFI_GetCastleDefenseGoldLabel(CastleFrame);
			declare CMlQuad						CastleDefenseGoldQuad					= CFI_GetCastleDefenseGoldQuad(CastleFrame);
			declare Integer						GoldToDisplay							= Srv_World_G_CastleDefenseGoldAmounts[_CastleId];

			CastleDefenseGoldLabel.SetText(TL::ToText(GoldToDisplay));
			CastleDefenseGoldQuad.Size.Y = CastleDefenseGoldLabel.ComputeWidth(CastleDefenseGoldLabel.Value) + 2;
		}

		Integer[] GetCastleIds() {
			declare netread Text[]				Srv_World_G_Castles						for Teams[0];
			declare Integer[] CastleIds;
			foreach (CastleId => CastleName in Srv_World_G_Castles) {
				CastleIds.add(CastleId);
			}
			return CastleIds;
		}

		// ---------------------------------- //
		/**
		 * Updates the world display.
		 */
		Void DrawCastles(Boolean _Force) {

			declare Boolean LastStartPointsVisibility	for This;

			declare netread Text[]				Srv_World_G_Castles						for Teams[0];
			declare netread Vec3[Integer]		Srv_World_G_CastleProperties			for Teams[0];
			declare netread Int3[Integer]		Srv_World_G_CastlePropertiesBis			for Teams[0];
			declare netread Int3[Integer]		Srv_World_G_CastleAttributes			for Teams[0];
			declare netread Integer[Integer]	Srv_World_G_CastleDefenseGoldAmounts	for Teams[0];
			declare netread Integer				Srv_World_G_BonusCastle					for Teams[0];
			declare netwrite Integer[Integer]	Cli_World_P_CastleDefenseGoldAddition	for UI;

			declare netread Integer[]			Srv_UI_P_CastlesToUpdate				for UI;

			declare CMlFrame World = GetWorldFrame();
			if (_Force || !G_CastlesDrawn) {
				World.RelativePosition.X = C_BaseCastlesFrameLocationX;
				World.RelativePosition.Y = C_BaseCastlesFrameLocationY;
			}

			declare Integer[] CastlesToUpdate;
			if (_Force) {
				CastlesToUpdate = GetCastleIds();
			} else {
				CastlesToUpdate = Srv_UI_P_CastlesToUpdate;
			}

			foreach (Id in CastlesToUpdate) {
				if (!Srv_World_G_Castles.existskey(Id)) continue;
				declare Text		CastleName				= Srv_World_G_Castles[Id];

				declare CMlFrame	CastleFrame				= GetCastleInstance(Id);
				declare CMlFrame	CastleScaleFrame		= CFI_GetCastleScaleFrame(CastleFrame);
				declare CMlFrame	CastleDefenseGoldFrame	= CFI_GetCastleDefenseGoldFrame(CastleFrame);
				declare CMlLabel	CastleDefenseGoldLabel	= CFI_GetCastleDefenseGoldLabel(CastleFrame);
				declare CMlQuad		CastleDefenseGoldQuad	= CFI_GetCastleDefenseGoldQuad(CastleFrame);
				declare CMlQuad		CastleImage				= CFI_GetCastleImage(CastleFrame);
				declare CMlLabel	CastleNameLabel			= CFI_GetCastleNameLabel(CastleFrame);
				declare CMlQuad		CastleStartPointQuad	= CFI_GetCastleStartPointQuad(CastleFrame);
				declare CMlQuad		CastleOwnerEmblemQuad	= CFI_GetCastleOwnerEmblemQuad(CastleFrame);
				declare CMlQuad		CastleCapitalQuad		= CFI_GetCastleCapitalQuad(CastleFrame);
				declare CMlQuad		GoldVeinQuad			= CFI_GetGoldVeinQuad(CastleFrame);
				declare CMlQuad		CastleHaloQuad			= CFI_GetCastleHaloQuad(CastleFrame);

				CastleNameLabel.SetText(CastleName);

				if (_Force || !G_CastlesDrawn) {
					CastleFrame.RelativePosition.X	= Srv_World_G_CastleProperties[Id].X;
					CastleFrame.RelativePosition.Y	= Srv_World_G_CastleProperties[Id].Y;
					CastleScaleFrame.RelativeScale	= Srv_World_G_CastleProperties[Id].Z;
					CastleImage.Colorize			= <0.4, 0.4, 0.4>; // GetColorization(Id)
					CastleImage.RelativeRotation	= ML::Rand(0., 359.);
					CastleImage.ImageUrl			= GetPlanetPicture(Id);
				}

				CastleDefenseGoldFrame.Hide();

				if (Srv_World_G_CastleAttributes[Id].X != -1) {
					// The castle is owned by a player.
					CastleOwnerEmblemQuad.ImageUrl = GetEmblemUrl(Srv_World_G_CastleAttributes[Id].X);
					CastleOwnerEmblemQuad.Show();
					CastleHaloQuad.ModulateColor = GetLinkColor(Srv_World_G_CastleAttributes[Id].X);
					CastleHaloQuad.RelativeScale = C_OwnedCastleHaloScale;
						
					if (Srv_World_G_CastleAttributes[Id].Z == 0) {
					
						CastleDefenseGoldFrame.Show();

						declare Integer GoldToDisplay = Srv_World_G_CastleDefenseGoldAmounts[Id];
						if (Cli_World_P_CastleDefenseGoldAddition.existskey(Id)) {
							GoldToDisplay += Cli_World_P_CastleDefenseGoldAddition[Id];
						}

						CastleDefenseGoldLabel.SetText(TL::ToText(GoldToDisplay));
						CastleDefenseGoldQuad.Size.Y = CastleDefenseGoldLabel.ComputeWidth(CastleDefenseGoldLabel.Value) + 2;
						
					}

				} else {
					CastleOwnerEmblemQuad.Hide();
					CastleHaloQuad.ModulateColor = <1., 1., 1.>;
					CastleHaloQuad.RelativeScale = C_NotOwnedCastleHaloScale;
				}

				if (Srv_World_G_CastleAttributes[Id].Z == 1) {
					CastleCapitalQuad.Show();
				} else {
					CastleCapitalQuad.Hide();
				}

				if (LastStartPointsVisibility && Srv_World_G_CastlePropertiesBis[Id].X == 1) {
					CastleStartPointQuad.Show(); // If the castle is a start point.
				} else {
					CastleStartPointQuad.Hide();
				}

				CastleFrame.Show();

				// Useful declaration to recover the castle id from any frame instance.
				declare Integer CastleId for CastleFrame;
				CastleId = Id;

				if (Srv_World_G_BonusCastle == Id) {
					// If the castle has a gold vein
					GoldVeinQuad.Show();
				} else {
					GoldVeinQuad.Hide();
				}

			}

			G_CastlesDrawn = True;
		}

		Void DrawCastles() {
			DrawCastles(False);
		}

		// ---------------------------------- //
		/**
		 * Updates the links display.
		 */
		Void DrawLinks() {
	
			declare Real RadToDeg = -(180. / ML::PI());

			declare netread Vec3[Integer]		Srv_World_G_CastleProperties	for Teams[0];
			declare netread Int3[]				Srv_World_G_Links				for Teams[0];

			foreach (Id => Link in Srv_World_G_Links) {

				declare Integer	Castle1Id = Link.X;
				declare Integer	Castle2Id = Link.Y;

				declare CMlFrame LinkFrame = GetLinkInstance(Id);
				declare CMlQuad LinkFrontImage = LFI_GetLinkFrontImage(LinkFrame);

				if (!G_LinksDrawn) {
					declare CMlQuad LinkBackWhiteImage = LFI_GetLinkBackWhiteImage(LinkFrame);
					declare CMlQuad LinkBackBlackImage = LFI_GetLinkBackBlackImage(LinkFrame);

					declare Vec3	Castle1Prop = Srv_World_G_CastleProperties[Castle1Id];
					declare Vec3	Castle1Pos = <Srv_World_G_CastleProperties[Castle1Id].X, Srv_World_G_CastleProperties[Castle1Id].Y, 0.>;
					declare Vec3	Castle2Prop = Srv_World_G_CastleProperties[Castle2Id];
					declare Vec3	Castle2Pos = <Srv_World_G_CastleProperties[Castle2Id].X, Srv_World_G_CastleProperties[Castle2Id].Y, 0.>;

					declare Real	Distance = ML::Distance(Castle1Pos, Castle2Pos);

					declare Real	Angle = ML::Angle(Castle2Pos - Castle1Pos, <1., 0., 0.>);
					if (Castle2Pos.Y < Castle1Pos.Y) Angle = -Angle;
					declare Real Rotation = Angle * RadToDeg;

					LinkFrame.RelativePosition = Castle1Pos;

					LinkFrontImage.Size		= <Distance, C_BaseLinkSize * 0.25>;
					LinkBackWhiteImage.Size	= <Distance, C_BaseLinkSize * 0.5>;
					LinkBackBlackImage.Size	= <Distance, C_BaseLinkSize * 1.75>;

					LinkFrontImage.RelativeRotation		= Rotation;
					LinkBackWhiteImage.RelativeRotation	= Rotation;
					LinkBackBlackImage.RelativeRotation	= Rotation;
				} else {

					LinkFrontImage.Size.Y = C_BaseLinkSize * 0.15;

				}

				declare Boolean SameOwner = IsSameOwner(Castle1Id, Castle2Id);
				LinkFrontImage.Visible = IsCastleOwned(Castle1Id) && IsCastleOwned(Castle2Id) && SameOwner;
				if (SameOwner) {
					LinkFrontImage.Colorize = GetLinkColor(GetCastleOwnerId(Castle1Id));
				}

				LinkFrame.Show();
			}

		}

		Int3 GetAction() {
			declare netwrite Int3 Cli_Action_P_Action for UI;
			return Cli_Action_P_Action;
		}

		Void SendAction(Int3 _Action) {
			declare netwrite Int3 Cli_Action_P_Action for UI;
			Cli_Action_P_Action = _Action;

			declare Integer Cli_UI_L_ActionRefreshedTimestamp for UI;
			Cli_UI_L_ActionRefreshedTimestamp = Now;
		}

		Void ClearAction() {
			//log(Now ^ "> clearing action...");
			SendAction(<-1, -1, -1>);
		}

		Boolean IsReady() {
			declare netwrite Boolean Cli_Player_P_Ready for UI;
			return Cli_Player_P_Ready;
		}

		Boolean IsCastleCapital(Integer _CastleId) {
			declare netread Int3[Integer] Srv_World_G_CastleAttributes for Teams[0];
			return Srv_World_G_CastleAttributes[_CastleId].Z == 1;
		}

		Integer[] GetPlayerCastles(Integer _PlayerId) {
			declare Integer[] PlayerCastles;
			declare netread Int3[Integer] Srv_World_G_CastleAttributes for Teams[0];
			foreach (CastleId => CastleAttr in Srv_World_G_CastleAttributes) {
				if (CastleAttr.X == _PlayerId) PlayerCastles.add(CastleId);
			}
			return PlayerCastles;
		}

		Integer[] GetInputPlayerCastles() {
			return GetPlayerCastles(GetInputPlayerId());
		}

		Boolean AreCastlesLinked(Integer _Castle1Id, Integer _Castle2Id) {
			declare netread Int3[] Srv_World_G_Links for Teams[0];

			foreach (Link in Srv_World_G_Links) {
				
				if ((Link.X == _Castle1Id && Link.Y == _Castle2Id) || (Link.X == _Castle2Id && Link.Y == _Castle1Id)) {
					return True;
				}

			}

			return False;
		}

		Boolean IsCastleAccessible(Integer _AimedCastleId, Integer _PlayerId) {
			foreach (CastleId in GetPlayerCastles(_PlayerId)) {
				if (AreCastlesLinked(_AimedCastleId, CastleId)) return True;
			}
			return False;
		}

		Void HideAllActionHelperQuads() {
			foreach (CastleFrameInstance in GetCastleFrameInstances()) {
				declare CMlQuad CastleAttackTextQuad	= CFI_GetCastleAttackTextQuad(CastleFrameInstance);
				declare CMlQuad CastleAttackArrowQuad	= CFI_GetCastleAttackArrowQuad(CastleFrameInstance);

				declare CMlQuad CastleTakeTextQuad		= CFI_GetCastleTakeTextQuad(CastleFrameInstance);
				declare CMlQuad CastleTakeArrowQuad		= CFI_GetCastleTakeArrowQuad(CastleFrameInstance);

				declare CMlQuad CastleBlitzTextQuad		= CFI_GetCastleBlitzTextQuad(CastleFrameInstance);
				declare CMlQuad CastleBlitzArrowQuad	= CFI_GetCastleBlitzArrowQuad(CastleFrameInstance);

				CastleAttackTextQuad.Hide();
				CastleAttackArrowQuad.Hide();

				CastleTakeTextQuad.Hide();
				CastleTakeArrowQuad.Hide();

				CastleBlitzTextQuad.Hide();
				CastleBlitzArrowQuad.Hide();
			}
		}

		Integer GetGoldDonationOnPlayer(Integer _PlayerId) {
			declare netwrite Integer[Integer] Cli_Player_P_GoldDonations for UI;
			if (Cli_Player_P_GoldDonations.existskey(_PlayerId)) return Cli_Player_P_GoldDonations[_PlayerId];
			return 0;
		}

		Integer GetTotalGoldDonation() {
			declare netread Text[Integer] Srv_Player_G_Players for Teams[0];
			declare Integer GoldSum;
			for (PlayerId, 0, Srv_Player_G_Players.count - 1) {
				GoldSum += GetGoldDonationOnPlayer(PlayerId);
			}
			return GoldSum;
		}

		Integer World_GetCastleGoldAdditions(Integer _CastleId) {
			declare netwrite Integer[Integer]	Cli_World_P_CastleDefenseGoldAddition		for UI;
			
			if (Cli_World_P_CastleDefenseGoldAddition.existskey(_CastleId)) return Cli_World_P_CastleDefenseGoldAddition[_CastleId];

			return 0;
		}

		Integer World_CountCastlesGoldAdditions() {
			declare netwrite Integer[Integer]	Cli_World_P_CastleDefenseGoldAddition		for UI;
			declare Integer GoldAmountPlacedOnCastles;

			foreach (CastleId => GoldAmount in Cli_World_P_CastleDefenseGoldAddition) {
				GoldAmountPlacedOnCastles += GoldAmount;
			}

			return GoldAmountPlacedOnCastles;
		}

		Void World_ResetAllCastlesGoldAddition() {
			declare netwrite Integer[Integer]	Cli_World_P_CastleDefenseGoldAddition		for UI;
			declare Integer						Cli_UI_L_CastleDefenseGoldAdditionTimestamp	for UI;

			Cli_World_P_CastleDefenseGoldAddition.clear();
			Cli_UI_L_CastleDefenseGoldAdditionTimestamp = Now;
			foreach (CastleId in GetInputPlayerCastles()) {
				UpdateCastleGold(CastleId);
			}
		}

		Void World_ResetGoldOnCastle(Integer _CastleId) {
			declare netwrite Integer[Integer]	Cli_World_P_CastleDefenseGoldAddition		for UI;
			declare Integer						Cli_UI_L_CastleDefenseGoldAdditionTimestamp	for UI;

			Cli_World_P_CastleDefenseGoldAddition[_CastleId] = 0;
			Cli_UI_L_CastleDefenseGoldAdditionTimestamp = Now;
			UpdateCastleGold(_CastleId);
		}

		Void World_AddGoldOnCastle(Integer _CastleId, Integer _Amount) {
			yield;
			declare Integer InputPlayerId = GetInputPlayerId();

			declare netread		Integer[Integer]	Srv_Player_G_PlayersGold					for Teams[0];
			declare netwrite	Integer				Cli_Player_P_Bet							for UI;
			declare netwrite	Integer[Integer]	Cli_World_P_CastleDefenseGoldAddition		for UI;
			declare				Integer				Cli_UI_L_CastleDefenseGoldAdditionTimestamp	for UI;

			declare Integer AvailableGoldAmount = Srv_Player_G_PlayersGold[InputPlayerId] - GetTotalGoldDonation() - World_CountCastlesGoldAdditions() - Cli_Player_P_Bet;

			if (AvailableGoldAmount <= 0) return;

			if (Cli_World_P_CastleDefenseGoldAddition.existskey(_CastleId)) {
				Cli_World_P_CastleDefenseGoldAddition[_CastleId] += _Amount;
			} else {
				Cli_World_P_CastleDefenseGoldAddition[_CastleId] = _Amount;
			}

			Cli_UI_L_CastleDefenseGoldAdditionTimestamp = Now;
			UpdateCastleGold(_CastleId);
		}

		Void World_SubGoldOnCastle(Integer _CastleId, Integer _Amount) {
			yield;
			declare netwrite Integer[Integer]	Cli_World_P_CastleDefenseGoldAddition		for UI;
			declare Integer						Cli_UI_L_CastleDefenseGoldAdditionTimestamp	for UI;

			if (Cli_World_P_CastleDefenseGoldAddition.existskey(_CastleId)) {
				Cli_World_P_CastleDefenseGoldAddition[_CastleId] -= _Amount;
			} else {
				Cli_World_P_CastleDefenseGoldAddition[_CastleId] = 0;
			}
			if (Cli_World_P_CastleDefenseGoldAddition[_CastleId] < 0) Cli_World_P_CastleDefenseGoldAddition[_CastleId] = 0;

			Cli_UI_L_CastleDefenseGoldAdditionTimestamp = Now;
			UpdateCastleGold(_CastleId);
		}

		Boolean HasBlitzed() {
			declare Integer ActionCastleId = GetAction().Z;
			return ActionCastleId != -1 && IsCastleCapital(ActionCastleId) && !IsCastleAccessible(ActionCastleId, GetInputPlayerId());
		}

		// ---------------------------------- //
		/**
		 * Gets the remaining gold usable for a bet.
		 *
		 * @return The gold amount.
		 */
		Integer GetAvailableGoldForBet(Boolean _WithBlitz) {
			declare Integer ActionCastleId = GetAction().Z;
			declare Integer BlitzGold;
			if (_WithBlitz && HasBlitzed() && IsCastleCapital(ActionCastleId)) {
				BlitzGold = C_BlitzGold;
			}
			return GetInputPlayerGold() - World_CountCastlesGoldAdditions() - GetTotalGoldDonation() - BlitzGold;
		}

		// ---------------------------------- //
		/**
		 * Gets the remaining gold usable for a bet.
		 *
		 * @return The gold amount.
		 */
		Integer GetAvailableGoldForBet() {
			return GetAvailableGoldForBet(False);
		}

		Void DrawTakeQuads() {

			if (GetInputPlayerCastles().count == 0) return;

			declare netread Integer[] Srv_UI_P_PossibleCastlesForAction for InputPlayer;
			declare Integer ActionCastleId = GetAction().Z;

			HideAllActionHelperQuads();

			foreach (CastleId in Srv_UI_P_PossibleCastlesForAction) {
				
				declare CMlFrame	CastleFrameInstance	= GetCastleInstance(CastleId);
				
				if (GetCastleOwnerId(CastleId) != -1) {
					// The castle is owned.

					if (IsCastleCapital(CastleId) && !IsCastleAccessible(CastleId, GetInputPlayerId())) {
						if (BlitzAllowed() && GetAvailableGoldForBet(False) >= C_BlitzGold) {
							declare CMlQuad		CastleBlitzTextQuad		= CFI_GetCastleBlitzTextQuad(CastleFrameInstance);
							declare CMlQuad		CastleBlitzArrowQuad	= CFI_GetCastleBlitzArrowQuad(CastleFrameInstance);

							if (ActionCastleId != CastleId && !IsReady()) {
								CastleBlitzTextQuad.Show();
								CastleBlitzArrowQuad.Show();
							} else {
								CastleBlitzTextQuad.Hide();
								CastleBlitzArrowQuad.Hide();
							}
						}
					} else {
						declare CMlQuad		CastleAttackTextQuad	= CFI_GetCastleAttackTextQuad(CastleFrameInstance);
						declare CMlQuad		CastleAttackArrowQuad	= CFI_GetCastleAttackArrowQuad(CastleFrameInstance);

						if (ActionCastleId != CastleId && !IsReady()) {
							CastleAttackTextQuad.Show();
							CastleAttackArrowQuad.Show();
						} else {
							CastleAttackTextQuad.Hide();
							CastleAttackArrowQuad.Hide();
						}
					}

				} else {
					// The castle isn't owned.

					declare CMlQuad		CastleTakeTextQuad		= CFI_GetCastleTakeTextQuad(CastleFrameInstance);
					declare CMlQuad		CastleTakeArrowQuad		= CFI_GetCastleTakeArrowQuad(CastleFrameInstance);

					if (ActionCastleId != CastleId && !IsReady()) {
						CastleTakeTextQuad.Show();
						CastleTakeArrowQuad.Show();
					} else {
						CastleTakeTextQuad.Hide();
						CastleTakeArrowQuad.Hide();
					}

				}

			}

		}

		Boolean IsCastleSelected(CMlFrame _CastleFrameInstance) {
			declare Integer ActionCastleId = GetAction().Z;
			return (CFI_GetCastleId(_CastleFrameInstance) == ActionCastleId);
		}

		Void HoverInCastle(CMlFrame _CastleFrameInstance) {
			declare CMlFrame HoveredCastleFrameInstance for This;
			declare CMlFrame OldHoveredCastleFrameInstance for This;

			OldHoveredCastleFrameInstance = HoveredCastleFrameInstance;
			HoveredCastleFrameInstance = _CastleFrameInstance;

			if (_CastleFrameInstance != Null) Audio.PlaySoundEvent(CAudioManager::ELibSound::Focus, 3, 0.);
		}

		Void Dbg_LogControl(CMlControl _Control, Integer _Indentation) {
			declare Text ToLog;

			for (I, 0, _Indentation - 1) {
				ToLog ^= "|- ";
			}

			switchtype (_Control) {
				case CMlFrame: {
					declare CMlFrame Frame = (_Control as CMlFrame);
					log(ToLog ^ "CMlFrame " ^ _Control.ControlId);
					foreach (Child in Frame.Controls) {
						Dbg_LogControl(Child, _Indentation + 1);
					}
				}
				case CMlLabel: {
					log(ToLog ^ "CMlLabel " ^ _Control.ControlId);
				}
				case CMlQuad: {
					log(ToLog ^ "CMlQuad " ^ _Control.ControlId);
				}
			}
		}

		// ---------------------------------- //
		/**
		 * Checks if the action can be sent (only works for the local player).
		 *
		 * @param _Action The action to check.
		 * @return True if the action can be sent, else otherwise.
		 */
		Boolean IsActionValid(Int3 _Action) {
			declare netread Integer[] Srv_UI_P_PossibleCastlesForAction for InputPlayer;
			declare Integer AimedCastleId = _Action.Z;
			declare Boolean HasEnoughGold = True;

			if (IsCastleCapital(AimedCastleId)) {
				if (!IsCastleAccessible(AimedCastleId, _Action.X)) {
					// Blitz.
					HasEnoughGold = BlitzAllowed() && GetAvailableGoldForBet(False) >= C_BlitzGold;
				} else {
					// Not a blitz.
					HasEnoughGold = (GetPlayerGold(_Action.X) >= C_GoldAmountForCapitals);
				}
			}

			return (Srv_UI_P_PossibleCastlesForAction.exists(_Action.Z) && HasEnoughGold);
		}

		// ---------------------------------- //
		/**
		 * Gets the local player's bet gold amount.
		 *
		 * @return The gold amount.
		 */
		Integer GetBet() {
			declare netwrite Integer Cli_Player_P_Bet for UI;
			return Cli_Player_P_Bet;
		}
		
		declare CMlControl[Integer][Ident] G_Cache_CastleControls;

		Void Animate() {

			// ---------------------------------- //
			// Rotables.

			Page.GetClassChildren("rotable", Page.MainFrame, True);
			foreach (Control in Page.GetClassChildren_Result) {
				if (!Control.Visible) continue;

				declare Real RotationVariable = TL::ToReal(Control.DataAttributeGet("rotvar"));

				Control.RelativeRotation += RotationVariable * Period / 8.;
			}
			
			// ---------------------------------- //
			// Scalables.

			Page.GetClassChildren("scalable", Page.MainFrame, True);
			foreach (Control in Page.GetClassChildren_Result) {
				if (!Control.Visible) continue;

				declare Real ScaleOrigin = TL::ToReal(Control.DataAttributeGet("scaleorig"));
				declare Real ScaleVariable = TL::ToReal(Control.DataAttributeGet("scalevar"));

				Control.RelativeScale = ScaleOrigin + (ML::Sin(Now / 500.) + 1) * ScaleVariable;
			}
			
			// ---------------------------------- //
			// Circle waves.
			HideAllCircleWaves();
			declare netread Integer[] Srv_UI_P_PossibleCastlesForAction for InputPlayer;
			
			declare Integer ActionCastleId = GetAction().Z;
			if (ActionCastleId != -1 && Srv_UI_P_PossibleCastlesForAction.exists(ActionCastleId)) {
				declare CMlFrame CFI = GetCastleInstance(ActionCastleId);
				declare CMlFrame CircleWavesFrame = CFI_GetCircleWavesFrame(CFI);
				CircleWavesFrame.Show();
			}
			
			// ---------------------------------- //
			// Castle frames intances.

			declare netread Boolean				Srv_Action_P_CanSendActions					for InputPlayer;
			declare netwrite Integer[Integer]	Cli_World_P_CastleDefenseGoldAddition		for UI;
			declare Integer						InputPlayerId = GetInputPlayerId();

			declare netread Integer				Srv_World_G_BonusCastle						for Teams[0];
			
			declare Integer						Cli_World_L_YearChangeTimestamp				for This;
			declare netread Integer[Integer]	Srv_World_G_CastleDefenseGoldAmounts		for Teams[0];

			declare Integer						Cli_UI_L_HistoryEventHighlightCastleId		for UI;

			declare Integer[]					Cli_UI_L_LastHighlightedEmpires				for UI;
			declare Integer						Cli_UI_L_LastHighlightedEmpiresTimestamp	for UI;

			declare Integer						Cli_UI_L_ActionRefreshedTimestamp			for UI;

			
			declare CastleFrameInstances = GetCastleFrameInstances();
			foreach (CastleFrameInstance in CastleFrameInstances) {
				declare Integer		CastleId				= CFI_GetCastleId(CastleFrameInstance);
				if (CastleId == -1) continue;
				declare Integer		OwnerId					= GetCastleOwnerId(CastleId);
				
				// Really poor perf
				/*
				declare CMlFrame	CircleWavesFrame		= CFI_GetCircleWavesFrame(CastleFrameInstance);
				declare CMlQuad		Reticle					= CFI_GetCastleReticle(CastleFrameInstance);
				declare CMlFrame	CastleDefenseGoldFrame	= CFI_GetCastleDefenseGoldFrame(CastleFrameInstance);
				declare CMlLabel	CastleDefenseGoldLabel	= CFI_GetCastleDefenseGoldLabel(CastleFrameInstance);
				declare CMlLabel	CastleGoldIncomeLabel	= CFI_GetCastleGoldIncomeLabel(CastleFrameInstance);
				declare CMlQuad		CastleHaloQuad			= CFI_GetCastleHaloQuad(CastleFrameInstance);
				declare CMlQuad		CastleFlagQuad			= CFI_GetFlagQuad(CastleFrameInstance);
				declare CMlQuad		CastleFlagCutQuad		= CFI_GetFlagCutQuad(CastleFrameInstance);
				*/
				declare CMlFrame CircleWavesFrame;
				declare	CMlQuad Reticle;
				declare CMlFrame CastleDefenseGoldFrame;
				declare CMlLabel CastleDefenseGoldLabel;
				declare CMlLabel CastleGoldIncomeLabel;
				declare CMlQuad CastleFlagQuad;
				declare CMlQuad CastleHaloQuad;
				declare CMlQuad CastleFlagCutQuad;
				if (G_Cache_CastleControls.existskey(CastleFrameInstance.Id)) {
					CircleWavesFrame <=> (G_Cache_CastleControls[CastleFrameInstance.Id][0] as CMlFrame);
					Reticle <=> (G_Cache_CastleControls[CastleFrameInstance.Id][1] as CMlQuad);
					CastleDefenseGoldFrame <=> (G_Cache_CastleControls[CastleFrameInstance.Id][2] as CMlFrame);
					CastleDefenseGoldLabel <=> (G_Cache_CastleControls[CastleFrameInstance.Id][3] as CMlLabel);
					CastleGoldIncomeLabel <=> (G_Cache_CastleControls[CastleFrameInstance.Id][4] as CMlLabel);
					CastleFlagQuad <=> (G_Cache_CastleControls[CastleFrameInstance.Id][5] as CMlQuad);
					CastleHaloQuad <=> (G_Cache_CastleControls[CastleFrameInstance.Id][6] as CMlQuad);
					CastleFlagCutQuad <=> (G_Cache_CastleControls[CastleFrameInstance.Id][7] as CMlQuad);
				} else {
					CircleWavesFrame <=> (CastleFrameInstance.GetFirstChild("circlewaves") as CMlFrame);
					Reticle <=> (CastleFrameInstance.GetFirstChild("reticle") as CMlQuad);
					CastleDefenseGoldFrame <=> (CastleFrameInstance.GetFirstChild("defensegold") as CMlFrame);
					CastleDefenseGoldLabel <=> (CastleFrameInstance.GetFirstChild("defensegoldtext") as CMlLabel);
					CastleGoldIncomeLabel <=> (CastleFrameInstance.GetFirstChild("goldincome") as CMlLabel);
					CastleHaloQuad <=> (CastleFrameInstance.GetFirstChild("halo") as CMlQuad);
					CastleFlagQuad <=> (CastleFrameInstance.GetFirstChild("flag") as CMlQuad);
					CastleFlagCutQuad <=> (CastleFrameInstance.GetFirstChild("flagcut") as CMlQuad);
					G_Cache_CastleControls[CastleFrameInstance.Id] = CMlControl[Integer];
					G_Cache_CastleControls[CastleFrameInstance.Id][0] <=> CircleWavesFrame;
					G_Cache_CastleControls[CastleFrameInstance.Id][1] <=> Reticle;
					G_Cache_CastleControls[CastleFrameInstance.Id][2] <=> CastleDefenseGoldFrame;
					G_Cache_CastleControls[CastleFrameInstance.Id][3] <=> CastleDefenseGoldLabel;
					G_Cache_CastleControls[CastleFrameInstance.Id][4] <=> CastleGoldIncomeLabel;
					G_Cache_CastleControls[CastleFrameInstance.Id][5] <=> CastleHaloQuad;
					G_Cache_CastleControls[CastleFrameInstance.Id][6] <=> CastleFlagQuad;
					G_Cache_CastleControls[CastleFrameInstance.Id][7] <=> CastleFlagCutQuad;
				}
				
				if (CastleId == Cli_UI_L_HistoryEventHighlightCastleId) {
					Reticle.Colorize = <1., 1., 1.>;
					Reticle.Show();
				} else {
					Reticle.Hide();
				}
				
				if (CastleId == ActionCastleId) {
					CastleFlagQuad.Opacity = AL::EaseOutExp(Now - Cli_UI_L_ActionRefreshedTimestamp, 0., 1., C_FlagAnimationDuration);
					CastleFlagQuad.RelativePosition.X = AL::EaseLinear(Now - Cli_UI_L_ActionRefreshedTimestamp, 4., -4., C_FlagAnimationDuration);
					CastleFlagQuad.RelativePosition.Y = AL::EaseLinear(Now - Cli_UI_L_ActionRefreshedTimestamp, 4., -4., C_FlagAnimationDuration);

					CastleFlagCutQuad.Opacity = AL::EaseOutExp(Now - Cli_UI_L_ActionRefreshedTimestamp - C_FlagAnimationDuration / 2, 0., 1., C_FlagAnimationDuration / 2);
				} else {
					CastleFlagQuad.Opacity = 0.;
					CastleFlagCutQuad.Opacity = 0.;
				}
				
				if (OwnerId != -1) {

					if (Cli_UI_L_LastHighlightedEmpires.exists(OwnerId)) {
						CastleHaloQuad.RelativeScale = AL::EaseOutBack(Now - Cli_UI_L_LastHighlightedEmpiresTimestamp, C_OwnedCastleHaloScale, 1., C_EmpireHighlightAnimationDuration);
					} else if (OwnerId != -1) {
						CastleHaloQuad.RelativeScale = C_OwnedCastleHaloScale;
					} else {
						CastleHaloQuad.RelativeScale = C_NotOwnedCastleHaloScale;
					}

					if (OwnerId == InputPlayerId) {


						if (CastleId == Srv_World_G_BonusCastle) {
							CastleGoldIncomeLabel.SetText("+" ^ (C_GoldPerCastlePerYear * 3));
						} else {
							CastleGoldIncomeLabel.SetText("+" ^ C_GoldPerCastlePerYear);
						}

						if (Now - Cli_World_L_YearChangeTimestamp - C_GoldIncomeLabelAnimShift >= 0) {
							if (Now - Cli_World_L_YearChangeTimestamp - C_GoldIncomeLabelAnimShift < C_GoldIncomeLabelAnimDuration / 4) {
								CastleGoldIncomeLabel.Show();
								CastleGoldIncomeLabel.RelativePosition.X = 0.;
								CastleGoldIncomeLabel.RelativePosition.Y = AL::EaseOutSine(Now - Cli_World_L_YearChangeTimestamp - C_GoldIncomeLabelAnimShift, 8., 2., C_GoldIncomeLabelAnimDuration / 4);

								CastleGoldIncomeLabel.Opacity = 1.;
							} else if (Now - Cli_World_L_YearChangeTimestamp - C_GoldIncomeLabelAnimShift - C_GoldIncomeLabelAnimDuration / 4 < C_GoldIncomeLabelAnimDuration / 4 * 3) {
								CastleGoldIncomeLabel.Show();
								declare Vec3 OriginalCastleAbsolutePos for CastleFrameInstance;

								declare Real Value = AL::EaseInSine(Now - Cli_World_L_YearChangeTimestamp - C_GoldIncomeLabelAnimShift - C_GoldIncomeLabelAnimDuration / 4, 0., 1., C_GoldIncomeLabelAnimDuration / 4 * 3);

								CastleGoldIncomeLabel.RelativePosition.X = AL::EaseInSine(Now - Cli_World_L_YearChangeTimestamp - C_GoldIncomeLabelAnimShift - C_GoldIncomeLabelAnimDuration / 4, 0., C_GoldMoveAimPos.X, C_GoldIncomeLabelAnimDuration / 4 * 3) - OriginalCastleAbsolutePos.X * Value;
								CastleGoldIncomeLabel.RelativePosition.Y = AL::EaseInSine(Now - Cli_World_L_YearChangeTimestamp - C_GoldIncomeLabelAnimShift - C_GoldIncomeLabelAnimDuration / 4, 10., C_GoldMoveAimPos.Y - 10., C_GoldIncomeLabelAnimDuration / 4 * 3) - OriginalCastleAbsolutePos.Y * Value;

								CastleGoldIncomeLabel.Opacity = AL::EaseInSine(Now - Cli_World_L_YearChangeTimestamp - C_GoldIncomeLabelAnimShift - C_GoldIncomeLabelAnimDuration / 2, 1., -1., C_GoldIncomeLabelAnimDuration / 4 * 3);

							} else {
								declare Vec3 OriginalCastleAbsolutePos for CastleFrameInstance;
								OriginalCastleAbsolutePos = CastleFrameInstance.AbsolutePosition;
								CastleGoldIncomeLabel.Opacity = 0.;
								CastleGoldIncomeLabel.Hide();
							}
						} else {
							CastleGoldIncomeLabel.Hide();
						}
					}
				}
				
				declare Vec3 TextColor = <1., 0.667, 0.>;
				
				CastleDefenseGoldFrame.Show();

				if (OwnerId == GetInputPlayerId()) {
					// This castle is owned by the local player.

					if (IsCastleCapital(CastleId)) {
						// This castle is a capital.
						CastleDefenseGoldFrame.Hide();
					} else {
						// This castle isn't a capital.
						if (Cli_World_P_CastleDefenseGoldAddition.existskey(CastleId) && Cli_World_P_CastleDefenseGoldAddition[CastleId] > 0) {
							// The local player put more gold on this castle.
							CastleDefenseGoldLabel.SetText(TL::ToText(Srv_World_G_CastleDefenseGoldAmounts[CastleId] + World_GetCastleGoldAdditions(CastleId)));
							
							declare Real Factor = (ML::Sin(Now / 100.) + 1) / 2.;
							declare Vec3 HighlightColor	= <1., 0.97, 0.5>;
							TextColor = TextColor - (TextColor - HighlightColor) * Factor;
						} else {
							// The local player did not put more gold on this castle.
							CastleDefenseGoldLabel.SetText(TL::ToText(Srv_World_G_CastleDefenseGoldAmounts[CastleId]));
						}
					}

				} else {
					// This castle isn't owned by the local player.

					if (GetAction().Z == CastleId) {
						// This castle is aimed by the player.
						if (IsCastleCapital(CastleId)) {
							// This castle is a capital.
							CastleDefenseGoldFrame.Hide();
						} else {
							// This castle isn't a capital.
							declare Real Factor = (ML::Sin(Now / 100.) + 1) / 2.;
							declare Vec3 HighlightColor	= <1., 0.97, 0.5>;

							if (OwnerId > -1) {
								// This castle is owned by someone.
								CastleDefenseGoldLabel.SetText("$<$F04" ^ GetBet() ^ "$> / " ^ Srv_World_G_CastleDefenseGoldAmounts[CastleId]);
							} else {
								// This castle isn't owned.
								CastleDefenseGoldLabel.SetText("$F04" ^ GetBet());
							}

							TextColor = TextColor - (TextColor - HighlightColor) * Factor;
						}
					} else {
						// This castle isn't aimed by the player.
						if (OwnerId == -1) {
							// This castle isn't owned.
							CastleDefenseGoldFrame.Hide();
						} else {
							// This castle is owned.
							if (IsCastleCapital(CastleId)) {
								// This castle is a capital.
								CastleDefenseGoldFrame.Hide();
							} else {
								// This castle isn't a capital.
								CastleDefenseGoldLabel.SetText(TL::ToText(Srv_World_G_CastleDefenseGoldAmounts[CastleId]));
							}
						}
					}

				}
				
				CastleDefenseGoldLabel.TextColor = TextColor;

				if (!CircleWavesFrame.Visible) continue;

				declare CMlFrame	CircleWave1			= CFI_GetFirstCircleWave(CastleFrameInstance);
				declare CMlQuad		CircleWaveQuad1		= CWFI_GetCircleWaveQuad(CircleWave1);
				declare CMlFrame	CircleWave2			= CFI_GetSecondCircleWave(CastleFrameInstance);
				declare CMlQuad		CircleWaveQuad2		= CWFI_GetCircleWaveQuad(CircleWave2);

				declare Vec3 Colorization = <0.333, 0.667, 1.>;
				if (OwnerId != -1) Colorization = <1., 0., 0.>;

				declare Integer Time = Now - Cli_UI_L_ActionRefreshedTimestamp;

				CircleWave1.RelativeScale = (Time % 2000) / 1000.;
				CircleWaveQuad1.Opacity = AL::EaseInCubic(ML::NearestInteger(CircleWave1.RelativeScale * 1000), 1., -1., 2000);
				CircleWaveQuad1.Colorize = Colorization;
				CircleWave2.RelativeScale = ((Time + 500) % 2000) / 1000.;
				CircleWaveQuad2.Opacity = AL::EaseInCubic(ML::NearestInteger(CircleWave2.RelativeScale * 1000), 1., -1., 2000);
				CircleWaveQuad2.Colorize = Colorization;
			}
			
			// ---------------------------------- //
			// Hovered castle frame instance.

			declare CMlFrame HoveredCastleFrameInstance for This;
			declare CMlFrame OldHoveredCastleFrameInstance for This;
			
			declare Integer Cli_UI_L_LastActionForRulesTip	for UI;
			if(Cli_UI_L_LastActionForRulesTip < 0) Cli_UI_L_LastActionForRulesTip = 0;

			if (HoveredCastleFrameInstance != Null) {

				declare Integer		CastleId				= CFI_GetCastleId(HoveredCastleFrameInstance);
				declare CMlLabel	CastleNameLabel			= CFI_GetCastleNameLabel(HoveredCastleFrameInstance);
				declare CMlQuad		Reticle					= CFI_GetCastleReticle(HoveredCastleFrameInstance);

				CastleNameLabel.RelativeScale = 1.2;
				if (Srv_Action_P_CanSendActions) {
					Reticle.Show();
					declare Vec3 Color = <0.2, 0.2, 0.2>;
					Cli_UI_L_LastActionForRulesTip = 5;
					
					if (Srv_UI_P_PossibleCastlesForAction.exists(CastleId)) {
						if (!IsCastleOwned(CastleId)) {
							Color = <0.333, 0.667, 1.>;
							Cli_UI_L_LastActionForRulesTip = 3;
						} else {
							Color = <1., 0., 0.>;
							if(IsCastleCapital(CastleId)) 	Cli_UI_L_LastActionForRulesTip = 2;
							else 							Cli_UI_L_LastActionForRulesTip = 1;
						}
					} else if (GetCastleOwnerId(CastleId) == GetInputPlayerId() && !IsCastleCapital(CastleId)) {
						Color = <0.333, 0.667, 1.>;
						Cli_UI_L_LastActionForRulesTip = 4;
					}
					
					if (IsCastleCapital(CastleId)) {
						if(GetCastleOwnerId(CastleId) == GetInputPlayerId()) {
							Cli_UI_L_LastActionForRulesTip = 7;
						} else {
							// TODO HERE EG : distinguer les capitales des vassaux de celles des opponents.
							// et mettre des valeurs dynamiques, genre nb de planÃ¨tes de l'opponent, pour donner des conseils ?
							// genre "attaquez-le et vous gagnez" ?
							Cli_UI_L_LastActionForRulesTip = 8;
						}
					}

					Reticle.Colorize = Color;

				} else {
					Reticle.Hide();
				}
			}
			
			if (OldHoveredCastleFrameInstance != Null) {
				declare CMlLabel CastleNameLabel = CFI_GetCastleNameLabel(OldHoveredCastleFrameInstance);
				CastleNameLabel.RelativeScale = 1.;
			}

			// ---------------------------------- //
			// Highlighted links.

			declare netread Integer		Srv_UI_G_HighlightedLinksTimestamp		for Teams[0];
			declare Integer				Cli_UI_L_LastHighlightedLinksTimestamp	for UI;

			Cli_UI_L_LastHighlightedLinksTimestamp = Srv_UI_G_HighlightedLinksTimestamp;
			
			declare netread Int3[]	Srv_UI_G_HighlightedLinks				for Teams[0];

			foreach (LinkHighlighter in Srv_UI_G_HighlightedLinks) {
				declare Integer		LinkId			= LinkHighlighter.X;
				declare Integer		PlayerId		= LinkHighlighter.Y;

				declare CMlFrame	LinkInstance	= GetLinkInstance(LinkId);
				declare CMlQuad		LinkFrontImage	= LFI_GetLinkFrontImage(LinkInstance);

				declare Vec3		Color			= GetLinkColor(PlayerId);
				declare Real		Factor			= (ML::Sin(Now / 100.) + 1) / 2.;

				LinkFrontImage.Show();
				LinkFrontImage.Colorize = <1., 1., 1.>;
				LinkFrontImage.Colorize.X -= (1 - Color.X) * (1 - Factor);
				LinkFrontImage.Colorize.Y -= (1 - Color.Y) * (1 - Factor);
				LinkFrontImage.Colorize.Z -= (1 - Color.Z) * (1 - Factor);
				LinkFrontImage.Size.Y = C_BaseLinkSize * 0.25 + Factor;
			}

			// ---------------------------------- //
			// Highlighted castle.

			declare Integer				Cli_UI_L_HighlightedCastle				for UI;
			declare Integer				Cli_UI_L_LastHighlightedCastle			for UI;
			declare Integer				Cli_UI_L_LastHighlightedCastleTimestamp	for UI;

			declare Vec3 Cli_UI_L_OriginHighlightedCastleCastlePos	for UI;
			declare netread Integer Srv_UI_G_ZoomTimestamp			for Teams[0];
			declare Integer Cli_UI_L_LastZoomTimestamp				for Teams[0];
			
			if (Cli_UI_L_HighlightedCastle != -1) {

				declare CMlFrame CastleFrameInstance = GetCastleInstance(Cli_UI_L_HighlightedCastle);

				if (Cli_UI_L_HighlightedCastle != Cli_UI_L_LastHighlightedCastle) {
					Cli_UI_L_LastHighlightedCastle = Cli_UI_L_HighlightedCastle;
					Cli_UI_L_OriginHighlightedCastleCastlePos = CastleFrameInstance.RelativePosition;
				}

				declare Real CastleScale = AL::EaseOutExp(Now - Cli_UI_L_LastHighlightedCastleTimestamp, 1., 1.25, C_CastleHighlighterFadeDuration);
				declare Vec3 CastlePos = Cli_UI_L_OriginHighlightedCastleCastlePos;

				CastlePos.Z = C_CastlePosZHighlighted;

				CastleFrameInstance.RelativeScale		= CastleScale;
				CastleFrameInstance.RelativePosition	= CastlePos;

			} else {

				if (Cli_UI_L_LastHighlightedCastle != -1) {

					declare CMlFrame LastCastleFrameInstance = GetCastleInstance(Cli_UI_L_LastHighlightedCastle);

					if (LastCastleFrameInstance != Null) {
						LastCastleFrameInstance.RelativeScale = AL::EaseOutExp(Now - Cli_UI_L_LastHighlightedCastleTimestamp, 1.25, -0.25, C_CastleHighlighterFadeDuration);
						LastCastleFrameInstance.RelativePosition.Z = C_CastlePosZNormal;
					}

				}

			}
			
			// ---------------------------------- //
			// Highlighter black background.

			declare Boolean	Cli_UI_L_HighlighterStatus		for UI;
			declare Integer	Cli_UI_L_HighlighterTimestamp	for UI;

			declare CMlQuad CastleHighlighterBg = GetCastleHighlighterBg();

			if (Cli_UI_L_HighlighterStatus) {

				CastleHighlighterBg.Opacity = AL::EaseOutExp(Now - Cli_UI_L_HighlighterTimestamp, 0., 0.75, C_CastleHighlighterFadeDuration);

			} else {

				CastleHighlighterBg.Opacity = AL::EaseOutExp(Now - Cli_UI_L_HighlighterTimestamp, 0.75, -0.75, C_CastleHighlighterFadeDuration);

			}

			// ANIMATE END

		}

		Integer GetCurrentActionType() {
			return 0;
		}

		Int3 CreateAction(CMlFrame _CastleFrameInstance) {
			declare Int3 Action;
			Action.X = GetInputPlayerId();
			Action.Y = GetCurrentActionType();
			Action.Z = CFI_GetCastleId(_CastleFrameInstance);
			return Action;
		}

		Integer CountCastles() {
			declare netread Text[] Srv_World_G_Castles for Teams[0];
			return Srv_World_G_Castles.count;
		}

		Boolean CanSendActions() {
			declare netread Boolean		Srv_Action_P_CanSendActions	for InputPlayer;
			declare netwrite Boolean	Cli_Player_P_Ready			for UI;
			return Srv_Action_P_CanSendActions && !Cli_Player_P_Ready && GetInputPlayerCastles().count > 0;
		}

		Integer GetGamePhase() {
			declare netread Integer Srv_Game_G_Phase for Teams[0];
			return Srv_Game_G_Phase;
		}

		// ---------------------------------- //
		/**
		 * Get the server's player logins.
		 *
		 * @return The players.
		 */
		Text[Integer] GetPlayers() {
			declare netread Text[Integer] Srv_Player_G_Players for Teams[0];
			return Srv_Player_G_Players;
		}

		// ---------------------------------- //
		/**
		 * Checks if there are players initialized.
		 *
		 * @return True if players are initialized, False otherwise.
		 */
		Boolean ArePlayersInitialized() {
			return (GetPlayers().count > 0);
		}

		Boolean IsSpec() {
			return (GetInputPlayerId() == -1);
		}

		Void Init() {
			while (InputPlayer == Null) { yield; }
			while (InputPlayer.User == Null) { yield; }
			while (!ArePlayersInitialized()) { yield; }
			declare Integer CastleInstancesCount = GetCastleFrameInstances().count;
			while (CountCastles() != CastleInstancesCount) { yield; }

			G_CastlesDrawn = False;
			G_LinksDrawn = False;
			
			declare Integer	Cli_UI_L_GaugeCastleId			for UI;
			declare Integer	Cli_UI_L_HighlightedCastle		for UI;
			declare Integer	Cli_UI_L_LastHighlightedCastle	for UI;
			declare	Boolean Cli_UI_L_LastReady				for UI;

			Cli_UI_L_GaugeCastleId			= -1;
			Cli_UI_L_HighlightedCastle		= -1;
			Cli_UI_L_LastHighlightedCastle	= -1;
			Cli_UI_L_LastReady = True;

			declare CMlFrame HoveredCastleFrameInstance for This;
			declare CMlFrame OldHoveredCastleFrameInstance for This;
			
			HoveredCastleFrameInstance		= Null;
			OldHoveredCastleFrameInstance	= Null;

			World_ResetAllCastlesGoldAddition();

			HoverInCastle(Null);

			DrawCastles(True);
			DrawLinks();
			HideAllActionHelperQuads();

			ClearAction();
		}

		/**
		 * Checks the events sent by the server and do the asked work (Dump the action slot, update the display).
		 */
		Void LoopStart() {
			declare netread	Integer Srv_Action_P_ClearActionTimestamp			for InputPlayer;
			declare			Integer LastClearActionTimeStamp					for This;
			declare			Integer	Cli_UI_L_GaugeCastleId						for UI;

			if (Srv_Action_P_ClearActionTimestamp != LastClearActionTimeStamp) {
				LastClearActionTimeStamp = Srv_Action_P_ClearActionTimestamp;
				ClearAction();
				Cli_UI_L_GaugeCastleId = -1;
			}

			// ---------------------------------- //

			declare netread	Integer Srv_UI_P_UpdateCastlesTimestamp				for UI;
			declare			Integer LastUpdateCastlesTimestamp					for This;

			if (Srv_UI_P_UpdateCastlesTimestamp != LastUpdateCastlesTimestamp) {
				LastUpdateCastlesTimestamp = Srv_UI_P_UpdateCastlesTimestamp;
				DrawCastles();
			}

			// ---------------------------------- //

			declare netread	Integer Srv_UI_P_UpdateLinksTimestamp				for UI;
			declare			Integer LastUpdateLinksTimestamp					for This;

			if (Srv_UI_P_UpdateLinksTimestamp != LastUpdateLinksTimestamp) {
				LastUpdateLinksTimestamp = Srv_UI_P_UpdateLinksTimestamp;
				DrawLinks();
			}

			// ---------------------------------- //

			declare netread	Boolean Srv_UI_G_StartPointsVisibility				for Teams[0];
			declare			Boolean LastStartPointsVisibility					for This;

			if (Srv_UI_G_StartPointsVisibility != LastStartPointsVisibility) {
				LastStartPointsVisibility = Srv_UI_G_StartPointsVisibility;
				DrawCastles();
			}

			// ---------------------------------- //

			declare Integer Cli_UI_L_ActionRefreshedTimestamp		for UI;
			declare Integer Cli_UI_L_LastActionRefreshedTimestamp	for This;

			if (Cli_UI_L_LastActionRefreshedTimestamp != Cli_UI_L_ActionRefreshedTimestamp) {
				Cli_UI_L_LastActionRefreshedTimestamp = Cli_UI_L_ActionRefreshedTimestamp;
				DrawTakeQuads();
			}

			// ---------------------------------- //

			declare netread		Integer Srv_UI_P_PossibleCastlesForActionTimestamp		for InputPlayer;
			declare				Integer Cli_UI_L_LastPossibleCastlesForActionTimestamp	for UI;

			if (Srv_UI_P_PossibleCastlesForActionTimestamp != Cli_UI_L_LastPossibleCastlesForActionTimestamp) {
				DrawTakeQuads();
				Cli_UI_L_LastPossibleCastlesForActionTimestamp = Srv_UI_P_PossibleCastlesForActionTimestamp;
			}

			// ---------------------------------- //

			declare Integer Cli_UI_L_ReadyChangeTimestamp		for UI;
			declare Integer Cli_UI_L_LastReadyChangeTimestamp	for UI;
			if (Cli_UI_L_LastReadyChangeTimestamp != Cli_UI_L_ReadyChangeTimestamp) {
				Cli_UI_L_LastReadyChangeTimestamp = Cli_UI_L_ReadyChangeTimestamp;
				DrawTakeQuads();
			}

			// ---------------------------------- //

			declare Integer Cli_UI_L_RefreshTakeQuads				for UI;
			declare Integer Cli_UI_L_LastRefreshTakeQuads			for This;

			if (Cli_UI_L_LastRefreshTakeQuads != Cli_UI_L_RefreshTakeQuads) {
				Cli_UI_L_LastRefreshTakeQuads = Cli_UI_L_RefreshTakeQuads;
				DrawTakeQuads();
			}
			
			// ---------------------------------- //

			declare netread Integer		Srv_UI_G_HighlightedCastle				for Teams[0];
			declare Integer				Cli_UI_L_HighlightedCastle				for UI;
			declare Integer				Cli_UI_L_LastHighlightedCastleTimestamp	for UI;

			if (Cli_UI_L_HighlightedCastle != Srv_UI_G_HighlightedCastle) {
				Cli_UI_L_HighlightedCastle = Srv_UI_G_HighlightedCastle;
				Cli_UI_L_LastHighlightedCastleTimestamp = Now;
			}

			// ---------------------------------- //

			declare netread	Boolean	Srv_UI_G_HighlighterStatus	for Teams[0];
			declare Boolean	Cli_UI_L_HighlighterStatus			for UI;

			if (Cli_UI_L_HighlighterStatus != Srv_UI_G_HighlighterStatus) {
				declare Integer	Cli_UI_L_HighlighterTimestamp	for UI;
				Cli_UI_L_HighlighterTimestamp = Now;

				Cli_UI_L_HighlighterStatus = Srv_UI_G_HighlighterStatus;
			}

			// ---------------------------------- //

			declare netread Integer Srv_World_P_DefenseGoldAdditionClearTimestamp		for InputPlayer;
			declare Integer Cli_World_L_LastDefenseGoldAdditionClearTimestamp			for UI;

			if (Cli_World_L_LastDefenseGoldAdditionClearTimestamp != Srv_World_P_DefenseGoldAdditionClearTimestamp) {
				Cli_World_L_LastDefenseGoldAdditionClearTimestamp = Srv_World_P_DefenseGoldAdditionClearTimestamp;
				World_ResetAllCastlesGoldAddition();
			}

			// ---------------------------------- //

			declare netread Integer	Srv_World_G_CurrentYear					for Teams[0];
			declare Integer			Cli_World_L_LastCurrentYear				for This;
			declare Integer			Cli_World_L_YearChangeTimestamp			for This;
			declare Boolean			Cli_UI_L_DelayGold						for UI;

			if (Srv_World_G_CurrentYear != Cli_World_L_LastCurrentYear) {
				Cli_World_L_YearChangeTimestamp = Now;
				Cli_World_L_LastCurrentYear = Srv_World_G_CurrentYear;
			}

			Cli_UI_L_DelayGold = (Now - Cli_World_L_YearChangeTimestamp < C_GoldIncomeLabelAnimDuration + C_GoldIncomeLabelAnimShift + 1000);


			// ---------------------------------- //

			declare netread Integer[]	Srv_UI_G_HighlightedEmpires					for Teams[0];
			declare Integer[]			Cli_UI_L_LastHighlightedEmpires				for UI;
			declare Integer				Cli_UI_L_LastHighlightedEmpiresTimestamp	for UI;

			declare Boolean Changed = False;

			if (Cli_UI_L_LastHighlightedEmpires.count == Srv_UI_G_HighlightedEmpires.count) {
				for (Index, 0, Srv_UI_G_HighlightedEmpires.count - 1) {
					if (Srv_UI_G_HighlightedEmpires[Index] != Cli_UI_L_LastHighlightedEmpires[Index]) {
						Changed = True;
						break;
					}
				}
			} else {
				Changed = True;
			}

			if (Changed) {
				Cli_UI_L_LastHighlightedEmpires = Srv_UI_G_HighlightedEmpires;
				Cli_UI_L_LastHighlightedEmpiresTimestamp = Now;
			}

		}

		main() {

			Init();
			
			if(C_DebugPosition) {
				Page.GetFirstChild("debugposition").Show();
			}
			
			while (True) {
				yield;
				
				if(C_DebugPosition) {
					declare CMlLabel Label_position = (Page.GetFirstChild("Label_position") as CMlLabel);
					Label_position.SetText(MouseX^"  :  "^MouseY);
				}

				LoopStart();

				Animate();

				if (!IsSpec()) {
					foreach (Event in PendingEvents) {
						switch (Event.Type) {
							case CMlEvent::Type::MouseOver: {
								switch (Event.ControlId) {

									case "focus": {
										// The control is a castle frame instance's focus.
										declare CMlQuad		QuadControl = (Event.Control as CMlQuad);
										declare CMlFrame	CastleFrameInstance = GetCastleFrameInstanceFromFocusQuad(QuadControl);
										if (CanSendActions()) HoverInCastle(CastleFrameInstance);
									}

								}
							}

							case CMlEvent::Type::MouseOut: {
								switch (Event.ControlId) {

									case "focus": {
										// The control is a castle frame instance's focus.
										declare CMlQuad		QuadControl			= (Event.Control as CMlQuad);
										declare CMlFrame	CastleFrameInstance	= GetCastleFrameInstanceFromFocusQuad(QuadControl);

										HoverInCastle(Null);
									}

								}
							}
							case CMlEvent::Type::MouseClick: {
								switch (Event.ControlId) {

									case "focus": {
										// The control is a castle frame instance's focus.
										declare CMlQuad		QuadControl			= (Event.Control as CMlQuad);
										declare CMlFrame	CastleFrameInstance	= GetCastleFrameInstanceFromFocusQuad(QuadControl);
										declare Integer		CastleId			= CFI_GetCastleId(CastleFrameInstance);

										if (CanSendActions()) {

											if (GetCastleOwnerId(CastleId) == GetInputPlayerId()) {
												// This castle is owned by the local player.

												if (GetGamePhase() != C_PhaseSetup && !IsCastleCapital(CastleId)) {
													
													// declare Integer Cli_UI_L_LastActionForRulesTip		for UI;
													// Cli_UI_L_LastActionForRulesTip = 4; // Defenses
													
													// For the gauge.
													declare Vec2	Cli_UI_L_GaugeClickPos				for UI;
													declare Integer	Cli_UI_L_GaugeSelectedCastleType	for UI;
													declare Integer	Cli_UI_L_GaugeCastleId				for UI;
													declare Integer	Cli_UI_L_CastleClickTimestamp		for UI;
													Cli_UI_L_GaugeClickPos = <CastleFrameInstance.AbsolutePosition.X, CastleFrameInstance.AbsolutePosition.Y>;
													Cli_UI_L_GaugeSelectedCastleType = 0;
													Cli_UI_L_GaugeCastleId = CastleId;
													Cli_UI_L_CastleClickTimestamp = Now;
												}

											} else {
												// This castle is not owned by the local player.
												declare Int3		Action				= CreateAction(CastleFrameInstance);

												if (IsActionValid(Action)) {
													SendAction(Action);
													Audio.PlaySoundEvent(CAudioManager::ELibSound::Focus, 1, 10.);

													if (GetGamePhase() != C_PhaseSetup) {
														// declare Integer Cli_UI_L_LastActionForRulesTip		for UI;
														
														// if(GetCastleOwnerId(CastleId) < 0) {
															// Cli_UI_L_LastActionForRulesTip = 3; // Take
														// } else if(IsCastleCapital(CastleId)) {
															// Cli_UI_L_LastActionForRulesTip = 2; // Battle
														// } else {
															// Cli_UI_L_LastActionForRulesTip = 1; // Assault
														// }
														// Cli_UI_L_LastActionForRulesTip = 8; // Action done : click "End turn"
														
														
													
														// For the gauge.
														declare Vec2	Cli_UI_L_GaugeClickPos				for UI;
														declare Integer	Cli_UI_L_GaugeSelectedCastleType	for UI;
														declare Integer	Cli_UI_L_GaugeCastleId				for UI;
														declare Integer	Cli_UI_L_CastleClickTimestamp		for UI;
														Cli_UI_L_GaugeClickPos = <CastleFrameInstance.AbsolutePosition.X, CastleFrameInstance.AbsolutePosition.Y>;
														Cli_UI_L_GaugeSelectedCastleType = 1;
														Cli_UI_L_GaugeCastleId = CastleId;
														Cli_UI_L_CastleClickTimestamp = Now;
													}

												} else {
													// declare Integer Cli_UI_L_LastActionForRulesTip		for UI;
													// Cli_UI_L_LastActionForRulesTip = 5; // Unreachable
													
													Audio.PlaySoundEvent(CAudioManager::ELibSound::Alert, 1, -10.);
												}
											}

										}
									}

								}
							}
						}
					}
				}

				// AFTER EVENTS

			}

			// AFTER MAIN LOOP

		}

	--></script>
</manialink>