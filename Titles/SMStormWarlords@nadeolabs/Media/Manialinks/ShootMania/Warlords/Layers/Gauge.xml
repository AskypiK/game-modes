<manialink version="2" name="{( LayerName )}">
	<framemodel id="gold">
		<label id="purpose" posn="7.5 3 2" sizen="20 5" halign="center" valign="center" style="TextTitle3" textsize="1" textcolor="FA0" text="Purpose" />
					
		<quad id="plusquad" posn="7.5 -5 2" sizen="15 5" halign="center" valign="bottom" image="file://Media/Manialinks/ShootMania/Warlords/Textures/Gauge/HPlus_Test1.png" colorize="fa0" scriptevents="1" />
		<quad id="plusgradbg" posn="7.5 -5 1" sizen="15 5" halign="center" valign="bottom" style="Bgs1" substyle="BgGradBottom" />
		
		<label id="infolabel" posn="7.5 -7.5 2" sizen="15 5" halign="center" valign="center" style="TextRaceChrono" textcolor="fa0" textsize="3" text="XXX" />
		<quad id="infobg" posn="7.5 -7.5 1" sizen="15 5" halign="center" valign="center" bgcolor="000" />
		
		<quad id="minusquad" posn="7.5 -10 2" sizen="15 5" halign="center" valign="top" image="file://Media/Manialinks/ShootMania/Warlords/Textures/Gauge/HMinus_Test1.png" colorize="fa0" scriptevents="1" />
		<quad id="minusgradbg" posn="7.5 -10 1" sizen="15 5" halign="center" valign="top" style="Bgs1" substyle="BgGradTop" />
		
		<quad id="shadow" posn="-5 5 0" sizen="25 25" style="Bgs1InRace" substyle="BgButtonShadow" scriptevents="1" />
	</framemodel>
	
	<framemodel id="player">
		<quad id="playergrad" posn="0 0 3" sizen="26 4" style="Bgs1InRace" substyle="BgGradTop" opacity="0.5"/>
		<quad id="playerfocus" posn="0 0 2" sizen="26 6" bgcolor="08f" opacity="0" scriptevents="1"/>
		<label id="playername" posn="1 -3 1" sizen="24 6" valign="center" textsize="1" text="player"/>
		<quad id="playerbg" posn="0 0 0" sizen="26 6" style="Bgs1" substyle="BgDialogBlur"/>
	</framemodel>

	<frame id="betframe" posn="0 0 -20">
		<quad id="betlight" posn="0 0" sizen="20 20" halign="center" valign="center" style="Bgs1" substyle="Glow" opacity="0" />
		
		<frame id="scaleframe">
			<frame id="gauges">
				<quad posn="0 0 5" sizen="0.5 28" bgcolor="FFFA" image="file://Media/Manialinks/ShootMania/Warlords/Textures/Gauge/Gradient.png" modulatecolor="fa0"/>
				<quad posn="0 0 5" sizen="0.5 28" bgcolor="FFFA" image="file://Media/Manialinks/ShootMania/Warlords/Textures/Gauge/Gradient.png" modulatecolor="fa0" rot="-90" halign="right"/>
				
				<frame posn="7 -8 1">
					<frameinstance id="assault" modelid="gold" />
					<label id="cancel" posn="8 -19.5 0" sizen="30 5" halign="center" valign="center2" style="TextButtonMedium" text="Cancel" textcolor="FA0" textsize="1" scriptevents="1"/>
	
					<quad id="separator" posn="23 8 0" sizen="0.5 30" bgcolor="0008" halign="center"/>

					<frameinstance id="defenses" modelid="gold" posn="30"/>
				</frame>
				
				<quad id="assblur" posn="0 0 0" sizen="30 30" style="Bgs1" substyle="BgDialogBlur" scriptevents="1"/>
				<quad id="defblur" posn="30 0 0" sizen="30 30" style="Bgs1" substyle="BgDialogBlur" scriptevents="1"/>
			</frame>
			
			<frame id="castledonation" posn="0 -30 0" hidden="1">
				<quad id="separator" posn="0 0 1" sizen="60 0.5" bgcolor="0008"/>
				
				<label posn="2 -5 0" sizen="26 5" valign="center" style="TextTitle3" text="Give planet to" textsize="1"/>
				<frame posn="32 -5">
					<quad id="btn-arrow" posn="20 0 1" sizen="6 6" style="Icons64x64_1" substyle="ArrowDown" valign="center" scriptevents="1"/>
					<label id="chosenplayerfordonation" posn="1 0 1" sizen="24 5" valign="center" text="..." textsize="1"/>
					<quad posn="0 0 0" sizen="26 6" valign="center" style="Bgs1" substyle="BgDialogBlur"/>
					<frame id="players" posn="0 -3 0" hidden="1">
						<frameinstance modelid="player" posn="0 0"/>
						<frameinstance modelid="player" posn="0 -6"/>
						<frameinstance modelid="player" posn="0 -12"/>
						<frameinstance modelid="player" posn="0 -18"/>
						<frameinstance modelid="player" posn="0 -24"/>
						<frameinstance modelid="player" posn="0 -30"/>
						<frameinstance modelid="player" posn="0 -36"/>
					</frame>
				</frame>
				
				<quad id="castledonationblur" posn="0 0 0" sizen="60 10" style="Bgs1" substyle="BgDialogBlur" scriptevents="1"/>
			</frame>
			
		</frame>
	</frame>

	<script><!--
		#Include	"MathLib"			as ML
		#Include	"TextLib"			as TL
		#Include	"AnimLib"			as AL

		// ---------------------------------- //

		#Const		C_NeutralPos					<-666., -666.>
		#Const		C_FrameSizeX					30
		#Const		C_GoldStep						50
		#Const		C_BlitzGold						{( BlitzGold )}

		#Const C_BetSize <60., 45.>
		
		#Const		C_GaugeTimeOut					3000
		#Const		C_FrameOpenCloseAnimDuration	500

		// ---------------------------------- //
		
		CMlQuad GetBetLight() {
			return (Page.GetFirstChild("betlight") as CMlQuad);
		}

		CMlFrame GetBetFrame() {
			return (Page.GetFirstChild("betframe") as CMlFrame);
		}

		CMlFrame GetAssaultFrame() {
			return (Page.GetFirstChild("assault") as CMlFrame);
		}

		CMlFrame GetDefensesFrame() {
			return (Page.GetFirstChild("defenses") as CMlFrame);
		}

		CMlFrame GetScaleFrame() {
			return (Page.GetFirstChild("scaleframe") as CMlFrame);
		}
		
		CMlLabel GetInfoLabel(CMlFrame _FrameInstance) {
			return (_FrameInstance.GetFirstChild("infolabel") as CMlLabel);
		}
		
		CMlLabel GetBetPurposeLabel(CMlFrame _FrameInstance) {
			return (_FrameInstance.GetFirstChild("purpose") as CMlLabel);
		}
		
		CMlQuad GetMinusQuad(CMlFrame _FrameInstance) {
			return (_FrameInstance.GetFirstChild("minusquad") as CMlQuad);
		}
		
		CMlQuad GetPlusQuad(CMlFrame _FrameInstance) {
			return (_FrameInstance.GetFirstChild("plusquad") as CMlQuad);
		}

		// ---------------------------------- //
		/**
		 * Changes the value of the gold label.
		 *
		 * @param _Value The gold to display.
		 */
		Void SetLabelValue(Integer _Value) {
			declare Integer Cli_UI_L_GaugeSelectedCastleType for UI;

			switch (Cli_UI_L_GaugeSelectedCastleType) {
				case 0: {
					// Defenses
					GetInfoLabel(GetDefensesFrame()).SetText(TL::ToText(_Value));
					GetInfoLabel(GetAssaultFrame()).SetText("...");
				}
				case 1: {
					// Assault
					GetInfoLabel(GetAssaultFrame()).SetText(TL::ToText(_Value));
					GetInfoLabel(GetDefensesFrame()).SetText("...");
				}
			}
		}
		
		// ---------------------------------- //
		/**
		 * Applies opacity recursively.
		 *
		 * @param _Control The control to start with.
		 * @param _Opacity The opacity to apply.
		 */
		Void SetOpacity(CMlControl _Control, Real _Opacity) {
			switchtype (_Control) {
				case CMlFrame: {
					declare CMlFrame Frame = (_Control as CMlFrame);
					foreach (Child in Frame.Controls) {
						SetOpacity(Child, _Opacity);
					}
				}
				case CMlQuad: {
					declare CMlQuad Quad = (_Control as CMlQuad);
					Quad.Opacity = _Opacity;
				}
				case CMlLabel: {
					declare CMlLabel Label = (_Control as CMlLabel);
					Label.Opacity = _Opacity;
				}
			}
		}

		CMlQuad GetDefensesBlur() {
			return (Page.GetFirstChild("defblur") as CMlQuad);
		}

		CMlQuad GetAssaultBlur() {
			return (Page.GetFirstChild("assblur") as CMlQuad);
		}

		CMlFrame GetCastleDonationFrame() {
			return (Page.GetFirstChild("castledonation") as CMlFrame);
		}

		CMlLabel GetChosenPlayerForDonationLabel() {
			return (Page.GetFirstChild("chosenplayerfordonation") as CMlLabel);
		}

		CMlFrame GetPlayerFrameInstancesParentFrame() {
			return (Page.GetFirstChild("players") as CMlFrame);
		}

		Void TogglePlayerFrameInstancesParentFrameVisibility() {
			declare CMlFrame ParentFrame = GetPlayerFrameInstancesParentFrame(); 
			ParentFrame.Visible = !ParentFrame.Visible;
		}

		Void ShowPlayerFrameInstancesParentFrame() {
			GetPlayerFrameInstancesParentFrame().Show();
		}

		Void HidePlayerFrameInstancesParentFrame() {
			GetPlayerFrameInstancesParentFrame().Hide();
		}

		Boolean IsPlayerFrameInstancesParentFrameVisible() {
			return GetPlayerFrameInstancesParentFrame().Visible;
		}

		CMlFrame[] GetPlayerFrameInstances() {
			declare CMlFrame[] PlayerFrameInstances;
			foreach (Control in GetPlayerFrameInstancesParentFrame().Controls) {
				if (!(Control is CMlFrame)) continue;
				PlayerFrameInstances.add((Control as CMlFrame));
			}
			return PlayerFrameInstances;
		}

		CMlQuad PFI_GetFocusQuad(CMlFrame _PFI) {
			return (_PFI.GetFirstChild("playerfocus") as CMlQuad);
		}

		CMlFrame PFI_GetPlayerFrameInstanceFromFocusQuad(CMlControl _FocusQuad) {
			foreach (PFI in GetPlayerFrameInstances()) {
				if (_FocusQuad == PFI_GetFocusQuad(PFI)) return PFI;
			}

			return Null;
		}

		CMlLabel PFI_GetPlayerNameLabel(CMlFrame _PFI) {
			return (_PFI.GetFirstChild("playername") as CMlLabel);
		}

		Integer PFI_GetPlayerIdFromFocusQuad(CMlControl _FocusQuad) {
			declare Integer PlayerId for _FocusQuad;
			return PlayerId;
		}

		// ---------------------------------- //
		/**
		 * Get the local player's id.
		 *
		 * @return The local player's id.
		 */
		Integer GetInputPlayerId() {
			declare netread Text[Integer] Srv_Player_G_Players for Teams[0];

			if (!Srv_Player_G_Players.exists(LocalUser.Login)) {
				// Do not spam log please; log("the input player isn't initialized");
				return -1;
			}

			return Srv_Player_G_Players.keyof(LocalUser.Login);
		}

		// ---------------------------------- //
		/**
		 * Checks if a player is vassal.
		 *
		 * @param _PlayerId The player's id to check.
		 * @return True if the player is vassal, False otherwise.
		 */
		Boolean IsPlayerVassal(Integer _PlayerId) {
			declare netread Integer[Integer] Srv_Player_G_Vassals for Teams[0];
			return Srv_Player_G_Vassals.existskey(_PlayerId);
		}

		Boolean HasVassals(Integer _PlayerId) {
			declare netread Integer[Integer] Srv_Player_G_Vassals for Teams[0];
			return Srv_Player_G_Vassals.exists(_PlayerId);
		}

		// ---------------------------------- //
		/**
		 * Gets a vassal player's master.
		 *
		 * @param _PlayerId The player's id to get the master from.
		 * @return The master player's id.
		 */
		Integer GetPlayerMasterId(Integer _PlayerId) {
			declare netread Integer[Integer] Srv_Player_G_Vassals for Teams[0];
			return Srv_Player_G_Vassals[_PlayerId];
		}

		Integer GetCurrentlyFocusedCastleId() {
			declare Integer Cli_UI_L_GaugeCastleId for UI;
			return Cli_UI_L_GaugeCastleId;
		}

		Void DonateCastle(Integer _PlayerId, Integer _CastleId) {
			declare netwrite Int3 Cli_Player_P_CastleDonation for UI;
			Cli_Player_P_CastleDonation = <GetInputPlayerId(), _PlayerId, _CastleId>;
		}

		Integer GetCastleDonationPlayerId() {
			declare netwrite Int3 Cli_Player_P_CastleDonation for UI;
			return Cli_Player_P_CastleDonation.Y;
		}

		Integer GetCastleDonationCastleId() {
			declare netwrite Int3 Cli_Player_P_CastleDonation for UI;
			return Cli_Player_P_CastleDonation.Z;
		}

		Void ResetCastleDonation() {
			DonateCastle(-1, -1);
		}

		Void HideCastleDonationFrame() {
			GetCastleDonationFrame().Hide();
			HidePlayerFrameInstancesParentFrame();
		}

		Void ShowCastleDonationFrame() {
			declare Integer DonationCastleId = GetCastleDonationCastleId();
			if (!HasVassals(GetInputPlayerId()) || (DonationCastleId > -1 && DonationCastleId != GetCurrentlyFocusedCastleId())) {
				HideCastleDonationFrame();
			} else {
				GetCastleDonationFrame().Show();
				ShowPlayerFrameInstancesParentFrame();
			}
		}

		Void BlurDefenses(Boolean _Blur) {
			declare Real Z = 0.;
			if (_Blur) Z = 4.;
			GetDefensesBlur().RelativePosition.Z = Z;
		}

		Void BlurAssault(Boolean _Blur) {
			declare Real Z = 0.;
			if (_Blur) Z = 4.;
			GetAssaultBlur().RelativePosition.Z = Z;
		}

		// ---------------------------------- //
		/**
		 * Gets the amount of gold possessed by the given player.
		 *
		 * @param _PlayerId The player to get the amount of gold from.
		 * @return The amount of gold.
		 */
		Integer GetPlayerGold(Integer _PlayerId) {
			declare netread Integer[Integer] Srv_Player_G_PlayersGold for Teams[0];
			if (!Srv_Player_G_PlayersGold.existskey(_PlayerId)) return -1;
			return Srv_Player_G_PlayersGold[_PlayerId];
		}

		// ---------------------------------- //
		/**
		 * Gets the local player's gold amount.
		 *
		 * @return The gold amount.
		 */
		Integer GetInputPlayerGold() {
			return GetPlayerGold(GetInputPlayerId());
		}

		Integer GetGoldDonationOnPlayer(Integer _PlayerId) {
			declare netwrite Integer[Integer] Cli_Player_P_GoldDonations for UI;
			if (Cli_Player_P_GoldDonations.existskey(_PlayerId)) return Cli_Player_P_GoldDonations[_PlayerId];
			return 0;
		}

		Integer GetTotalGoldDonation() {
			declare netread Text[Integer] Srv_Player_G_Players for Teams[0];
			declare Integer GoldSum;
			for (PlayerId, 0, Srv_Player_G_Players.count - 1) {
				GoldSum += GetGoldDonationOnPlayer(PlayerId);
			}
			return GoldSum;
		}

		Integer[] GetPlayerCastles(Integer _PlayerId) {
			declare Integer[] PlayerCastles;
			declare netread Int3[Integer] Srv_World_G_CastleAttributes for Teams[0];
			foreach (CastleId => CastleAttr in Srv_World_G_CastleAttributes) {
				if (CastleAttr.X == _PlayerId) PlayerCastles.add(CastleId);
			}
			return PlayerCastles;
		}

		Boolean AreCastlesLinked(Integer _Castle1Id, Integer _Castle2Id) {
			declare netread Int3[] Srv_World_G_Links for Teams[0];

			foreach (Link in Srv_World_G_Links) {
				
				if ((Link.X == _Castle1Id && Link.Y == _Castle2Id) || (Link.X == _Castle2Id && Link.Y == _Castle1Id)) {
					return True;
				}

			}

			return False;
		}

		Boolean IsCastleAccessible(Integer _AimedCastleId, Integer _PlayerId) {
			foreach (CastleId in GetPlayerCastles(_PlayerId)) {
				if (AreCastlesLinked(_AimedCastleId, CastleId)) return True;
			}
			return False;
		}

		Boolean IsCastleCapital(Integer _CastleId) {
			declare netread Int3[Integer] Srv_World_G_CastleAttributes for Teams[0];
			return Srv_World_G_CastleAttributes[_CastleId].Z == 1;
		}

		Int3 GetAction() {
			declare netwrite Int3 Cli_Action_P_Action for UI;
			return Cli_Action_P_Action;
		}

		Void ClearAction() {
			declare netwrite	Int3	Cli_Action_P_Action					for UI;
			declare 			Integer	Cli_UI_L_GaugeCastleId				for UI;
			declare				Integer	Cli_UI_L_ActionRefreshedTimestamp	for UI;

			Cli_Action_P_Action = <-1, -1, -1>;
			Cli_UI_L_GaugeCastleId = -1;
			Cli_UI_L_ActionRefreshedTimestamp = Now;
		}

		Boolean HasBlitzed() {
			declare Integer ActionCastleId = GetAction().Z;
			return ActionCastleId != -1 && IsCastleCapital(ActionCastleId) && !IsCastleAccessible(ActionCastleId, GetInputPlayerId());
		}

		// ---------------------------------- //
		/**
		 * Count the gold placed on the specified castle.
		 *
		 * @param _CastleId The concerned castle.
		 * @return The gold amount.
		 */
		Integer World_GetGoldOnCastle(Integer _CastleId) {
			declare netwrite Integer[Integer]	Cli_World_P_CastleDefenseGoldAddition		for UI;

			if (Cli_World_P_CastleDefenseGoldAddition.existskey(_CastleId)) {
				return Cli_World_P_CastleDefenseGoldAddition[_CastleId];
			}
			
			return 0;
		}

		// ---------------------------------- //
		/**
		 * Count all the placed gold.
		 *
		 * @param _CastleId The concerned castle.
		 * @param _Amount The amount of gold to substract.
		 */
		Integer World_CountCastlesGoldAdditions() {
			declare netwrite Integer[Integer]	Cli_World_P_CastleDefenseGoldAddition		for UI;
			declare Integer GoldAmountPlacedOnCastles;

			foreach (GoldAmount in Cli_World_P_CastleDefenseGoldAddition) {
				GoldAmountPlacedOnCastles += GoldAmount;
			}

			return GoldAmountPlacedOnCastles;
		}

		// ---------------------------------- //
		/**
		 * Resets the gold on every castle.
		 */
		Void World_ResetAllCastlesGoldAddition() {
			declare netwrite Integer[Integer]	Cli_World_P_CastleDefenseGoldAddition		for UI;
			declare Integer						Cli_UI_L_CastleDefenseGoldAdditionTimestamp	for UI;

			Cli_World_P_CastleDefenseGoldAddition.clear();
			Cli_UI_L_CastleDefenseGoldAdditionTimestamp = Now;
		}

		// ---------------------------------- //
		/**
		 * Resets the gold on the specified castle.
		 *
		 * @param _CastleId The concerned castle.
		 */
		Void World_ResetGoldOnCastle(Integer _CastleId) {
			declare netwrite Integer[Integer]	Cli_World_P_CastleDefenseGoldAddition		for UI;
			declare Integer						Cli_UI_L_CastleDefenseGoldAdditionTimestamp	for UI;

			Cli_World_P_CastleDefenseGoldAddition[_CastleId] = 0;
			Cli_UI_L_CastleDefenseGoldAdditionTimestamp = Now;
		}

		// ---------------------------------- //
		/**
		 * Adds gold to the specified castle.
		 *
		 * @param _CastleId The concerned castle.
		 * @param _Amount The amount of gold to add.
		 */
		Void World_AddGoldOnCastle(Integer _CastleId, Integer _Amount) {
			yield;

			declare netwrite	Integer[Integer]	Cli_World_P_CastleDefenseGoldAddition		for UI;
			declare				Integer				Cli_UI_L_CastleDefenseGoldAdditionTimestamp	for UI;
			declare netwrite	Integer				Cli_Player_P_Bet							for UI;
			declare				Integer				ActionCastleId = GetAction().Z;

			declare Integer BlitzGold;

			if (HasBlitzed() && ActionCastleId > -1 && IsCastleCapital(ActionCastleId)) { // -2 => castle capital
				BlitzGold = C_BlitzGold;
			}

			declare Integer AvailableGoldAmount = GetInputPlayerGold() - GetTotalGoldDonation() - World_CountCastlesGoldAdditions() - Cli_Player_P_Bet - BlitzGold;
			AvailableGoldAmount -= AvailableGoldAmount % C_GoldStep;

			if (AvailableGoldAmount <= 0) return;

			declare Amount = _Amount;
			if (Amount > AvailableGoldAmount) Amount = AvailableGoldAmount;

			if (Cli_World_P_CastleDefenseGoldAddition.existskey(_CastleId)) {
				Cli_World_P_CastleDefenseGoldAddition[_CastleId] += Amount;
			} else {
				Cli_World_P_CastleDefenseGoldAddition[_CastleId] = Amount;
			}

			Cli_UI_L_CastleDefenseGoldAdditionTimestamp = Now;
		}

		// ---------------------------------- //
		/**
		 * Substracts gold to the specified castle.
		 *
		 * @param _CastleId The concerned castle.
		 * @param _Amount The amount of gold to substract.
		 */
		Void World_SubGoldOnCastle(Integer _CastleId, Integer _Amount) {
			yield;

			declare netwrite Integer[Integer]	Cli_World_P_CastleDefenseGoldAddition		for UI;
			declare Integer						Cli_UI_L_CastleDefenseGoldAdditionTimestamp	for UI;

			if (Cli_World_P_CastleDefenseGoldAddition.existskey(_CastleId)) {
				Cli_World_P_CastleDefenseGoldAddition[_CastleId] -= _Amount;
			} else {
				Cli_World_P_CastleDefenseGoldAddition[_CastleId] = 0;
			}
			if (Cli_World_P_CastleDefenseGoldAddition[_CastleId] < 0) Cli_World_P_CastleDefenseGoldAddition[_CastleId] = 0;

			Cli_UI_L_CastleDefenseGoldAdditionTimestamp = Now;
		}

		// ---------------------------------- //
		/**
		 * Gets the remaining gold usable for a bet.
		 *
		 * @return The gold amount.
		 */
		Integer GetAvailableGoldForBet() {
			declare Integer BlitzGold;
			declare Integer ActionCastleId = GetAction().Z;

			if (HasBlitzed() && ActionCastleId > -1 && IsCastleCapital(ActionCastleId)) {
				BlitzGold = C_BlitzGold;
			}

			declare Gold = GetInputPlayerGold() - World_CountCastlesGoldAdditions() - GetTotalGoldDonation() - BlitzGold;
			Gold -= Gold % C_GoldStep;
			return Gold;
		}

		// ---------------------------------- //
		/**
		 * Gets the local player's bet gold amount.
		 *
		 * @return The gold amount.
		 */
		Integer GetBet() {
			declare netwrite Integer Cli_Player_P_Bet for UI;
			return Cli_Player_P_Bet;
		}

		// ---------------------------------- //
		/**
		 * Changes the local player's bet gold amount.
		 *
		 * @param _GoldAmount The bet gold amount.
		 */
		Void SetBet(Integer _GoldAmount) {

			declare Integer GoldAmount = _GoldAmount;
			if (GoldAmount > GetAvailableGoldForBet()) GoldAmount = GetAvailableGoldForBet();
			if (GoldAmount < 0) GoldAmount = 0;

			declare netwrite Integer Cli_Player_P_Bet for UI;
			Cli_Player_P_Bet = GoldAmount;
		}

		// ---------------------------------- //
		/**
		 * Calculates the amount of gold on a castle to display.
		 *
		 * @return The amount of gold.
		 */
		Integer GetGoldOnCastleToDisplay(Integer _CastleId) {
			declare netread Integer[Integer] Srv_World_G_CastleDefenseGoldAmounts	for Teams[0];
			return Srv_World_G_CastleDefenseGoldAmounts[_CastleId] + World_GetGoldOnCastle(_CastleId);
		}

		// ---------------------------------- //
		/**
		 * Function that must be called when clicking on +, automatically handles the correct behaviour (bet or defense gold).
		 */
		Void Plus() {
			declare Integer Cli_UI_L_GaugeCastleId					for UI;
			declare Integer Cli_UI_L_GaugeSelectedCastleType		for UI;
			declare Integer Cli_UI_L_LastBetPlusClickTimestamp		for UI;
			declare Integer Cli_UI_L_LastBetValueChangeTimestamp	for UI;
			declare Integer Cli_UI_L_RefreshTakeQuads				for UI;
			
			Cli_UI_L_LastBetPlusClickTimestamp = Now;
			Cli_UI_L_LastBetValueChangeTimestamp = Now;

			switch (Cli_UI_L_GaugeSelectedCastleType) {
				case 0: {
					// Defense
					World_AddGoldOnCastle(Cli_UI_L_GaugeCastleId, C_GoldStep);
				}
				case 1: {
					// Attack
					SetBet(GetBet() + C_GoldStep);
				}
			}

			Audio.PlaySoundEvent(CAudioManager::ELibSound::ScoreIncrease, 0, 0.);
			Cli_UI_L_RefreshTakeQuads = Now;
		}

		// ---------------------------------- //
		/**
		 * Function that must be called when clicking on -, automatically handles the correct behaviour (bet or defense gold).
		 */
		Void Minus() {
			declare Integer Cli_UI_L_GaugeSelectedCastleType		for UI;
			declare Integer Cli_UI_L_GaugeCastleId					for UI;
			declare Integer Cli_UI_L_LastBetMinusClickTimestamp		for UI;
			declare Integer Cli_UI_L_LastBetValueChangeTimestamp	for UI;
			declare Integer Cli_UI_L_RefreshTakeQuads				for UI;
			
			Cli_UI_L_LastBetMinusClickTimestamp = Now;
			Cli_UI_L_LastBetValueChangeTimestamp = Now;

			switch (Cli_UI_L_GaugeSelectedCastleType) {
				case 0: {
					// Defense
					World_SubGoldOnCastle(Cli_UI_L_GaugeCastleId, C_GoldStep);
				}
				case 1: {
					// Attack
					 SetBet(GetBet() - C_GoldStep);
				}
			}

			Audio.PlaySoundEvent(CAudioManager::ELibSound::ScoreIncrease, 0, 0.);
			Cli_UI_L_RefreshTakeQuads = Now;
		}

		Boolean IsReady() {
			declare netwrite Boolean Cli_Player_P_Ready for UI;
			return Cli_Player_P_Ready;
		}

		// ---------------------------------- //
		/**
		 * Get the server's player logins.
		 *
		 * @return The players.
		 */
		Text[Integer] GetPlayers() {
			declare netread Text[Integer] Srv_Player_G_Players for Teams[0];
			return Srv_Player_G_Players;
		}

		// ---------------------------------- //
		/**
		 * Gets the name of a player.
		 *
		 * @param _PlayerId The id used to find the player.
		 * @return The player name.
		 */
		Text GetPlayerLogin(Integer _PlayerId) {
			declare netread Text[Integer] Srv_Player_G_Players for Teams[0];
			if (Srv_Player_G_Players.existskey(_PlayerId)) return Srv_Player_G_Players[_PlayerId];
			return "";
		}

		Text GetPlayerName(Integer _PlayerId) {
			declare Text PlayerLogin = GetPlayerLogin(_PlayerId);
			foreach (Player in Players) {
				if (Player.User.Login == PlayerLogin) return Player.User.Name;
			}
			return PlayerLogin;
		}

		Text GetPlayerName(Text _PlayerLogin) {
			foreach (Player in Players) {
				if (Player.User.Login == _PlayerLogin) return Player.User.Name;
			}
			return _PlayerLogin;
		}

		Text[Integer] GetVassalsNames(Integer _PlayerId) {
			declare Text[Integer] PlayerLogins = GetPlayers();
			declare Text[Integer] VassalNames;
			foreach (Id => PlayerLogin in PlayerLogins) {
				if (!IsPlayerVassal(Id) || GetPlayerMasterId(Id) != _PlayerId) continue;

				VassalNames[Id] = GetPlayerName(PlayerLogin);
			}
			return VassalNames;

		}

		Text[Integer] GetPlayerNames() {
			declare Text[Integer] PlayerLogins = GetPlayers();
			declare Text[Integer] PlayerNames;
			foreach (Id => PlayerLogin in PlayerLogins) {
				PlayerNames[Id] = GetPlayerName(PlayerLogin);
			}
			return PlayerNames;
		}

		// ---------------------------------- //
		/**
		 * Checks if there are players initialized.
		 *
		 * @return True if players are initialized, False otherwise.
		 */
		Boolean ArePlayersInitialized() {
			return (GetPlayers().count > 0);
		}

		Boolean IsSpec() {
			return (GetInputPlayerId() == -1);
		}

		// ---------------------------------- //
		/**
		 * Function that must be called on the script start.
		 */
		Void Init() {
			while (InputPlayer == Null) { yield; }
			while (InputPlayer.User == Null) { yield; }
			while (!ArePlayersInitialized()) { yield; }

			declare Vec2 Cli_UI_L_GaugeClickPos for UI; //< Set by the World UI. Indicates where to show the UI.
			Cli_UI_L_GaugeClickPos = C_NeutralPos;

			ResetCastleDonation();

			GetBetPurposeLabel(GetAssaultFrame()).SetText(_("$sAssault"));
			GetBetPurposeLabel(GetDefensesFrame()).SetText(_("$sDefenses"));
		}

		Void HideGauge() {
			declare Boolean	Cli_UI_L_GaugeVisibility				for UI;
			declare Integer	Cli_UI_L_GaugeVisibilityChangeTimestamp	for UI;
			
			if (Cli_UI_L_GaugeVisibility) {
				Cli_UI_L_GaugeVisibility = False;
				Cli_UI_L_GaugeVisibilityChangeTimestamp = Now;
			}

			HidePlayerFrameInstancesParentFrame();
		}

		Void ShowGauge(Boolean _ForceAnimation) {
			declare Boolean	Cli_UI_L_GaugeVisibility				for UI;
			declare Integer	Cli_UI_L_GaugeVisibilityChangeTimestamp	for UI;
			
			if (!Cli_UI_L_GaugeVisibility || _ForceAnimation) {
				Cli_UI_L_GaugeVisibility = True;
				Cli_UI_L_GaugeVisibilityChangeTimestamp = Now;
			}
		}

		Void ShowGauge() {
			ShowGauge(False);
		}
		
		// ---------------------------------- //
		/**
		 * Function that must be called on each loop start.
		 */
		Void LoopStart() {

			if (IsSpec()) return;

			// ---------------------------------- //
			// Orders to hide the bet frame if actions can't be sent.
			declare Integer			Cli_UI_L_GaugeSelectedCastleType		for UI;
			declare Integer			Cli_UI_L_GaugeCastleId					for UI;
			declare Integer			Cli_UI_L_LastGaugeCastleId				for This;
			declare Integer			Cli_UI_L_CastleClickTimestamp			for UI;
			declare Integer			Cli_UI_L_ActionRefreshedTimestamp		for UI;
			declare Integer			Cli_UI_L_LastCastleClickTimestamp		for This;
			declare Integer			Cli_UI_L_ReadyChangeTimestamp			for UI;
			declare Integer			Cli_UI_L_LastReadyChangeTimestamp		for This;

			if (Cli_UI_L_LastCastleClickTimestamp < ML::Max(Cli_UI_L_CastleClickTimestamp, Cli_UI_L_ActionRefreshedTimestamp)) {
				Cli_UI_L_LastCastleClickTimestamp = ML::Max(Cli_UI_L_CastleClickTimestamp, Cli_UI_L_ActionRefreshedTimestamp);
				
				if (Cli_UI_L_GaugeCastleId != -1) {
					if (Cli_UI_L_LastGaugeCastleId != Cli_UI_L_GaugeCastleId && HasBlitzed() && IsCastleCapital(Cli_UI_L_GaugeCastleId)) {
						SetBet(0);
					}
					ShowGauge(True);
					Cli_UI_L_LastGaugeCastleId = Cli_UI_L_GaugeCastleId;
				} else {
					HideGauge();
				}
			}

			if (Cli_UI_L_LastReadyChangeTimestamp != Cli_UI_L_ReadyChangeTimestamp) {
				Cli_UI_L_LastReadyChangeTimestamp != Cli_UI_L_ReadyChangeTimestamp;
				if (IsReady()) HideGauge();
			}

			declare netread Boolean	Srv_Action_P_CanSendActions				for InputPlayer;
			declare Boolean			Cli_UI_L_LastCanSendActions				for UI;
			
			if (Cli_UI_L_LastCanSendActions != Srv_Action_P_CanSendActions) {
				Cli_UI_L_LastCanSendActions = Srv_Action_P_CanSendActions;
				HideGauge();
			}

			declare Boolean			Cli_UI_L_GaugeVisibility				for UI;
			declare Integer			Cli_UI_L_GaugeVisibilityChangeTimestamp	for UI;
			declare Integer			Cli_UI_L_LastBetValueChangeTimestamp	for UI;

			declare Integer			LastEvent = ML::Max(ML::Max(Cli_UI_L_CastleClickTimestamp, Cli_UI_L_LastBetValueChangeTimestamp), Cli_UI_L_GaugeVisibilityChangeTimestamp);

			if (Cli_UI_L_GaugeVisibility && Now - LastEvent >= C_GaugeTimeOut) {
				HideGauge();
			}




			// ---------------------------------- //
			// Clears the bet if the server asked it.
			declare netread Integer Srv_Player_P_ClearBetTimestamp	for InputPlayer;
			declare Integer LastClearBetTimestamp					for UI;

			if (LastClearBetTimestamp != Srv_Player_P_ClearBetTimestamp) {
				LastClearBetTimestamp = Srv_Player_P_ClearBetTimestamp;
				SetBet(0);
			}

			// ---------------------------------- //
			// Places correctly the frame according to what the World UI indicated.
			declare CMlFrame	BetFrame = GetBetFrame();

			declare Vec2		Cli_UI_L_GaugeClickPos	for UI;

			BetFrame.RelativePosition.X = Cli_UI_L_GaugeClickPos.X;
			BetFrame.RelativePosition.Y = Cli_UI_L_GaugeClickPos.Y;

			if (BetFrame.RelativePosition.X + C_BetSize.X > 160.) BetFrame.RelativePosition.X = 160. - C_BetSize.X;
			if (BetFrame.RelativePosition.Y - C_BetSize.Y < -90.) BetFrame.RelativePosition.Y = -90. + C_BetSize.Y;

			// ---------------------------------- //
			// Displays the correct value.

			switch (Cli_UI_L_GaugeSelectedCastleType) {
				case 0: {
					// Defense
					if (Cli_UI_L_GaugeCastleId != -1) SetLabelValue(GetGoldOnCastleToDisplay(Cli_UI_L_GaugeCastleId));
					BlurDefenses(False);
					BlurAssault(True);
					ShowCastleDonationFrame();
				}
				case 1: {
					// 	Attack
					SetLabelValue(GetBet());
					BlurDefenses(True);
					BlurAssault(False);
					HideCastleDonationFrame();
				}
			}

			// ---------------------------------- //
			// Displays the chosen player that will receive a planet.

			declare Integer PlayerId = GetCastleDonationPlayerId();
			declare Text	PlayerName;

			if (PlayerId == -1) {
				PlayerName = "...";
			} else {
				PlayerName = GetPlayerName(PlayerId);
			}

			GetChosenPlayerForDonationLabel().SetText(PlayerName);

			// ---------------------------------- //

			declare netread Integer	Srv_World_G_CurrentYear			for Teams[0];
			declare Integer			Cli_UI_L_LastYear				for This;

			if (Cli_UI_L_LastYear != Srv_World_G_CurrentYear) {
				Cli_UI_L_LastYear = Srv_World_G_CurrentYear;
				ResetCastleDonation();
			}
		}
		
		// ---------------------------------- //
		/**
		 * Animates the UI. 
		 */
		Void Animate() {

			if (IsSpec()) {
				declare CMlFrame	BetFrame				= GetBetFrame();
				BetFrame.Hide();
			} else {
				declare Boolean		Cli_UI_L_GaugeVisibility				for UI;
				declare Integer		Cli_UI_L_GaugeVisibilityChangeTimestamp	for UI;
				declare Integer		Cli_UI_L_CastleClickTimestamp			for UI;
				declare Integer		Cli_UI_L_LastBetValueChangeTimestamp	for UI;
				declare Integer		Cli_UI_L_GaugeSelectedCastleType		for UI;
				declare Integer		Cli_UI_L_GaugeCastleId					for UI;
				
				declare CMlQuad		BetLight				= GetBetLight();
				declare CMlFrame	BetFrame				= GetBetFrame();
				declare CMlFrame	ScaleFrame				= GetScaleFrame();

				declare CMlFrame	AssaultFrame			= GetAssaultFrame();

				declare CMlQuad		AssaultMinusQuad		= GetMinusQuad(AssaultFrame);
				declare CMlQuad		AssaultPlusQuad			= GetPlusQuad(AssaultFrame);
				declare CMlLabel	AssaultInfoLabel		= GetInfoLabel(AssaultFrame);
				declare CMlLabel	AssaultBetPurposeLabel	= GetBetPurposeLabel(AssaultFrame);

				declare CMlFrame	DefensesFrame			= GetDefensesFrame();

				declare CMlQuad		DefensesMinusQuad		= GetMinusQuad(DefensesFrame);
				declare CMlQuad		DefensesPlusQuad		= GetPlusQuad(DefensesFrame);
				declare CMlLabel	DefensesInfoLabel		= GetInfoLabel(DefensesFrame);
				declare CMlLabel	DefensesBetPurposeLabel	= GetBetPurposeLabel(DefensesFrame);

				declare Integer		LastClick		= ML::Max(Cli_UI_L_CastleClickTimestamp, Cli_UI_L_LastBetValueChangeTimestamp);
				

				if (Cli_UI_L_GaugeVisibility) {
					// The gauge must be shown.
					ScaleFrame.Show();

					if (Now - Cli_UI_L_GaugeVisibilityChangeTimestamp < C_FrameOpenCloseAnimDuration + C_GaugeTimeOut) {
						ScaleFrame.RelativeScale = AL::EaseOutExp(Now - Cli_UI_L_GaugeVisibilityChangeTimestamp, 0., 1., C_FrameOpenCloseAnimDuration);
						// ScaleFrame.RelativeRotation = AL::EaseOutExp(Now - Cli_UI_L_GaugeVisibilityChangeTimestamp, -45., 45., C_FrameOpenCloseAnimDuration);
						ScaleFrame.RelativeRotation = 0.;
					} else {
						ScaleFrame.RelativeScale = 1.;
						ScaleFrame.RelativeRotation = 0.;
					}

					// Gauge's content animation.

					declare Integer		Cli_UI_L_LastBetPlusClickTimestamp		for UI;
					declare Integer		Cli_UI_L_LastBetMinusClickTimestamp		for UI;

					declare Vec3 NormalColor	= <1., 0.667, 0.>;
					declare Vec3 HighlightColor	= <1., 0.97, 0.5>;
					declare Vec3 TextColor;
					TextColor = NormalColor - (NormalColor - HighlightColor) * AL::EaseLinear(Now - Cli_UI_L_LastBetValueChangeTimestamp, 1., -1., 200);
					
					switch (Cli_UI_L_GaugeSelectedCastleType) {
						case 0: {
							DefensesPlusQuad.RelativeScale	= AL::EaseOutExp(Now - Cli_UI_L_LastBetPlusClickTimestamp, 0.9, 0.1, C_FrameOpenCloseAnimDuration);
							DefensesMinusQuad.RelativeScale	= AL::EaseOutExp(Now - Cli_UI_L_LastBetMinusClickTimestamp, 0.9, 0.1, C_FrameOpenCloseAnimDuration);
							DefensesInfoLabel.RelativeScale	= AL::EaseOutExp(Now - Cli_UI_L_LastBetValueChangeTimestamp, 1.1, -0.1, C_FrameOpenCloseAnimDuration);
							DefensesInfoLabel.TextColor		= TextColor;
						}
						case 1: {
							AssaultPlusQuad.RelativeScale	= AL::EaseOutExp(Now - Cli_UI_L_LastBetPlusClickTimestamp, 0.9, 0.1, C_FrameOpenCloseAnimDuration);
							AssaultMinusQuad.RelativeScale	= AL::EaseOutExp(Now - Cli_UI_L_LastBetMinusClickTimestamp, 0.9, 0.1, C_FrameOpenCloseAnimDuration);
							AssaultInfoLabel.RelativeScale	= AL::EaseOutExp(Now - Cli_UI_L_LastBetValueChangeTimestamp, 1.1, -0.1, C_FrameOpenCloseAnimDuration);
							AssaultInfoLabel.TextColor		= TextColor;
						}
					}

					declare Vec3 Color;

					declare Integer MouseOverTimestamp	as	AssaultPlusQuadMouseOverTimestamp	for AssaultPlusQuad;
					declare Integer MouseOutTimestamp	as	AssaultPlusQuadMouseOutTimestamp	for AssaultPlusQuad;

					if (AssaultPlusQuadMouseOverTimestamp > AssaultPlusQuadMouseOutTimestamp) {
						Color = NormalColor - (NormalColor - HighlightColor) * AL::EaseLinear(Now - AssaultPlusQuadMouseOverTimestamp, 0., 1., 200);
					} else {
						Color = NormalColor - (NormalColor - HighlightColor) * AL::EaseLinear(Now - AssaultPlusQuadMouseOutTimestamp, 1., -1., 200);
					}

					AssaultPlusQuad.Colorize = Color;

					declare Integer MouseOverTimestamp	as	AssaultMinusQuadMouseOverTimestamp	for AssaultMinusQuad;
					declare Integer MouseOutTimestamp	as	AssaultMinusQuadMouseOutTimestamp	for AssaultMinusQuad;

					if (AssaultMinusQuadMouseOverTimestamp > AssaultMinusQuadMouseOutTimestamp) {
						Color = NormalColor - (NormalColor - HighlightColor) * AL::EaseLinear(Now - AssaultMinusQuadMouseOverTimestamp, 0., 1., 200);
					} else {
						Color = NormalColor - (NormalColor - HighlightColor) * AL::EaseLinear(Now - AssaultMinusQuadMouseOutTimestamp, 1., -1., 200);
					}

					AssaultMinusQuad.Colorize = Color;

					declare Integer MouseOverTimestamp	as	DefensesPlusQuadMouseOverTimestamp	for DefensesPlusQuad;
					declare Integer MouseOutTimestamp	as	DefensesPlusQuadMouseOutTimestamp	for DefensesPlusQuad;

					if (DefensesPlusQuadMouseOverTimestamp > DefensesPlusQuadMouseOutTimestamp) {
						Color = NormalColor - (NormalColor - HighlightColor) * AL::EaseLinear(Now - DefensesPlusQuadMouseOverTimestamp, 0., 1., 200);
					} else {
						Color = NormalColor - (NormalColor - HighlightColor) * AL::EaseLinear(Now - DefensesPlusQuadMouseOutTimestamp, 1., -1., 200);
					}

					DefensesPlusQuad.Colorize = Color;

					declare Integer MouseOverTimestamp	as	DefensesMinusQuadMouseOverTimestamp	for DefensesMinusQuad;
					declare Integer MouseOutTimestamp	as	DefensesMinusQuadMouseOutTimestamp	for DefensesMinusQuad;

					if (DefensesMinusQuadMouseOverTimestamp > DefensesMinusQuadMouseOutTimestamp) {
						Color = NormalColor - (NormalColor - HighlightColor) * AL::EaseLinear(Now - DefensesMinusQuadMouseOverTimestamp, 0., 1., 200);
					} else {
						Color = NormalColor - (NormalColor - HighlightColor) * AL::EaseLinear(Now - DefensesMinusQuadMouseOutTimestamp, 1., -1., 200);
					}

					DefensesMinusQuad.Colorize = Color;

				} else {
					// The gauge must be hidden.

					if (Now - Cli_UI_L_GaugeVisibilityChangeTimestamp < C_FrameOpenCloseAnimDuration + C_GaugeTimeOut) {
						ScaleFrame.RelativeScale = AL::EaseOutExp(Now - Cli_UI_L_GaugeVisibilityChangeTimestamp, 1., -1., C_FrameOpenCloseAnimDuration);
						// ScaleFrame.RelativeRotation = AL::EaseOutExp(Now - Cli_UI_L_GaugeVisibilityChangeTimestamp, 0., 45., C_FrameOpenCloseAnimDuration);
						ScaleFrame.RelativeRotation = 0.;
					} else {
						ScaleFrame.Hide();
					}
				}
			}

			// ---------------------------------- //

			declare CMlFrame[] PlayerFrameInstances = GetPlayerFrameInstances();
			declare Text[Integer] GamePlayers = GetVassalsNames(GetInputPlayerId());

			declare CMlLabel	ResetPlayerNameLabel	= PFI_GetPlayerNameLabel(PlayerFrameInstances[0]);
			declare CMlQuad		ResetFocusQuad			= PFI_GetFocusQuad(PlayerFrameInstances[0]);
			declare Integer		PlayerId for ResetFocusQuad;
			ResetPlayerNameLabel.SetText(("No one"));
			PlayerId = -1;

			declare Integer CurrentPFIIndex = 1;

			foreach (Id => PlayerName in GamePlayers) {
				if (Id == GetInputPlayerId()) continue;

				declare CMlFrame	CurrentPFI = PlayerFrameInstances[CurrentPFIIndex];
				declare CMlLabel	PlayerNameLabel = PFI_GetPlayerNameLabel(CurrentPFI);
				declare CMlQuad		PlayerFocusQuad = PFI_GetFocusQuad(CurrentPFI);
				declare Integer		PlayerId	for PlayerFocusQuad;

				PlayerNameLabel.SetText(PlayerName);
				PlayerId = Id;
				CurrentPFI.Show();

				CurrentPFIIndex += 1;
			}

			while (CurrentPFIIndex < PlayerFrameInstances.count) {
				declare CMlFrame CurrentPFI = PlayerFrameInstances[CurrentPFIIndex];
				CurrentPFI.Hide();

				CurrentPFIIndex += 1;
			}

			// ---------------------------------- //
			// ANIMATE END

		}
		
		// ---------------------------------- //
		/**
		 * Main function.
		 */
		main() {
			Init();

			declare Integer		Cli_UI_L_LastBetPlusClickTimestamp	for UI;
			declare Integer		Cli_UI_L_LastBetMinusClickTimestamp	for UI;

			declare Integer		Cli_UI_L_GaugeCastleId				for UI;
			
			declare CMlFrame	AssaultFrame		= GetAssaultFrame();

			declare CMlLabel	AssaultInfoLabel	= GetInfoLabel(AssaultFrame);
			declare CMlQuad		AssaultMinusQuad	= GetMinusQuad(AssaultFrame);
			declare CMlQuad		AssaultPlusQuad		= GetPlusQuad(AssaultFrame);

			declare CMlFrame	DefensesFrame		= GetDefensesFrame();

			declare CMlLabel	DefensesInfoLabel	= GetInfoLabel(DefensesFrame);
			declare CMlQuad		DefensesMinusQuad	= GetMinusQuad(DefensesFrame);
			declare CMlQuad		DefensesPlusQuad	= GetPlusQuad(DefensesFrame);

			declare Boolean IsSpec;
			declare Boolean PreventPlayerFrameInstancesHiding;
			declare Boolean HasClickedOnLastLoop;
			
			while (True) {

				PreventPlayerFrameInstancesHiding = False;
				IsSpec = IsSpec();

				LoopStart();
				
				if (!IsSpec) {
					foreach (Event in PendingEvents) {
						switch (Event.Type) {

							case CMlEvent::Type::MouseClick: {
								switch (Event.ControlId) {
									case "plusquad": {
										Plus();
									}
									case "minusquad": {
										Minus();
									}
									case "cancel": {
										ClearAction();
										SetBet(0);
									}
									case "btn-arrow": {
										TogglePlayerFrameInstancesParentFrameVisibility();
										PreventPlayerFrameInstancesHiding = True;
									}
									case "playerfocus": {
										declare Integer PlayerId = PFI_GetPlayerIdFromFocusQuad(Event.Control);
										if (PlayerId == -1) {
											ResetCastleDonation();
										} else {
											DonateCastle(PlayerId, GetCurrentlyFocusedCastleId());
										}
										HidePlayerFrameInstancesParentFrame();
										PreventPlayerFrameInstancesHiding = True;
									}
								}
							}

							case CMlEvent::Type::MouseOver: {
								switch (Event.ControlId) {
									case "plusquad": {
										declare Integer MouseOverTimestamp for Event.Control;
										MouseOverTimestamp = Now;
										Audio.PlaySoundEvent(CAudioManager::ELibSound::Focus, 0, 20.);
									}
									case "minusquad": {
										declare Integer MouseOverTimestamp for Event.Control;
										MouseOverTimestamp = Now;
										Audio.PlaySoundEvent(CAudioManager::ELibSound::Focus, 0, 20.);
									}
								}
							}

							case CMlEvent::Type::MouseOut: {
								switch (Event.ControlId) {
									case "plusquad": {
										declare Integer MouseOutTimestamp for Event.Control;
										MouseOutTimestamp = Now;
										Audio.PlaySoundEvent(CAudioManager::ELibSound::Focus, 0, 20.);
									}
									case "minusquad": {
										declare Integer MouseOutTimestamp for Event.Control;
										MouseOutTimestamp = Now;
										Audio.PlaySoundEvent(CAudioManager::ELibSound::Focus, 0, 20.);
									}
								}
							}
						}
					}

					if (MouseLeftButton) {

						if (!PreventPlayerFrameInstancesHiding && !HasClickedOnLastLoop) {
							// Hides the PFIs if the player clicks anywhere else.
							HidePlayerFrameInstancesParentFrame();
						}

						declare Integer Cli_UI_L_GaugeSelectedCastleType for UI;

						switch (Cli_UI_L_GaugeSelectedCastleType) {
							case 0: {
								if (Cli_UI_L_LastBetPlusClickTimestamp != -1 && Now - Cli_UI_L_LastBetPlusClickTimestamp > 100) {
									// X
									if (DefensesPlusQuad.AbsolutePosition.X - DefensesPlusQuad.Size.X / 2. <= MouseX && MouseX <= DefensesPlusQuad.AbsolutePosition.X + DefensesPlusQuad.Size.X / 2.) {
										// Y
										if (DefensesPlusQuad.AbsolutePosition.Y <= MouseY && MouseY <= DefensesPlusQuad.AbsolutePosition.Y + DefensesPlusQuad.Size.Y) {
											Plus();
										}
									}
								}

								if (Cli_UI_L_LastBetMinusClickTimestamp != -1 && Now - Cli_UI_L_LastBetMinusClickTimestamp > 100) {
									// X
									if (DefensesMinusQuad.AbsolutePosition.X - DefensesMinusQuad.Size.X / 2. <= MouseX && MouseX <= DefensesMinusQuad.AbsolutePosition.X + DefensesMinusQuad.Size.X / 2.) {
										// Y
										if (DefensesMinusQuad.AbsolutePosition.Y - DefensesMinusQuad.Size.Y <= MouseY && MouseY <= DefensesMinusQuad.AbsolutePosition.Y) {
											Minus();
										}
									}
								}
							}
							case 1: {
								if (Cli_UI_L_LastBetPlusClickTimestamp != -1 && Now - Cli_UI_L_LastBetPlusClickTimestamp > 100) {
									// X
									if (AssaultPlusQuad.AbsolutePosition.X - AssaultPlusQuad.Size.X / 2. <= MouseX && MouseX <= AssaultPlusQuad.AbsolutePosition.X + AssaultPlusQuad.Size.X / 2.) {
										// Y
										if (AssaultPlusQuad.AbsolutePosition.Y <= MouseY && MouseY <= AssaultPlusQuad.AbsolutePosition.Y + AssaultPlusQuad.Size.Y) {
											Plus();
										}
									}
								}

								if (Cli_UI_L_LastBetMinusClickTimestamp != -1 && Now - Cli_UI_L_LastBetMinusClickTimestamp > 100) {
									// X
									if (AssaultMinusQuad.AbsolutePosition.X - AssaultMinusQuad.Size.X / 2. <= MouseX && MouseX <= AssaultMinusQuad.AbsolutePosition.X + AssaultMinusQuad.Size.X / 2.) {
										// Y
										if (AssaultMinusQuad.AbsolutePosition.Y - AssaultMinusQuad.Size.Y <= MouseY && MouseY <= AssaultMinusQuad.AbsolutePosition.Y) {
											Minus();
										}
									}
								}
							}
						}
					} else {
						Cli_UI_L_LastBetPlusClickTimestamp = -1;
						Cli_UI_L_LastBetMinusClickTimestamp = -1;
					}
				}
				
				Animate();
				HasClickedOnLastLoop = MouseLeftButton;
				
				yield;
			}
		}
	--></script>
</manialink>